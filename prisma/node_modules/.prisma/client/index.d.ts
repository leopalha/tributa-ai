
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model CreditTitle
 * 
 */
export type CreditTitle = $Result.DefaultSelection<Prisma.$CreditTitlePayload>
/**
 * Model CreditTitleTributario
 * 
 */
export type CreditTitleTributario = $Result.DefaultSelection<Prisma.$CreditTitleTributarioPayload>
/**
 * Model CreditTitleComercial
 * 
 */
export type CreditTitleComercial = $Result.DefaultSelection<Prisma.$CreditTitleComercialPayload>
/**
 * Model CreditTitleFinanceiro
 * 
 */
export type CreditTitleFinanceiro = $Result.DefaultSelection<Prisma.$CreditTitleFinanceiroPayload>
/**
 * Model CreditTitleJudicial
 * 
 */
export type CreditTitleJudicial = $Result.DefaultSelection<Prisma.$CreditTitleJudicialPayload>
/**
 * Model CreditTitleRural
 * 
 */
export type CreditTitleRural = $Result.DefaultSelection<Prisma.$CreditTitleRuralPayload>
/**
 * Model CreditTitleImobiliario
 * 
 */
export type CreditTitleImobiliario = $Result.DefaultSelection<Prisma.$CreditTitleImobiliarioPayload>
/**
 * Model CreditTitleAmbiental
 * 
 */
export type CreditTitleAmbiental = $Result.DefaultSelection<Prisma.$CreditTitleAmbientalPayload>
/**
 * Model CreditTitleEspecial
 * 
 */
export type CreditTitleEspecial = $Result.DefaultSelection<Prisma.$CreditTitleEspecialPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model Bid
 * 
 */
export type Bid = $Result.DefaultSelection<Prisma.$BidPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Auction
 * 
 */
export type Auction = $Result.DefaultSelection<Prisma.$AuctionPayload>
/**
 * Model Settlement
 * 
 */
export type Settlement = $Result.DefaultSelection<Prisma.$SettlementPayload>
/**
 * Model SettlementParticipant
 * 
 */
export type SettlementParticipant = $Result.DefaultSelection<Prisma.$SettlementParticipantPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model FiscalObligation
 * 
 */
export type FiscalObligation = $Result.DefaultSelection<Prisma.$FiscalObligationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  EMPRESA: 'EMPRESA',
  PROFISSIONAL_TRIBUTARIO: 'PROFISSIONAL_TRIBUTARIO',
  INVESTIDOR_QUALIFICADO: 'INVESTIDOR_QUALIFICADO'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CreditCategory: {
  TRIBUTARIO: 'TRIBUTARIO',
  COMERCIAL: 'COMERCIAL',
  FINANCEIRO: 'FINANCEIRO',
  JUDICIAL: 'JUDICIAL',
  RURAL: 'RURAL',
  IMOBILIARIO: 'IMOBILIARIO',
  AMBIENTAL: 'AMBIENTAL',
  ESPECIAL: 'ESPECIAL'
};

export type CreditCategory = (typeof CreditCategory)[keyof typeof CreditCategory]


export const CreditStatus: {
  DRAFT: 'DRAFT',
  PENDING_VALIDATION: 'PENDING_VALIDATION',
  VALIDATED: 'VALIDATED',
  REJECTED: 'REJECTED',
  PENDING_TOKENIZATION: 'PENDING_TOKENIZATION',
  TOKENIZED: 'TOKENIZED',
  LISTED_FOR_SALE: 'LISTED_FOR_SALE',
  IN_NEGOTIATION: 'IN_NEGOTIATION',
  NEGOTIATED: 'NEGOTIATED',
  SETTLEMENT_PENDING: 'SETTLEMENT_PENDING',
  SETTLED: 'SETTLED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type CreditStatus = (typeof CreditStatus)[keyof typeof CreditStatus]


export const TCTributarioFederal: {
  IRPJ: 'IRPJ',
  CSLL: 'CSLL',
  PIS_PASEP: 'PIS_PASEP',
  COFINS: 'COFINS',
  IPI: 'IPI',
  IOF: 'IOF'
};

export type TCTributarioFederal = (typeof TCTributarioFederal)[keyof typeof TCTributarioFederal]


export const TCTributarioEstadual: {
  ICMS: 'ICMS',
  IPVA: 'IPVA',
  ITCMD: 'ITCMD'
};

export type TCTributarioEstadual = (typeof TCTributarioEstadual)[keyof typeof TCTributarioEstadual]


export const TCTributarioMunicipal: {
  ISSQN: 'ISSQN',
  IPTU: 'IPTU',
  ITBI: 'ITBI',
  TAXAS_MUNICIPAIS: 'TAXAS_MUNICIPAIS'
};

export type TCTributarioMunicipal = (typeof TCTributarioMunicipal)[keyof typeof TCTributarioMunicipal]


export const TCComercial: {
  DUPLICATA_MERCANTIL: 'DUPLICATA_MERCANTIL',
  DUPLICATA_SERVICO: 'DUPLICATA_SERVICO',
  NOTA_PROMISSORIA: 'NOTA_PROMISSORIA',
  LETRA_CAMBIO: 'LETRA_CAMBIO'
};

export type TCComercial = (typeof TCComercial)[keyof typeof TCComercial]


export const TCFinanceiro: {
  DEBENTURE_SIMPLES: 'DEBENTURE_SIMPLES',
  DEBENTURE_INCENTIVADA: 'DEBENTURE_INCENTIVADA',
  CCB: 'CCB',
  CRI: 'CRI',
  CRA: 'CRA'
};

export type TCFinanceiro = (typeof TCFinanceiro)[keyof typeof TCFinanceiro]


export const TCJudicial: {
  PRECATORIO_COMUM: 'PRECATORIO_COMUM',
  PRECATORIO_ALIMENTAR: 'PRECATORIO_ALIMENTAR',
  CREDITORIO_PRE_JUDICIAL: 'CREDITORIO_PRE_JUDICIAL',
  HONORARIO_ADVOCATICIO: 'HONORARIO_ADVOCATICIO',
  HONORARIO_PERICIAL: 'HONORARIO_PERICIAL',
  HONORARIO_MEDICO: 'HONORARIO_MEDICO',
  HONORARIO_ENGENHARIA: 'HONORARIO_ENGENHARIA'
};

export type TCJudicial = (typeof TCJudicial)[keyof typeof TCJudicial]


export const TCRural: {
  CCR_CUSTEIO: 'CCR_CUSTEIO',
  CCR_INVESTIMENTO: 'CCR_INVESTIMENTO',
  CPR_FISICA: 'CPR_FISICA',
  CPR_FINANCEIRA: 'CPR_FINANCEIRA',
  CPR_ELETRONICA: 'CPR_ELETRONICA',
  NCR: 'NCR'
};

export type TCRural = (typeof TCRural)[keyof typeof TCRural]


export const TCImobiliario: {
  FINANCIAMENTO_SBPE: 'FINANCIAMENTO_SBPE',
  FINANCIAMENTO_PMCMV: 'FINANCIAMENTO_PMCMV',
  CONTRATO_GARANTIA_HIPOTECA: 'CONTRATO_GARANTIA_HIPOTECA',
  CONTRATO_GARANTIA_ALIENACAO: 'CONTRATO_GARANTIA_ALIENACAO'
};

export type TCImobiliario = (typeof TCImobiliario)[keyof typeof TCImobiliario]


export const TCAmbiental: {
  CREDITO_CARBONO_VOLUNTARIO: 'CREDITO_CARBONO_VOLUNTARIO',
  CREDITO_CARBONO_REGULATORIO: 'CREDITO_CARBONO_REGULATORIO',
  CREDITO_BIODIVERSIDADE: 'CREDITO_BIODIVERSIDADE',
  CREDITO_HIDRICO: 'CREDITO_HIDRICO'
};

export type TCAmbiental = (typeof TCAmbiental)[keyof typeof TCAmbiental]


export const TCEspecial: {
  RECUPERACAO_JUDICIAL_TRABALHISTA: 'RECUPERACAO_JUDICIAL_TRABALHISTA',
  RECUPERACAO_JUDICIAL_FISCAL: 'RECUPERACAO_JUDICIAL_FISCAL',
  RECUPERACAO_JUDICIAL_BANCARIO: 'RECUPERACAO_JUDICIAL_BANCARIO',
  CONSORCIO_NAO_CONTEMPLADO: 'CONSORCIO_NAO_CONTEMPLADO',
  CONSORCIO_SALDO_RESIDUAL: 'CONSORCIO_SALDO_RESIDUAL',
  PLANO_ECONOMICO_RESSARCIMENTO: 'PLANO_ECONOMICO_RESSARCIMENTO',
  ROYALTY_PROPRIEDADE_INTELECTUAL: 'ROYALTY_PROPRIEDADE_INTELECTUAL',
  ROYALTY_RECURSOS_NATURAIS: 'ROYALTY_RECURSOS_NATURAIS',
  SEGURO_SINISTRO: 'SEGURO_SINISTRO',
  SEGURO_INDENIZACAO: 'SEGURO_INDENIZACAO',
  BENEFICIO_PREVIDENCIARIO: 'BENEFICIO_PREVIDENCIARIO',
  FRETE_RODOVIARIO: 'FRETE_RODOVIARIO',
  FRETE_MARITIMO: 'FRETE_MARITIMO',
  FRETE_AEREO: 'FRETE_AEREO',
  ENERGIA_GERACAO_DISTRIBUIDA: 'ENERGIA_GERACAO_DISTRIBUIDA',
  LEASING_ARRENDAMENTO: 'LEASING_ARRENDAMENTO'
};

export type TCEspecial = (typeof TCEspecial)[keyof typeof TCEspecial]


export const OfferType: {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
  NEGOTIABLE: 'NEGOTIABLE'
};

export type OfferType = (typeof OfferType)[keyof typeof OfferType]


export const OfferStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  EXPIRED: 'EXPIRED',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED'
};

export type OfferStatus = (typeof OfferStatus)[keyof typeof OfferStatus]


export const BidStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type BidStatus = (typeof BidStatus)[keyof typeof BidStatus]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  FAILED: 'FAILED',
  DISPUTE: 'DISPUTE'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const TransactionType: {
  DIRECT: 'DIRECT',
  MARKETPLACE: 'MARKETPLACE',
  AUCTION: 'AUCTION',
  OTC: 'OTC',
  SYSTEM: 'SYSTEM'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CreditCategory = $Enums.CreditCategory

export const CreditCategory: typeof $Enums.CreditCategory

export type CreditStatus = $Enums.CreditStatus

export const CreditStatus: typeof $Enums.CreditStatus

export type TCTributarioFederal = $Enums.TCTributarioFederal

export const TCTributarioFederal: typeof $Enums.TCTributarioFederal

export type TCTributarioEstadual = $Enums.TCTributarioEstadual

export const TCTributarioEstadual: typeof $Enums.TCTributarioEstadual

export type TCTributarioMunicipal = $Enums.TCTributarioMunicipal

export const TCTributarioMunicipal: typeof $Enums.TCTributarioMunicipal

export type TCComercial = $Enums.TCComercial

export const TCComercial: typeof $Enums.TCComercial

export type TCFinanceiro = $Enums.TCFinanceiro

export const TCFinanceiro: typeof $Enums.TCFinanceiro

export type TCJudicial = $Enums.TCJudicial

export const TCJudicial: typeof $Enums.TCJudicial

export type TCRural = $Enums.TCRural

export const TCRural: typeof $Enums.TCRural

export type TCImobiliario = $Enums.TCImobiliario

export const TCImobiliario: typeof $Enums.TCImobiliario

export type TCAmbiental = $Enums.TCAmbiental

export const TCAmbiental: typeof $Enums.TCAmbiental

export type TCEspecial = $Enums.TCEspecial

export const TCEspecial: typeof $Enums.TCEspecial

export type OfferType = $Enums.OfferType

export const OfferType: typeof $Enums.OfferType

export type OfferStatus = $Enums.OfferStatus

export const OfferStatus: typeof $Enums.OfferStatus

export type BidStatus = $Enums.BidStatus

export const BidStatus: typeof $Enums.BidStatus

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitle`: Exposes CRUD operations for the **CreditTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitles
    * const creditTitles = await prisma.creditTitle.findMany()
    * ```
    */
  get creditTitle(): Prisma.CreditTitleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleTributario`: Exposes CRUD operations for the **CreditTitleTributario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleTributarios
    * const creditTitleTributarios = await prisma.creditTitleTributario.findMany()
    * ```
    */
  get creditTitleTributario(): Prisma.CreditTitleTributarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleComercial`: Exposes CRUD operations for the **CreditTitleComercial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleComercials
    * const creditTitleComercials = await prisma.creditTitleComercial.findMany()
    * ```
    */
  get creditTitleComercial(): Prisma.CreditTitleComercialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleFinanceiro`: Exposes CRUD operations for the **CreditTitleFinanceiro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleFinanceiros
    * const creditTitleFinanceiros = await prisma.creditTitleFinanceiro.findMany()
    * ```
    */
  get creditTitleFinanceiro(): Prisma.CreditTitleFinanceiroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleJudicial`: Exposes CRUD operations for the **CreditTitleJudicial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleJudicials
    * const creditTitleJudicials = await prisma.creditTitleJudicial.findMany()
    * ```
    */
  get creditTitleJudicial(): Prisma.CreditTitleJudicialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleRural`: Exposes CRUD operations for the **CreditTitleRural** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleRurals
    * const creditTitleRurals = await prisma.creditTitleRural.findMany()
    * ```
    */
  get creditTitleRural(): Prisma.CreditTitleRuralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleImobiliario`: Exposes CRUD operations for the **CreditTitleImobiliario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleImobiliarios
    * const creditTitleImobiliarios = await prisma.creditTitleImobiliario.findMany()
    * ```
    */
  get creditTitleImobiliario(): Prisma.CreditTitleImobiliarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleAmbiental`: Exposes CRUD operations for the **CreditTitleAmbiental** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleAmbientals
    * const creditTitleAmbientals = await prisma.creditTitleAmbiental.findMany()
    * ```
    */
  get creditTitleAmbiental(): Prisma.CreditTitleAmbientalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTitleEspecial`: Exposes CRUD operations for the **CreditTitleEspecial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTitleEspecials
    * const creditTitleEspecials = await prisma.creditTitleEspecial.findMany()
    * ```
    */
  get creditTitleEspecial(): Prisma.CreditTitleEspecialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bid`: Exposes CRUD operations for the **Bid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bids
    * const bids = await prisma.bid.findMany()
    * ```
    */
  get bid(): Prisma.BidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auction`: Exposes CRUD operations for the **Auction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auctions
    * const auctions = await prisma.auction.findMany()
    * ```
    */
  get auction(): Prisma.AuctionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settlement`: Exposes CRUD operations for the **Settlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settlements
    * const settlements = await prisma.settlement.findMany()
    * ```
    */
  get settlement(): Prisma.SettlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settlementParticipant`: Exposes CRUD operations for the **SettlementParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettlementParticipants
    * const settlementParticipants = await prisma.settlementParticipant.findMany()
    * ```
    */
  get settlementParticipant(): Prisma.SettlementParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fiscalObligation`: Exposes CRUD operations for the **FiscalObligation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalObligations
    * const fiscalObligations = await prisma.fiscalObligation.findMany()
    * ```
    */
  get fiscalObligation(): Prisma.FiscalObligationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Empresa: 'Empresa',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    CreditTitle: 'CreditTitle',
    CreditTitleTributario: 'CreditTitleTributario',
    CreditTitleComercial: 'CreditTitleComercial',
    CreditTitleFinanceiro: 'CreditTitleFinanceiro',
    CreditTitleJudicial: 'CreditTitleJudicial',
    CreditTitleRural: 'CreditTitleRural',
    CreditTitleImobiliario: 'CreditTitleImobiliario',
    CreditTitleAmbiental: 'CreditTitleAmbiental',
    CreditTitleEspecial: 'CreditTitleEspecial',
    Document: 'Document',
    Offer: 'Offer',
    Bid: 'Bid',
    Transaction: 'Transaction',
    Auction: 'Auction',
    Settlement: 'Settlement',
    SettlementParticipant: 'SettlementParticipant',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    FiscalObligation: 'FiscalObligation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "empresa" | "account" | "session" | "verificationToken" | "creditTitle" | "creditTitleTributario" | "creditTitleComercial" | "creditTitleFinanceiro" | "creditTitleJudicial" | "creditTitleRural" | "creditTitleImobiliario" | "creditTitleAmbiental" | "creditTitleEspecial" | "document" | "offer" | "bid" | "transaction" | "auction" | "settlement" | "settlementParticipant" | "notification" | "auditLog" | "fiscalObligation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpresaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmpresaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      CreditTitle: {
        payload: Prisma.$CreditTitlePayload<ExtArgs>
        fields: Prisma.CreditTitleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>
          }
          findFirst: {
            args: Prisma.CreditTitleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>
          }
          findMany: {
            args: Prisma.CreditTitleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>[]
          }
          create: {
            args: Prisma.CreditTitleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>
          }
          createMany: {
            args: Prisma.CreditTitleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>[]
          }
          delete: {
            args: Prisma.CreditTitleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>
          }
          update: {
            args: Prisma.CreditTitleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitlePayload>
          }
          aggregate: {
            args: Prisma.CreditTitleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitle>
          }
          groupBy: {
            args: Prisma.CreditTitleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleTributario: {
        payload: Prisma.$CreditTitleTributarioPayload<ExtArgs>
        fields: Prisma.CreditTitleTributarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleTributarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleTributarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleTributarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleTributarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>
          }
          findMany: {
            args: Prisma.CreditTitleTributarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>[]
          }
          create: {
            args: Prisma.CreditTitleTributarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>
          }
          createMany: {
            args: Prisma.CreditTitleTributarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleTributarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleTributarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>
          }
          update: {
            args: Prisma.CreditTitleTributarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleTributarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleTributarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleTributarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleTributarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleTributarioPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleTributarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleTributario>
          }
          groupBy: {
            args: Prisma.CreditTitleTributarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleTributarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleTributarioCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleTributarioCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleComercial: {
        payload: Prisma.$CreditTitleComercialPayload<ExtArgs>
        fields: Prisma.CreditTitleComercialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleComercialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleComercialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleComercialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleComercialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>
          }
          findMany: {
            args: Prisma.CreditTitleComercialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>[]
          }
          create: {
            args: Prisma.CreditTitleComercialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>
          }
          createMany: {
            args: Prisma.CreditTitleComercialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleComercialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleComercialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>
          }
          update: {
            args: Prisma.CreditTitleComercialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleComercialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleComercialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleComercialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleComercialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleComercialPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleComercialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleComercial>
          }
          groupBy: {
            args: Prisma.CreditTitleComercialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleComercialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleComercialCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleComercialCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleFinanceiro: {
        payload: Prisma.$CreditTitleFinanceiroPayload<ExtArgs>
        fields: Prisma.CreditTitleFinanceiroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleFinanceiroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleFinanceiroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleFinanceiroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleFinanceiroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>
          }
          findMany: {
            args: Prisma.CreditTitleFinanceiroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>[]
          }
          create: {
            args: Prisma.CreditTitleFinanceiroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>
          }
          createMany: {
            args: Prisma.CreditTitleFinanceiroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleFinanceiroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleFinanceiroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>
          }
          update: {
            args: Prisma.CreditTitleFinanceiroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleFinanceiroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleFinanceiroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleFinanceiroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleFinanceiroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleFinanceiroPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleFinanceiroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleFinanceiro>
          }
          groupBy: {
            args: Prisma.CreditTitleFinanceiroGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleFinanceiroGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleFinanceiroCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleFinanceiroCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleJudicial: {
        payload: Prisma.$CreditTitleJudicialPayload<ExtArgs>
        fields: Prisma.CreditTitleJudicialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleJudicialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleJudicialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleJudicialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleJudicialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>
          }
          findMany: {
            args: Prisma.CreditTitleJudicialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>[]
          }
          create: {
            args: Prisma.CreditTitleJudicialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>
          }
          createMany: {
            args: Prisma.CreditTitleJudicialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleJudicialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleJudicialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>
          }
          update: {
            args: Prisma.CreditTitleJudicialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleJudicialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleJudicialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleJudicialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleJudicialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleJudicialPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleJudicialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleJudicial>
          }
          groupBy: {
            args: Prisma.CreditTitleJudicialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleJudicialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleJudicialCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleJudicialCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleRural: {
        payload: Prisma.$CreditTitleRuralPayload<ExtArgs>
        fields: Prisma.CreditTitleRuralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleRuralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleRuralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleRuralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleRuralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>
          }
          findMany: {
            args: Prisma.CreditTitleRuralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>[]
          }
          create: {
            args: Prisma.CreditTitleRuralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>
          }
          createMany: {
            args: Prisma.CreditTitleRuralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleRuralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleRuralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>
          }
          update: {
            args: Prisma.CreditTitleRuralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleRuralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleRuralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleRuralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleRuralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleRuralPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleRuralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleRural>
          }
          groupBy: {
            args: Prisma.CreditTitleRuralGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleRuralGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleRuralCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleRuralCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleImobiliario: {
        payload: Prisma.$CreditTitleImobiliarioPayload<ExtArgs>
        fields: Prisma.CreditTitleImobiliarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleImobiliarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleImobiliarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleImobiliarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleImobiliarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>
          }
          findMany: {
            args: Prisma.CreditTitleImobiliarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>[]
          }
          create: {
            args: Prisma.CreditTitleImobiliarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>
          }
          createMany: {
            args: Prisma.CreditTitleImobiliarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleImobiliarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleImobiliarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>
          }
          update: {
            args: Prisma.CreditTitleImobiliarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleImobiliarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleImobiliarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleImobiliarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleImobiliarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleImobiliarioPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleImobiliarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleImobiliario>
          }
          groupBy: {
            args: Prisma.CreditTitleImobiliarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleImobiliarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleImobiliarioCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleImobiliarioCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleAmbiental: {
        payload: Prisma.$CreditTitleAmbientalPayload<ExtArgs>
        fields: Prisma.CreditTitleAmbientalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleAmbientalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleAmbientalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleAmbientalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleAmbientalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>
          }
          findMany: {
            args: Prisma.CreditTitleAmbientalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>[]
          }
          create: {
            args: Prisma.CreditTitleAmbientalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>
          }
          createMany: {
            args: Prisma.CreditTitleAmbientalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleAmbientalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleAmbientalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>
          }
          update: {
            args: Prisma.CreditTitleAmbientalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleAmbientalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleAmbientalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleAmbientalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleAmbientalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleAmbientalPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleAmbientalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleAmbiental>
          }
          groupBy: {
            args: Prisma.CreditTitleAmbientalGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleAmbientalGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleAmbientalCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleAmbientalCountAggregateOutputType> | number
          }
        }
      }
      CreditTitleEspecial: {
        payload: Prisma.$CreditTitleEspecialPayload<ExtArgs>
        fields: Prisma.CreditTitleEspecialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTitleEspecialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTitleEspecialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>
          }
          findFirst: {
            args: Prisma.CreditTitleEspecialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTitleEspecialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>
          }
          findMany: {
            args: Prisma.CreditTitleEspecialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>[]
          }
          create: {
            args: Prisma.CreditTitleEspecialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>
          }
          createMany: {
            args: Prisma.CreditTitleEspecialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTitleEspecialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>[]
          }
          delete: {
            args: Prisma.CreditTitleEspecialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>
          }
          update: {
            args: Prisma.CreditTitleEspecialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>
          }
          deleteMany: {
            args: Prisma.CreditTitleEspecialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTitleEspecialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTitleEspecialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>[]
          }
          upsert: {
            args: Prisma.CreditTitleEspecialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTitleEspecialPayload>
          }
          aggregate: {
            args: Prisma.CreditTitleEspecialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTitleEspecial>
          }
          groupBy: {
            args: Prisma.CreditTitleEspecialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleEspecialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTitleEspecialCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTitleEspecialCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      Bid: {
        payload: Prisma.$BidPayload<ExtArgs>
        fields: Prisma.BidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findFirst: {
            args: Prisma.BidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findMany: {
            args: Prisma.BidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          create: {
            args: Prisma.BidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          createMany: {
            args: Prisma.BidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          delete: {
            args: Prisma.BidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          update: {
            args: Prisma.BidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          deleteMany: {
            args: Prisma.BidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          upsert: {
            args: Prisma.BidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          aggregate: {
            args: Prisma.BidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBid>
          }
          groupBy: {
            args: Prisma.BidGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidCountArgs<ExtArgs>
            result: $Utils.Optional<BidCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Auction: {
        payload: Prisma.$AuctionPayload<ExtArgs>
        fields: Prisma.AuctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          findFirst: {
            args: Prisma.AuctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          findMany: {
            args: Prisma.AuctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          create: {
            args: Prisma.AuctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          createMany: {
            args: Prisma.AuctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          delete: {
            args: Prisma.AuctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          update: {
            args: Prisma.AuctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          deleteMany: {
            args: Prisma.AuctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          upsert: {
            args: Prisma.AuctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          aggregate: {
            args: Prisma.AuctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuction>
          }
          groupBy: {
            args: Prisma.AuctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionCountAggregateOutputType> | number
          }
        }
      }
      Settlement: {
        payload: Prisma.$SettlementPayload<ExtArgs>
        fields: Prisma.SettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          findFirst: {
            args: Prisma.SettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          findMany: {
            args: Prisma.SettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          create: {
            args: Prisma.SettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          createMany: {
            args: Prisma.SettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          delete: {
            args: Prisma.SettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          update: {
            args: Prisma.SettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          deleteMany: {
            args: Prisma.SettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettlementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          upsert: {
            args: Prisma.SettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          aggregate: {
            args: Prisma.SettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlement>
          }
          groupBy: {
            args: Prisma.SettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettlementCountArgs<ExtArgs>
            result: $Utils.Optional<SettlementCountAggregateOutputType> | number
          }
        }
      }
      SettlementParticipant: {
        payload: Prisma.$SettlementParticipantPayload<ExtArgs>
        fields: Prisma.SettlementParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettlementParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettlementParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>
          }
          findFirst: {
            args: Prisma.SettlementParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettlementParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>
          }
          findMany: {
            args: Prisma.SettlementParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>[]
          }
          create: {
            args: Prisma.SettlementParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>
          }
          createMany: {
            args: Prisma.SettlementParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettlementParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>[]
          }
          delete: {
            args: Prisma.SettlementParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>
          }
          update: {
            args: Prisma.SettlementParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>
          }
          deleteMany: {
            args: Prisma.SettlementParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettlementParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettlementParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>[]
          }
          upsert: {
            args: Prisma.SettlementParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementParticipantPayload>
          }
          aggregate: {
            args: Prisma.SettlementParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlementParticipant>
          }
          groupBy: {
            args: Prisma.SettlementParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettlementParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettlementParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<SettlementParticipantCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      FiscalObligation: {
        payload: Prisma.$FiscalObligationPayload<ExtArgs>
        fields: Prisma.FiscalObligationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiscalObligationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiscalObligationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>
          }
          findFirst: {
            args: Prisma.FiscalObligationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiscalObligationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>
          }
          findMany: {
            args: Prisma.FiscalObligationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>[]
          }
          create: {
            args: Prisma.FiscalObligationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>
          }
          createMany: {
            args: Prisma.FiscalObligationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FiscalObligationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>[]
          }
          delete: {
            args: Prisma.FiscalObligationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>
          }
          update: {
            args: Prisma.FiscalObligationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>
          }
          deleteMany: {
            args: Prisma.FiscalObligationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FiscalObligationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FiscalObligationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>[]
          }
          upsert: {
            args: Prisma.FiscalObligationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalObligationPayload>
          }
          aggregate: {
            args: Prisma.FiscalObligationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalObligation>
          }
          groupBy: {
            args: Prisma.FiscalObligationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalObligationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiscalObligationCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalObligationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    empresa?: EmpresaOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    creditTitle?: CreditTitleOmit
    creditTitleTributario?: CreditTitleTributarioOmit
    creditTitleComercial?: CreditTitleComercialOmit
    creditTitleFinanceiro?: CreditTitleFinanceiroOmit
    creditTitleJudicial?: CreditTitleJudicialOmit
    creditTitleRural?: CreditTitleRuralOmit
    creditTitleImobiliario?: CreditTitleImobiliarioOmit
    creditTitleAmbiental?: CreditTitleAmbientalOmit
    creditTitleEspecial?: CreditTitleEspecialOmit
    document?: DocumentOmit
    offer?: OfferOmit
    bid?: BidOmit
    transaction?: TransactionOmit
    auction?: AuctionOmit
    settlement?: SettlementOmit
    settlementParticipant?: SettlementParticipantOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    fiscalObligation?: FiscalObligationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    issuedCredits: number
    ownedCredits: number
    documents: number
    offers: number
    bids: number
    transactionsAsSeller: number
    transactionsAsBuyer: number
    createdTransactions: number
    auctionsAsSeller: number
    auctionsAsWinner: number
    settlementParticipants: number
    notifications: number
    auditLogs: number
    fiscalObligations: number
    empresasRepresentadas: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    issuedCredits?: boolean | UserCountOutputTypeCountIssuedCreditsArgs
    ownedCredits?: boolean | UserCountOutputTypeCountOwnedCreditsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    offers?: boolean | UserCountOutputTypeCountOffersArgs
    bids?: boolean | UserCountOutputTypeCountBidsArgs
    transactionsAsSeller?: boolean | UserCountOutputTypeCountTransactionsAsSellerArgs
    transactionsAsBuyer?: boolean | UserCountOutputTypeCountTransactionsAsBuyerArgs
    createdTransactions?: boolean | UserCountOutputTypeCountCreatedTransactionsArgs
    auctionsAsSeller?: boolean | UserCountOutputTypeCountAuctionsAsSellerArgs
    auctionsAsWinner?: boolean | UserCountOutputTypeCountAuctionsAsWinnerArgs
    settlementParticipants?: boolean | UserCountOutputTypeCountSettlementParticipantsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    fiscalObligations?: boolean | UserCountOutputTypeCountFiscalObligationsArgs
    empresasRepresentadas?: boolean | UserCountOutputTypeCountEmpresasRepresentadasArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIssuedCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsAsBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuctionsAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuctionsAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSettlementParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFiscalObligationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalObligationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmpresasRepresentadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
  }


  /**
   * Count Type CreditTitleCountOutputType
   */

  export type CreditTitleCountOutputType = {
    documents: number
    offers: number
    transactions: number
    auctions: number
  }

  export type CreditTitleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | CreditTitleCountOutputTypeCountDocumentsArgs
    offers?: boolean | CreditTitleCountOutputTypeCountOffersArgs
    transactions?: boolean | CreditTitleCountOutputTypeCountTransactionsArgs
    auctions?: boolean | CreditTitleCountOutputTypeCountAuctionsArgs
  }

  // Custom InputTypes
  /**
   * CreditTitleCountOutputType without action
   */
  export type CreditTitleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleCountOutputType
     */
    select?: CreditTitleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreditTitleCountOutputType without action
   */
  export type CreditTitleCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * CreditTitleCountOutputType without action
   */
  export type CreditTitleCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * CreditTitleCountOutputType without action
   */
  export type CreditTitleCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CreditTitleCountOutputType without action
   */
  export type CreditTitleCountOutputTypeCountAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    bids: number
    transactions: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | OfferCountOutputTypeCountBidsArgs
    transactions?: boolean | OfferCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type BidCountOutputType
   */

  export type BidCountOutputType = {
    transactions: number
  }

  export type BidCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BidCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BidCountOutputType without action
   */
  export type BidCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidCountOutputType
     */
    select?: BidCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BidCountOutputType without action
   */
  export type BidCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type SettlementCountOutputType
   */

  export type SettlementCountOutputType = {
    participants: number
  }

  export type SettlementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | SettlementCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * SettlementCountOutputType without action
   */
  export type SettlementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementCountOutputType
     */
    select?: SettlementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SettlementCountOutputType without action
   */
  export type SettlementCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementParticipantWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    issuedCredits?: boolean | User$issuedCreditsArgs<ExtArgs>
    ownedCredits?: boolean | User$ownedCreditsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    offers?: boolean | User$offersArgs<ExtArgs>
    bids?: boolean | User$bidsArgs<ExtArgs>
    transactionsAsSeller?: boolean | User$transactionsAsSellerArgs<ExtArgs>
    transactionsAsBuyer?: boolean | User$transactionsAsBuyerArgs<ExtArgs>
    createdTransactions?: boolean | User$createdTransactionsArgs<ExtArgs>
    auctionsAsSeller?: boolean | User$auctionsAsSellerArgs<ExtArgs>
    auctionsAsWinner?: boolean | User$auctionsAsWinnerArgs<ExtArgs>
    settlementParticipants?: boolean | User$settlementParticipantsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    fiscalObligations?: boolean | User$fiscalObligationsArgs<ExtArgs>
    empresasRepresentadas?: boolean | User$empresasRepresentadasArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    issuedCredits?: boolean | User$issuedCreditsArgs<ExtArgs>
    ownedCredits?: boolean | User$ownedCreditsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    offers?: boolean | User$offersArgs<ExtArgs>
    bids?: boolean | User$bidsArgs<ExtArgs>
    transactionsAsSeller?: boolean | User$transactionsAsSellerArgs<ExtArgs>
    transactionsAsBuyer?: boolean | User$transactionsAsBuyerArgs<ExtArgs>
    createdTransactions?: boolean | User$createdTransactionsArgs<ExtArgs>
    auctionsAsSeller?: boolean | User$auctionsAsSellerArgs<ExtArgs>
    auctionsAsWinner?: boolean | User$auctionsAsWinnerArgs<ExtArgs>
    settlementParticipants?: boolean | User$settlementParticipantsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    fiscalObligations?: boolean | User$fiscalObligationsArgs<ExtArgs>
    empresasRepresentadas?: boolean | User$empresasRepresentadasArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      issuedCredits: Prisma.$CreditTitlePayload<ExtArgs>[]
      ownedCredits: Prisma.$CreditTitlePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      bids: Prisma.$BidPayload<ExtArgs>[]
      transactionsAsSeller: Prisma.$TransactionPayload<ExtArgs>[]
      transactionsAsBuyer: Prisma.$TransactionPayload<ExtArgs>[]
      createdTransactions: Prisma.$TransactionPayload<ExtArgs>[]
      auctionsAsSeller: Prisma.$AuctionPayload<ExtArgs>[]
      auctionsAsWinner: Prisma.$AuctionPayload<ExtArgs>[]
      settlementParticipants: Prisma.$SettlementParticipantPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      fiscalObligations: Prisma.$FiscalObligationPayload<ExtArgs>[]
      empresasRepresentadas: Prisma.$EmpresaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      password: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    issuedCredits<T extends User$issuedCreditsArgs<ExtArgs> = {}>(args?: Subset<T, User$issuedCreditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedCredits<T extends User$ownedCreditsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedCreditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends User$offersArgs<ExtArgs> = {}>(args?: Subset<T, User$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bids<T extends User$bidsArgs<ExtArgs> = {}>(args?: Subset<T, User$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionsAsSeller<T extends User$transactionsAsSellerArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsAsSellerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionsAsBuyer<T extends User$transactionsAsBuyerArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsAsBuyerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTransactions<T extends User$createdTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auctionsAsSeller<T extends User$auctionsAsSellerArgs<ExtArgs> = {}>(args?: Subset<T, User$auctionsAsSellerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auctionsAsWinner<T extends User$auctionsAsWinnerArgs<ExtArgs> = {}>(args?: Subset<T, User$auctionsAsWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settlementParticipants<T extends User$settlementParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$settlementParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fiscalObligations<T extends User$fiscalObligationsArgs<ExtArgs> = {}>(args?: Subset<T, User$fiscalObligationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    empresasRepresentadas<T extends User$empresasRepresentadasArgs<ExtArgs> = {}>(args?: Subset<T, User$empresasRepresentadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.issuedCredits
   */
  export type User$issuedCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    where?: CreditTitleWhereInput
    orderBy?: CreditTitleOrderByWithRelationInput | CreditTitleOrderByWithRelationInput[]
    cursor?: CreditTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditTitleScalarFieldEnum | CreditTitleScalarFieldEnum[]
  }

  /**
   * User.ownedCredits
   */
  export type User$ownedCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    where?: CreditTitleWhereInput
    orderBy?: CreditTitleOrderByWithRelationInput | CreditTitleOrderByWithRelationInput[]
    cursor?: CreditTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditTitleScalarFieldEnum | CreditTitleScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.offers
   */
  export type User$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * User.bids
   */
  export type User$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * User.transactionsAsSeller
   */
  export type User$transactionsAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.transactionsAsBuyer
   */
  export type User$transactionsAsBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.createdTransactions
   */
  export type User$createdTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.auctionsAsSeller
   */
  export type User$auctionsAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * User.auctionsAsWinner
   */
  export type User$auctionsAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * User.settlementParticipants
   */
  export type User$settlementParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    where?: SettlementParticipantWhereInput
    orderBy?: SettlementParticipantOrderByWithRelationInput | SettlementParticipantOrderByWithRelationInput[]
    cursor?: SettlementParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementParticipantScalarFieldEnum | SettlementParticipantScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.fiscalObligations
   */
  export type User$fiscalObligationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    where?: FiscalObligationWhereInput
    orderBy?: FiscalObligationOrderByWithRelationInput | FiscalObligationOrderByWithRelationInput[]
    cursor?: FiscalObligationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FiscalObligationScalarFieldEnum | FiscalObligationScalarFieldEnum[]
  }

  /**
   * User.empresasRepresentadas
   */
  export type User$empresasRepresentadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    cursor?: EmpresaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaMinAggregateOutputType = {
    id: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    cnpj: string | null
    inscEstadual: string | null
    inscMunicipal: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    website: string | null
    status: string | null
    representantePrincipalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    cnpj: string | null
    inscEstadual: string | null
    inscMunicipal: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    website: string | null
    status: string | null
    representantePrincipalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpresaCountAggregateOutputType = {
    id: number
    razaoSocial: number
    nomeFantasia: number
    cnpj: number
    inscEstadual: number
    inscMunicipal: number
    endereco: number
    telefone: number
    email: number
    website: number
    status: number
    representantePrincipalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmpresaMinAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpj?: true
    inscEstadual?: true
    inscMunicipal?: true
    endereco?: true
    telefone?: true
    email?: true
    website?: true
    status?: true
    representantePrincipalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpj?: true
    inscEstadual?: true
    inscMunicipal?: true
    endereco?: true
    telefone?: true
    email?: true
    website?: true
    status?: true
    representantePrincipalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpresaCountAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpj?: true
    inscEstadual?: true
    inscMunicipal?: true
    endereco?: true
    telefone?: true
    email?: true
    website?: true
    status?: true
    representantePrincipalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id: string
    razaoSocial: string
    nomeFantasia: string | null
    cnpj: string
    inscEstadual: string | null
    inscMunicipal: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    website: string | null
    status: string
    representantePrincipalId: string
    createdAt: Date
    updatedAt: Date
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscEstadual?: boolean
    inscMunicipal?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    website?: boolean
    status?: boolean
    representantePrincipalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    representantePrincipal?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscEstadual?: boolean
    inscMunicipal?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    website?: boolean
    status?: boolean
    representantePrincipalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    representantePrincipal?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscEstadual?: boolean
    inscMunicipal?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    website?: boolean
    status?: boolean
    representantePrincipalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    representantePrincipal?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectScalar = {
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscEstadual?: boolean
    inscMunicipal?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    website?: boolean
    status?: boolean
    representantePrincipalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmpresaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "razaoSocial" | "nomeFantasia" | "cnpj" | "inscEstadual" | "inscMunicipal" | "endereco" | "telefone" | "email" | "website" | "status" | "representantePrincipalId" | "createdAt" | "updatedAt", ExtArgs["result"]["empresa"]>
  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    representantePrincipal?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmpresaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    representantePrincipal?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmpresaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    representantePrincipal?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      representantePrincipal: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      razaoSocial: string
      nomeFantasia: string | null
      cnpj: string
      inscEstadual: string | null
      inscMunicipal: string | null
      endereco: string | null
      telefone: string | null
      email: string | null
      website: string | null
      status: string
      representantePrincipalId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaWithIdOnly = await prisma.empresa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empresas and returns the data saved in the database.
     * @param {EmpresaCreateManyAndReturnArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empresas and only return the `id`
     * const empresaWithIdOnly = await prisma.empresa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpresaCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpresaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas and returns the data updated in the database.
     * @param {EmpresaUpdateManyAndReturnArgs} args - Arguments to update many Empresas.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Empresas and only return the `id`
     * const empresaWithIdOnly = await prisma.empresa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmpresaUpdateManyAndReturnArgs>(args: SelectSubset<T, EmpresaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    representantePrincipal<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */
  interface EmpresaFieldRefs {
    readonly id: FieldRef<"Empresa", 'String'>
    readonly razaoSocial: FieldRef<"Empresa", 'String'>
    readonly nomeFantasia: FieldRef<"Empresa", 'String'>
    readonly cnpj: FieldRef<"Empresa", 'String'>
    readonly inscEstadual: FieldRef<"Empresa", 'String'>
    readonly inscMunicipal: FieldRef<"Empresa", 'String'>
    readonly endereco: FieldRef<"Empresa", 'String'>
    readonly telefone: FieldRef<"Empresa", 'String'>
    readonly email: FieldRef<"Empresa", 'String'>
    readonly website: FieldRef<"Empresa", 'String'>
    readonly status: FieldRef<"Empresa", 'String'>
    readonly representantePrincipalId: FieldRef<"Empresa", 'String'>
    readonly createdAt: FieldRef<"Empresa", 'DateTime'>
    readonly updatedAt: FieldRef<"Empresa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
  }

  /**
   * Empresa createManyAndReturn
   */
  export type EmpresaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
    /**
     * Limit how many Empresas to update.
     */
    limit?: number
  }

  /**
   * Empresa updateManyAndReturn
   */
  export type EmpresaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
    /**
     * Limit how many Empresas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
    /**
     * Limit how many Empresas to delete.
     */
    limit?: number
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Empresa
     */
    omit?: EmpresaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model CreditTitle
   */

  export type AggregateCreditTitle = {
    _count: CreditTitleCountAggregateOutputType | null
    _avg: CreditTitleAvgAggregateOutputType | null
    _sum: CreditTitleSumAggregateOutputType | null
    _min: CreditTitleMinAggregateOutputType | null
    _max: CreditTitleMaxAggregateOutputType | null
  }

  export type CreditTitleAvgAggregateOutputType = {
    valueNominal: number | null
    valueCurrent: number | null
    listingPrice: number | null
  }

  export type CreditTitleSumAggregateOutputType = {
    valueNominal: number | null
    valueCurrent: number | null
    listingPrice: number | null
  }

  export type CreditTitleMinAggregateOutputType = {
    id: string | null
    category: $Enums.CreditCategory | null
    valueNominal: number | null
    valueCurrent: number | null
    issueDate: Date | null
    expiryDate: Date | null
    issuerId: string | null
    ownerId: string | null
    status: $Enums.CreditStatus | null
    tokenId: string | null
    tokenStandard: string | null
    blockchainTxHash: string | null
    isListed: boolean | null
    listingPrice: number | null
    listingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditTitleMaxAggregateOutputType = {
    id: string | null
    category: $Enums.CreditCategory | null
    valueNominal: number | null
    valueCurrent: number | null
    issueDate: Date | null
    expiryDate: Date | null
    issuerId: string | null
    ownerId: string | null
    status: $Enums.CreditStatus | null
    tokenId: string | null
    tokenStandard: string | null
    blockchainTxHash: string | null
    isListed: boolean | null
    listingPrice: number | null
    listingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditTitleCountAggregateOutputType = {
    id: number
    category: number
    valueNominal: number
    valueCurrent: number
    issueDate: number
    expiryDate: number
    issuerId: number
    ownerId: number
    status: number
    tokenId: number
    tokenStandard: number
    blockchainTxHash: number
    isListed: number
    listingPrice: number
    listingDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreditTitleAvgAggregateInputType = {
    valueNominal?: true
    valueCurrent?: true
    listingPrice?: true
  }

  export type CreditTitleSumAggregateInputType = {
    valueNominal?: true
    valueCurrent?: true
    listingPrice?: true
  }

  export type CreditTitleMinAggregateInputType = {
    id?: true
    category?: true
    valueNominal?: true
    valueCurrent?: true
    issueDate?: true
    expiryDate?: true
    issuerId?: true
    ownerId?: true
    status?: true
    tokenId?: true
    tokenStandard?: true
    blockchainTxHash?: true
    isListed?: true
    listingPrice?: true
    listingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditTitleMaxAggregateInputType = {
    id?: true
    category?: true
    valueNominal?: true
    valueCurrent?: true
    issueDate?: true
    expiryDate?: true
    issuerId?: true
    ownerId?: true
    status?: true
    tokenId?: true
    tokenStandard?: true
    blockchainTxHash?: true
    isListed?: true
    listingPrice?: true
    listingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditTitleCountAggregateInputType = {
    id?: true
    category?: true
    valueNominal?: true
    valueCurrent?: true
    issueDate?: true
    expiryDate?: true
    issuerId?: true
    ownerId?: true
    status?: true
    tokenId?: true
    tokenStandard?: true
    blockchainTxHash?: true
    isListed?: true
    listingPrice?: true
    listingDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreditTitleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitle to aggregate.
     */
    where?: CreditTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitles to fetch.
     */
    orderBy?: CreditTitleOrderByWithRelationInput | CreditTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitles
    **/
    _count?: true | CreditTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleMaxAggregateInputType
  }

  export type GetCreditTitleAggregateType<T extends CreditTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitle[P]>
      : GetScalarType<T[P], AggregateCreditTitle[P]>
  }




  export type CreditTitleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleWhereInput
    orderBy?: CreditTitleOrderByWithAggregationInput | CreditTitleOrderByWithAggregationInput[]
    by: CreditTitleScalarFieldEnum[] | CreditTitleScalarFieldEnum
    having?: CreditTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleCountAggregateInputType | true
    _avg?: CreditTitleAvgAggregateInputType
    _sum?: CreditTitleSumAggregateInputType
    _min?: CreditTitleMinAggregateInputType
    _max?: CreditTitleMaxAggregateInputType
  }

  export type CreditTitleGroupByOutputType = {
    id: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date
    expiryDate: Date | null
    issuerId: string
    ownerId: string
    status: $Enums.CreditStatus
    tokenId: string | null
    tokenStandard: string | null
    blockchainTxHash: string | null
    isListed: boolean
    listingPrice: number | null
    listingDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CreditTitleCountAggregateOutputType | null
    _avg: CreditTitleAvgAggregateOutputType | null
    _sum: CreditTitleSumAggregateOutputType | null
    _min: CreditTitleMinAggregateOutputType | null
    _max: CreditTitleMaxAggregateOutputType | null
  }

  type GetCreditTitleGroupByPayload<T extends CreditTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    valueNominal?: boolean
    valueCurrent?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuerId?: boolean
    ownerId?: boolean
    status?: boolean
    tokenId?: boolean
    tokenStandard?: boolean
    blockchainTxHash?: boolean
    isListed?: boolean
    listingPrice?: boolean
    listingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    detailsTributario?: boolean | CreditTitle$detailsTributarioArgs<ExtArgs>
    detailsComercial?: boolean | CreditTitle$detailsComercialArgs<ExtArgs>
    detailsFinanceiro?: boolean | CreditTitle$detailsFinanceiroArgs<ExtArgs>
    detailsJudicial?: boolean | CreditTitle$detailsJudicialArgs<ExtArgs>
    detailsRural?: boolean | CreditTitle$detailsRuralArgs<ExtArgs>
    detailsImobiliario?: boolean | CreditTitle$detailsImobiliarioArgs<ExtArgs>
    detailsAmbiental?: boolean | CreditTitle$detailsAmbientalArgs<ExtArgs>
    detailsEspecial?: boolean | CreditTitle$detailsEspecialArgs<ExtArgs>
    documents?: boolean | CreditTitle$documentsArgs<ExtArgs>
    offers?: boolean | CreditTitle$offersArgs<ExtArgs>
    transactions?: boolean | CreditTitle$transactionsArgs<ExtArgs>
    auctions?: boolean | CreditTitle$auctionsArgs<ExtArgs>
    _count?: boolean | CreditTitleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitle"]>

  export type CreditTitleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    valueNominal?: boolean
    valueCurrent?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuerId?: boolean
    ownerId?: boolean
    status?: boolean
    tokenId?: boolean
    tokenStandard?: boolean
    blockchainTxHash?: boolean
    isListed?: boolean
    listingPrice?: boolean
    listingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitle"]>

  export type CreditTitleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    valueNominal?: boolean
    valueCurrent?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuerId?: boolean
    ownerId?: boolean
    status?: boolean
    tokenId?: boolean
    tokenStandard?: boolean
    blockchainTxHash?: boolean
    isListed?: boolean
    listingPrice?: boolean
    listingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitle"]>

  export type CreditTitleSelectScalar = {
    id?: boolean
    category?: boolean
    valueNominal?: boolean
    valueCurrent?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuerId?: boolean
    ownerId?: boolean
    status?: boolean
    tokenId?: boolean
    tokenStandard?: boolean
    blockchainTxHash?: boolean
    isListed?: boolean
    listingPrice?: boolean
    listingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreditTitleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "valueNominal" | "valueCurrent" | "issueDate" | "expiryDate" | "issuerId" | "ownerId" | "status" | "tokenId" | "tokenStandard" | "blockchainTxHash" | "isListed" | "listingPrice" | "listingDate" | "createdAt" | "updatedAt", ExtArgs["result"]["creditTitle"]>
  export type CreditTitleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    detailsTributario?: boolean | CreditTitle$detailsTributarioArgs<ExtArgs>
    detailsComercial?: boolean | CreditTitle$detailsComercialArgs<ExtArgs>
    detailsFinanceiro?: boolean | CreditTitle$detailsFinanceiroArgs<ExtArgs>
    detailsJudicial?: boolean | CreditTitle$detailsJudicialArgs<ExtArgs>
    detailsRural?: boolean | CreditTitle$detailsRuralArgs<ExtArgs>
    detailsImobiliario?: boolean | CreditTitle$detailsImobiliarioArgs<ExtArgs>
    detailsAmbiental?: boolean | CreditTitle$detailsAmbientalArgs<ExtArgs>
    detailsEspecial?: boolean | CreditTitle$detailsEspecialArgs<ExtArgs>
    documents?: boolean | CreditTitle$documentsArgs<ExtArgs>
    offers?: boolean | CreditTitle$offersArgs<ExtArgs>
    transactions?: boolean | CreditTitle$transactionsArgs<ExtArgs>
    auctions?: boolean | CreditTitle$auctionsArgs<ExtArgs>
    _count?: boolean | CreditTitleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreditTitleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditTitleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CreditTitlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitle"
    objects: {
      issuer: Prisma.$UserPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      detailsTributario: Prisma.$CreditTitleTributarioPayload<ExtArgs> | null
      detailsComercial: Prisma.$CreditTitleComercialPayload<ExtArgs> | null
      detailsFinanceiro: Prisma.$CreditTitleFinanceiroPayload<ExtArgs> | null
      detailsJudicial: Prisma.$CreditTitleJudicialPayload<ExtArgs> | null
      detailsRural: Prisma.$CreditTitleRuralPayload<ExtArgs> | null
      detailsImobiliario: Prisma.$CreditTitleImobiliarioPayload<ExtArgs> | null
      detailsAmbiental: Prisma.$CreditTitleAmbientalPayload<ExtArgs> | null
      detailsEspecial: Prisma.$CreditTitleEspecialPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      auctions: Prisma.$AuctionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.CreditCategory
      valueNominal: number
      valueCurrent: number
      issueDate: Date
      expiryDate: Date | null
      issuerId: string
      ownerId: string
      status: $Enums.CreditStatus
      tokenId: string | null
      tokenStandard: string | null
      blockchainTxHash: string | null
      isListed: boolean
      listingPrice: number | null
      listingDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creditTitle"]>
    composites: {}
  }

  type CreditTitleGetPayload<S extends boolean | null | undefined | CreditTitleDefaultArgs> = $Result.GetResult<Prisma.$CreditTitlePayload, S>

  type CreditTitleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleCountAggregateInputType | true
    }

  export interface CreditTitleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitle'], meta: { name: 'CreditTitle' } }
    /**
     * Find zero or one CreditTitle that matches the filter.
     * @param {CreditTitleFindUniqueArgs} args - Arguments to find a CreditTitle
     * @example
     * // Get one CreditTitle
     * const creditTitle = await prisma.creditTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleFindUniqueArgs>(args: SelectSubset<T, CreditTitleFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleFindUniqueOrThrowArgs} args - Arguments to find a CreditTitle
     * @example
     * // Get one CreditTitle
     * const creditTitle = await prisma.creditTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFindFirstArgs} args - Arguments to find a CreditTitle
     * @example
     * // Get one CreditTitle
     * const creditTitle = await prisma.creditTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleFindFirstArgs>(args?: SelectSubset<T, CreditTitleFindFirstArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFindFirstOrThrowArgs} args - Arguments to find a CreditTitle
     * @example
     * // Get one CreditTitle
     * const creditTitle = await prisma.creditTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitles
     * const creditTitles = await prisma.creditTitle.findMany()
     * 
     * // Get first 10 CreditTitles
     * const creditTitles = await prisma.creditTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleWithIdOnly = await prisma.creditTitle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleFindManyArgs>(args?: SelectSubset<T, CreditTitleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitle.
     * @param {CreditTitleCreateArgs} args - Arguments to create a CreditTitle.
     * @example
     * // Create one CreditTitle
     * const CreditTitle = await prisma.creditTitle.create({
     *   data: {
     *     // ... data to create a CreditTitle
     *   }
     * })
     * 
     */
    create<T extends CreditTitleCreateArgs>(args: SelectSubset<T, CreditTitleCreateArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitles.
     * @param {CreditTitleCreateManyArgs} args - Arguments to create many CreditTitles.
     * @example
     * // Create many CreditTitles
     * const creditTitle = await prisma.creditTitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleCreateManyArgs>(args?: SelectSubset<T, CreditTitleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitles and returns the data saved in the database.
     * @param {CreditTitleCreateManyAndReturnArgs} args - Arguments to create many CreditTitles.
     * @example
     * // Create many CreditTitles
     * const creditTitle = await prisma.creditTitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitles and only return the `id`
     * const creditTitleWithIdOnly = await prisma.creditTitle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitle.
     * @param {CreditTitleDeleteArgs} args - Arguments to delete one CreditTitle.
     * @example
     * // Delete one CreditTitle
     * const CreditTitle = await prisma.creditTitle.delete({
     *   where: {
     *     // ... filter to delete one CreditTitle
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleDeleteArgs>(args: SelectSubset<T, CreditTitleDeleteArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitle.
     * @param {CreditTitleUpdateArgs} args - Arguments to update one CreditTitle.
     * @example
     * // Update one CreditTitle
     * const creditTitle = await prisma.creditTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleUpdateArgs>(args: SelectSubset<T, CreditTitleUpdateArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitles.
     * @param {CreditTitleDeleteManyArgs} args - Arguments to filter CreditTitles to delete.
     * @example
     * // Delete a few CreditTitles
     * const { count } = await prisma.creditTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleDeleteManyArgs>(args?: SelectSubset<T, CreditTitleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitles
     * const creditTitle = await prisma.creditTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleUpdateManyArgs>(args: SelectSubset<T, CreditTitleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitles and returns the data updated in the database.
     * @param {CreditTitleUpdateManyAndReturnArgs} args - Arguments to update many CreditTitles.
     * @example
     * // Update many CreditTitles
     * const creditTitle = await prisma.creditTitle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitles and only return the `id`
     * const creditTitleWithIdOnly = await prisma.creditTitle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitle.
     * @param {CreditTitleUpsertArgs} args - Arguments to update or create a CreditTitle.
     * @example
     * // Update or create a CreditTitle
     * const creditTitle = await prisma.creditTitle.upsert({
     *   create: {
     *     // ... data to create a CreditTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitle we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleUpsertArgs>(args: SelectSubset<T, CreditTitleUpsertArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleCountArgs} args - Arguments to filter CreditTitles to count.
     * @example
     * // Count the number of CreditTitles
     * const count = await prisma.creditTitle.count({
     *   where: {
     *     // ... the filter for the CreditTitles we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleCountArgs>(
      args?: Subset<T, CreditTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleAggregateArgs>(args: Subset<T, CreditTitleAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleAggregateType<T>>

    /**
     * Group by CreditTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitle model
   */
  readonly fields: CreditTitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issuer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detailsTributario<T extends CreditTitle$detailsTributarioArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsTributarioArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsComercial<T extends CreditTitle$detailsComercialArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsComercialArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsFinanceiro<T extends CreditTitle$detailsFinanceiroArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsFinanceiroArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsJudicial<T extends CreditTitle$detailsJudicialArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsJudicialArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsRural<T extends CreditTitle$detailsRuralArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsRuralArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsImobiliario<T extends CreditTitle$detailsImobiliarioArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsImobiliarioArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsAmbiental<T extends CreditTitle$detailsAmbientalArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsAmbientalArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailsEspecial<T extends CreditTitle$detailsEspecialArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$detailsEspecialArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends CreditTitle$documentsArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends CreditTitle$offersArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends CreditTitle$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auctions<T extends CreditTitle$auctionsArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitle$auctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitle model
   */
  interface CreditTitleFieldRefs {
    readonly id: FieldRef<"CreditTitle", 'String'>
    readonly category: FieldRef<"CreditTitle", 'CreditCategory'>
    readonly valueNominal: FieldRef<"CreditTitle", 'Float'>
    readonly valueCurrent: FieldRef<"CreditTitle", 'Float'>
    readonly issueDate: FieldRef<"CreditTitle", 'DateTime'>
    readonly expiryDate: FieldRef<"CreditTitle", 'DateTime'>
    readonly issuerId: FieldRef<"CreditTitle", 'String'>
    readonly ownerId: FieldRef<"CreditTitle", 'String'>
    readonly status: FieldRef<"CreditTitle", 'CreditStatus'>
    readonly tokenId: FieldRef<"CreditTitle", 'String'>
    readonly tokenStandard: FieldRef<"CreditTitle", 'String'>
    readonly blockchainTxHash: FieldRef<"CreditTitle", 'String'>
    readonly isListed: FieldRef<"CreditTitle", 'Boolean'>
    readonly listingPrice: FieldRef<"CreditTitle", 'Float'>
    readonly listingDate: FieldRef<"CreditTitle", 'DateTime'>
    readonly createdAt: FieldRef<"CreditTitle", 'DateTime'>
    readonly updatedAt: FieldRef<"CreditTitle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitle findUnique
   */
  export type CreditTitleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitle to fetch.
     */
    where: CreditTitleWhereUniqueInput
  }

  /**
   * CreditTitle findUniqueOrThrow
   */
  export type CreditTitleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitle to fetch.
     */
    where: CreditTitleWhereUniqueInput
  }

  /**
   * CreditTitle findFirst
   */
  export type CreditTitleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitle to fetch.
     */
    where?: CreditTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitles to fetch.
     */
    orderBy?: CreditTitleOrderByWithRelationInput | CreditTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitles.
     */
    cursor?: CreditTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitles.
     */
    distinct?: CreditTitleScalarFieldEnum | CreditTitleScalarFieldEnum[]
  }

  /**
   * CreditTitle findFirstOrThrow
   */
  export type CreditTitleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitle to fetch.
     */
    where?: CreditTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitles to fetch.
     */
    orderBy?: CreditTitleOrderByWithRelationInput | CreditTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitles.
     */
    cursor?: CreditTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitles.
     */
    distinct?: CreditTitleScalarFieldEnum | CreditTitleScalarFieldEnum[]
  }

  /**
   * CreditTitle findMany
   */
  export type CreditTitleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitles to fetch.
     */
    where?: CreditTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitles to fetch.
     */
    orderBy?: CreditTitleOrderByWithRelationInput | CreditTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitles.
     */
    cursor?: CreditTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitles.
     */
    skip?: number
    distinct?: CreditTitleScalarFieldEnum | CreditTitleScalarFieldEnum[]
  }

  /**
   * CreditTitle create
   */
  export type CreditTitleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitle.
     */
    data: XOR<CreditTitleCreateInput, CreditTitleUncheckedCreateInput>
  }

  /**
   * CreditTitle createMany
   */
  export type CreditTitleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitles.
     */
    data: CreditTitleCreateManyInput | CreditTitleCreateManyInput[]
  }

  /**
   * CreditTitle createManyAndReturn
   */
  export type CreditTitleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitles.
     */
    data: CreditTitleCreateManyInput | CreditTitleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitle update
   */
  export type CreditTitleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitle.
     */
    data: XOR<CreditTitleUpdateInput, CreditTitleUncheckedUpdateInput>
    /**
     * Choose, which CreditTitle to update.
     */
    where: CreditTitleWhereUniqueInput
  }

  /**
   * CreditTitle updateMany
   */
  export type CreditTitleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitles.
     */
    data: XOR<CreditTitleUpdateManyMutationInput, CreditTitleUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitles to update
     */
    where?: CreditTitleWhereInput
    /**
     * Limit how many CreditTitles to update.
     */
    limit?: number
  }

  /**
   * CreditTitle updateManyAndReturn
   */
  export type CreditTitleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitles.
     */
    data: XOR<CreditTitleUpdateManyMutationInput, CreditTitleUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitles to update
     */
    where?: CreditTitleWhereInput
    /**
     * Limit how many CreditTitles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitle upsert
   */
  export type CreditTitleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitle to update in case it exists.
     */
    where: CreditTitleWhereUniqueInput
    /**
     * In case the CreditTitle found by the `where` argument doesn't exist, create a new CreditTitle with this data.
     */
    create: XOR<CreditTitleCreateInput, CreditTitleUncheckedCreateInput>
    /**
     * In case the CreditTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleUpdateInput, CreditTitleUncheckedUpdateInput>
  }

  /**
   * CreditTitle delete
   */
  export type CreditTitleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
    /**
     * Filter which CreditTitle to delete.
     */
    where: CreditTitleWhereUniqueInput
  }

  /**
   * CreditTitle deleteMany
   */
  export type CreditTitleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitles to delete
     */
    where?: CreditTitleWhereInput
    /**
     * Limit how many CreditTitles to delete.
     */
    limit?: number
  }

  /**
   * CreditTitle.detailsTributario
   */
  export type CreditTitle$detailsTributarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    where?: CreditTitleTributarioWhereInput
  }

  /**
   * CreditTitle.detailsComercial
   */
  export type CreditTitle$detailsComercialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    where?: CreditTitleComercialWhereInput
  }

  /**
   * CreditTitle.detailsFinanceiro
   */
  export type CreditTitle$detailsFinanceiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    where?: CreditTitleFinanceiroWhereInput
  }

  /**
   * CreditTitle.detailsJudicial
   */
  export type CreditTitle$detailsJudicialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    where?: CreditTitleJudicialWhereInput
  }

  /**
   * CreditTitle.detailsRural
   */
  export type CreditTitle$detailsRuralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    where?: CreditTitleRuralWhereInput
  }

  /**
   * CreditTitle.detailsImobiliario
   */
  export type CreditTitle$detailsImobiliarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    where?: CreditTitleImobiliarioWhereInput
  }

  /**
   * CreditTitle.detailsAmbiental
   */
  export type CreditTitle$detailsAmbientalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    where?: CreditTitleAmbientalWhereInput
  }

  /**
   * CreditTitle.detailsEspecial
   */
  export type CreditTitle$detailsEspecialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    where?: CreditTitleEspecialWhereInput
  }

  /**
   * CreditTitle.documents
   */
  export type CreditTitle$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * CreditTitle.offers
   */
  export type CreditTitle$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * CreditTitle.transactions
   */
  export type CreditTitle$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * CreditTitle.auctions
   */
  export type CreditTitle$auctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * CreditTitle without action
   */
  export type CreditTitleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitle
     */
    select?: CreditTitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitle
     */
    omit?: CreditTitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleTributario
   */

  export type AggregateCreditTitleTributario = {
    _count: CreditTitleTributarioCountAggregateOutputType | null
    _min: CreditTitleTributarioMinAggregateOutputType | null
    _max: CreditTitleTributarioMaxAggregateOutputType | null
  }

  export type CreditTitleTributarioMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subTypeFederal: $Enums.TCTributarioFederal | null
    subTypeEstadual: $Enums.TCTributarioEstadual | null
    subTypeMunicipal: $Enums.TCTributarioMunicipal | null
    esfera: string | null
    nomeTributo: string | null
    periodoApuracaoInicio: Date | null
    periodoApuracaoFim: Date | null
    numeroProcessoAdministrativo: string | null
    numeroProcessoJudicial: string | null
  }

  export type CreditTitleTributarioMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subTypeFederal: $Enums.TCTributarioFederal | null
    subTypeEstadual: $Enums.TCTributarioEstadual | null
    subTypeMunicipal: $Enums.TCTributarioMunicipal | null
    esfera: string | null
    nomeTributo: string | null
    periodoApuracaoInicio: Date | null
    periodoApuracaoFim: Date | null
    numeroProcessoAdministrativo: string | null
    numeroProcessoJudicial: string | null
  }

  export type CreditTitleTributarioCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subTypeFederal: number
    subTypeEstadual: number
    subTypeMunicipal: number
    esfera: number
    nomeTributo: number
    periodoApuracaoInicio: number
    periodoApuracaoFim: number
    numeroProcessoAdministrativo: number
    numeroProcessoJudicial: number
    _all: number
  }


  export type CreditTitleTributarioMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subTypeFederal?: true
    subTypeEstadual?: true
    subTypeMunicipal?: true
    esfera?: true
    nomeTributo?: true
    periodoApuracaoInicio?: true
    periodoApuracaoFim?: true
    numeroProcessoAdministrativo?: true
    numeroProcessoJudicial?: true
  }

  export type CreditTitleTributarioMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subTypeFederal?: true
    subTypeEstadual?: true
    subTypeMunicipal?: true
    esfera?: true
    nomeTributo?: true
    periodoApuracaoInicio?: true
    periodoApuracaoFim?: true
    numeroProcessoAdministrativo?: true
    numeroProcessoJudicial?: true
  }

  export type CreditTitleTributarioCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subTypeFederal?: true
    subTypeEstadual?: true
    subTypeMunicipal?: true
    esfera?: true
    nomeTributo?: true
    periodoApuracaoInicio?: true
    periodoApuracaoFim?: true
    numeroProcessoAdministrativo?: true
    numeroProcessoJudicial?: true
    _all?: true
  }

  export type CreditTitleTributarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleTributario to aggregate.
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleTributarios to fetch.
     */
    orderBy?: CreditTitleTributarioOrderByWithRelationInput | CreditTitleTributarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleTributarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleTributarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleTributarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleTributarios
    **/
    _count?: true | CreditTitleTributarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleTributarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleTributarioMaxAggregateInputType
  }

  export type GetCreditTitleTributarioAggregateType<T extends CreditTitleTributarioAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleTributario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleTributario[P]>
      : GetScalarType<T[P], AggregateCreditTitleTributario[P]>
  }




  export type CreditTitleTributarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleTributarioWhereInput
    orderBy?: CreditTitleTributarioOrderByWithAggregationInput | CreditTitleTributarioOrderByWithAggregationInput[]
    by: CreditTitleTributarioScalarFieldEnum[] | CreditTitleTributarioScalarFieldEnum
    having?: CreditTitleTributarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleTributarioCountAggregateInputType | true
    _min?: CreditTitleTributarioMinAggregateInputType
    _max?: CreditTitleTributarioMaxAggregateInputType
  }

  export type CreditTitleTributarioGroupByOutputType = {
    id: string
    creditTitleId: string
    subTypeFederal: $Enums.TCTributarioFederal | null
    subTypeEstadual: $Enums.TCTributarioEstadual | null
    subTypeMunicipal: $Enums.TCTributarioMunicipal | null
    esfera: string
    nomeTributo: string
    periodoApuracaoInicio: Date
    periodoApuracaoFim: Date
    numeroProcessoAdministrativo: string | null
    numeroProcessoJudicial: string | null
    _count: CreditTitleTributarioCountAggregateOutputType | null
    _min: CreditTitleTributarioMinAggregateOutputType | null
    _max: CreditTitleTributarioMaxAggregateOutputType | null
  }

  type GetCreditTitleTributarioGroupByPayload<T extends CreditTitleTributarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleTributarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleTributarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleTributarioGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleTributarioGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleTributarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subTypeFederal?: boolean
    subTypeEstadual?: boolean
    subTypeMunicipal?: boolean
    esfera?: boolean
    nomeTributo?: boolean
    periodoApuracaoInicio?: boolean
    periodoApuracaoFim?: boolean
    numeroProcessoAdministrativo?: boolean
    numeroProcessoJudicial?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleTributario"]>

  export type CreditTitleTributarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subTypeFederal?: boolean
    subTypeEstadual?: boolean
    subTypeMunicipal?: boolean
    esfera?: boolean
    nomeTributo?: boolean
    periodoApuracaoInicio?: boolean
    periodoApuracaoFim?: boolean
    numeroProcessoAdministrativo?: boolean
    numeroProcessoJudicial?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleTributario"]>

  export type CreditTitleTributarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subTypeFederal?: boolean
    subTypeEstadual?: boolean
    subTypeMunicipal?: boolean
    esfera?: boolean
    nomeTributo?: boolean
    periodoApuracaoInicio?: boolean
    periodoApuracaoFim?: boolean
    numeroProcessoAdministrativo?: boolean
    numeroProcessoJudicial?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleTributario"]>

  export type CreditTitleTributarioSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subTypeFederal?: boolean
    subTypeEstadual?: boolean
    subTypeMunicipal?: boolean
    esfera?: boolean
    nomeTributo?: boolean
    periodoApuracaoInicio?: boolean
    periodoApuracaoFim?: boolean
    numeroProcessoAdministrativo?: boolean
    numeroProcessoJudicial?: boolean
  }

  export type CreditTitleTributarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subTypeFederal" | "subTypeEstadual" | "subTypeMunicipal" | "esfera" | "nomeTributo" | "periodoApuracaoInicio" | "periodoApuracaoFim" | "numeroProcessoAdministrativo" | "numeroProcessoJudicial", ExtArgs["result"]["creditTitleTributario"]>
  export type CreditTitleTributarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleTributarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleTributarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleTributarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleTributario"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subTypeFederal: $Enums.TCTributarioFederal | null
      subTypeEstadual: $Enums.TCTributarioEstadual | null
      subTypeMunicipal: $Enums.TCTributarioMunicipal | null
      esfera: string
      nomeTributo: string
      periodoApuracaoInicio: Date
      periodoApuracaoFim: Date
      numeroProcessoAdministrativo: string | null
      numeroProcessoJudicial: string | null
    }, ExtArgs["result"]["creditTitleTributario"]>
    composites: {}
  }

  type CreditTitleTributarioGetPayload<S extends boolean | null | undefined | CreditTitleTributarioDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleTributarioPayload, S>

  type CreditTitleTributarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleTributarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleTributarioCountAggregateInputType | true
    }

  export interface CreditTitleTributarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleTributario'], meta: { name: 'CreditTitleTributario' } }
    /**
     * Find zero or one CreditTitleTributario that matches the filter.
     * @param {CreditTitleTributarioFindUniqueArgs} args - Arguments to find a CreditTitleTributario
     * @example
     * // Get one CreditTitleTributario
     * const creditTitleTributario = await prisma.creditTitleTributario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleTributarioFindUniqueArgs>(args: SelectSubset<T, CreditTitleTributarioFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleTributario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleTributarioFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleTributario
     * @example
     * // Get one CreditTitleTributario
     * const creditTitleTributario = await prisma.creditTitleTributario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleTributarioFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleTributarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleTributario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioFindFirstArgs} args - Arguments to find a CreditTitleTributario
     * @example
     * // Get one CreditTitleTributario
     * const creditTitleTributario = await prisma.creditTitleTributario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleTributarioFindFirstArgs>(args?: SelectSubset<T, CreditTitleTributarioFindFirstArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleTributario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioFindFirstOrThrowArgs} args - Arguments to find a CreditTitleTributario
     * @example
     * // Get one CreditTitleTributario
     * const creditTitleTributario = await prisma.creditTitleTributario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleTributarioFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleTributarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleTributarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleTributarios
     * const creditTitleTributarios = await prisma.creditTitleTributario.findMany()
     * 
     * // Get first 10 CreditTitleTributarios
     * const creditTitleTributarios = await prisma.creditTitleTributario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleTributarioWithIdOnly = await prisma.creditTitleTributario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleTributarioFindManyArgs>(args?: SelectSubset<T, CreditTitleTributarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleTributario.
     * @param {CreditTitleTributarioCreateArgs} args - Arguments to create a CreditTitleTributario.
     * @example
     * // Create one CreditTitleTributario
     * const CreditTitleTributario = await prisma.creditTitleTributario.create({
     *   data: {
     *     // ... data to create a CreditTitleTributario
     *   }
     * })
     * 
     */
    create<T extends CreditTitleTributarioCreateArgs>(args: SelectSubset<T, CreditTitleTributarioCreateArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleTributarios.
     * @param {CreditTitleTributarioCreateManyArgs} args - Arguments to create many CreditTitleTributarios.
     * @example
     * // Create many CreditTitleTributarios
     * const creditTitleTributario = await prisma.creditTitleTributario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleTributarioCreateManyArgs>(args?: SelectSubset<T, CreditTitleTributarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleTributarios and returns the data saved in the database.
     * @param {CreditTitleTributarioCreateManyAndReturnArgs} args - Arguments to create many CreditTitleTributarios.
     * @example
     * // Create many CreditTitleTributarios
     * const creditTitleTributario = await prisma.creditTitleTributario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleTributarios and only return the `id`
     * const creditTitleTributarioWithIdOnly = await prisma.creditTitleTributario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleTributarioCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleTributarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleTributario.
     * @param {CreditTitleTributarioDeleteArgs} args - Arguments to delete one CreditTitleTributario.
     * @example
     * // Delete one CreditTitleTributario
     * const CreditTitleTributario = await prisma.creditTitleTributario.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleTributario
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleTributarioDeleteArgs>(args: SelectSubset<T, CreditTitleTributarioDeleteArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleTributario.
     * @param {CreditTitleTributarioUpdateArgs} args - Arguments to update one CreditTitleTributario.
     * @example
     * // Update one CreditTitleTributario
     * const creditTitleTributario = await prisma.creditTitleTributario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleTributarioUpdateArgs>(args: SelectSubset<T, CreditTitleTributarioUpdateArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleTributarios.
     * @param {CreditTitleTributarioDeleteManyArgs} args - Arguments to filter CreditTitleTributarios to delete.
     * @example
     * // Delete a few CreditTitleTributarios
     * const { count } = await prisma.creditTitleTributario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleTributarioDeleteManyArgs>(args?: SelectSubset<T, CreditTitleTributarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleTributarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleTributarios
     * const creditTitleTributario = await prisma.creditTitleTributario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleTributarioUpdateManyArgs>(args: SelectSubset<T, CreditTitleTributarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleTributarios and returns the data updated in the database.
     * @param {CreditTitleTributarioUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleTributarios.
     * @example
     * // Update many CreditTitleTributarios
     * const creditTitleTributario = await prisma.creditTitleTributario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleTributarios and only return the `id`
     * const creditTitleTributarioWithIdOnly = await prisma.creditTitleTributario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleTributarioUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleTributarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleTributario.
     * @param {CreditTitleTributarioUpsertArgs} args - Arguments to update or create a CreditTitleTributario.
     * @example
     * // Update or create a CreditTitleTributario
     * const creditTitleTributario = await prisma.creditTitleTributario.upsert({
     *   create: {
     *     // ... data to create a CreditTitleTributario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleTributario we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleTributarioUpsertArgs>(args: SelectSubset<T, CreditTitleTributarioUpsertArgs<ExtArgs>>): Prisma__CreditTitleTributarioClient<$Result.GetResult<Prisma.$CreditTitleTributarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleTributarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioCountArgs} args - Arguments to filter CreditTitleTributarios to count.
     * @example
     * // Count the number of CreditTitleTributarios
     * const count = await prisma.creditTitleTributario.count({
     *   where: {
     *     // ... the filter for the CreditTitleTributarios we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleTributarioCountArgs>(
      args?: Subset<T, CreditTitleTributarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleTributarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleTributario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleTributarioAggregateArgs>(args: Subset<T, CreditTitleTributarioAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleTributarioAggregateType<T>>

    /**
     * Group by CreditTitleTributario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleTributarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleTributarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleTributarioGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleTributarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleTributarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleTributarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleTributario model
   */
  readonly fields: CreditTitleTributarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleTributario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleTributarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleTributario model
   */
  interface CreditTitleTributarioFieldRefs {
    readonly id: FieldRef<"CreditTitleTributario", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleTributario", 'String'>
    readonly subTypeFederal: FieldRef<"CreditTitleTributario", 'TCTributarioFederal'>
    readonly subTypeEstadual: FieldRef<"CreditTitleTributario", 'TCTributarioEstadual'>
    readonly subTypeMunicipal: FieldRef<"CreditTitleTributario", 'TCTributarioMunicipal'>
    readonly esfera: FieldRef<"CreditTitleTributario", 'String'>
    readonly nomeTributo: FieldRef<"CreditTitleTributario", 'String'>
    readonly periodoApuracaoInicio: FieldRef<"CreditTitleTributario", 'DateTime'>
    readonly periodoApuracaoFim: FieldRef<"CreditTitleTributario", 'DateTime'>
    readonly numeroProcessoAdministrativo: FieldRef<"CreditTitleTributario", 'String'>
    readonly numeroProcessoJudicial: FieldRef<"CreditTitleTributario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleTributario findUnique
   */
  export type CreditTitleTributarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleTributario to fetch.
     */
    where: CreditTitleTributarioWhereUniqueInput
  }

  /**
   * CreditTitleTributario findUniqueOrThrow
   */
  export type CreditTitleTributarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleTributario to fetch.
     */
    where: CreditTitleTributarioWhereUniqueInput
  }

  /**
   * CreditTitleTributario findFirst
   */
  export type CreditTitleTributarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleTributario to fetch.
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleTributarios to fetch.
     */
    orderBy?: CreditTitleTributarioOrderByWithRelationInput | CreditTitleTributarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleTributarios.
     */
    cursor?: CreditTitleTributarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleTributarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleTributarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleTributarios.
     */
    distinct?: CreditTitleTributarioScalarFieldEnum | CreditTitleTributarioScalarFieldEnum[]
  }

  /**
   * CreditTitleTributario findFirstOrThrow
   */
  export type CreditTitleTributarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleTributario to fetch.
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleTributarios to fetch.
     */
    orderBy?: CreditTitleTributarioOrderByWithRelationInput | CreditTitleTributarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleTributarios.
     */
    cursor?: CreditTitleTributarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleTributarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleTributarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleTributarios.
     */
    distinct?: CreditTitleTributarioScalarFieldEnum | CreditTitleTributarioScalarFieldEnum[]
  }

  /**
   * CreditTitleTributario findMany
   */
  export type CreditTitleTributarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleTributarios to fetch.
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleTributarios to fetch.
     */
    orderBy?: CreditTitleTributarioOrderByWithRelationInput | CreditTitleTributarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleTributarios.
     */
    cursor?: CreditTitleTributarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleTributarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleTributarios.
     */
    skip?: number
    distinct?: CreditTitleTributarioScalarFieldEnum | CreditTitleTributarioScalarFieldEnum[]
  }

  /**
   * CreditTitleTributario create
   */
  export type CreditTitleTributarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleTributario.
     */
    data: XOR<CreditTitleTributarioCreateInput, CreditTitleTributarioUncheckedCreateInput>
  }

  /**
   * CreditTitleTributario createMany
   */
  export type CreditTitleTributarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleTributarios.
     */
    data: CreditTitleTributarioCreateManyInput | CreditTitleTributarioCreateManyInput[]
  }

  /**
   * CreditTitleTributario createManyAndReturn
   */
  export type CreditTitleTributarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleTributarios.
     */
    data: CreditTitleTributarioCreateManyInput | CreditTitleTributarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleTributario update
   */
  export type CreditTitleTributarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleTributario.
     */
    data: XOR<CreditTitleTributarioUpdateInput, CreditTitleTributarioUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleTributario to update.
     */
    where: CreditTitleTributarioWhereUniqueInput
  }

  /**
   * CreditTitleTributario updateMany
   */
  export type CreditTitleTributarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleTributarios.
     */
    data: XOR<CreditTitleTributarioUpdateManyMutationInput, CreditTitleTributarioUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleTributarios to update
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * Limit how many CreditTitleTributarios to update.
     */
    limit?: number
  }

  /**
   * CreditTitleTributario updateManyAndReturn
   */
  export type CreditTitleTributarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleTributarios.
     */
    data: XOR<CreditTitleTributarioUpdateManyMutationInput, CreditTitleTributarioUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleTributarios to update
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * Limit how many CreditTitleTributarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleTributario upsert
   */
  export type CreditTitleTributarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleTributario to update in case it exists.
     */
    where: CreditTitleTributarioWhereUniqueInput
    /**
     * In case the CreditTitleTributario found by the `where` argument doesn't exist, create a new CreditTitleTributario with this data.
     */
    create: XOR<CreditTitleTributarioCreateInput, CreditTitleTributarioUncheckedCreateInput>
    /**
     * In case the CreditTitleTributario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleTributarioUpdateInput, CreditTitleTributarioUncheckedUpdateInput>
  }

  /**
   * CreditTitleTributario delete
   */
  export type CreditTitleTributarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleTributario to delete.
     */
    where: CreditTitleTributarioWhereUniqueInput
  }

  /**
   * CreditTitleTributario deleteMany
   */
  export type CreditTitleTributarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleTributarios to delete
     */
    where?: CreditTitleTributarioWhereInput
    /**
     * Limit how many CreditTitleTributarios to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleTributario without action
   */
  export type CreditTitleTributarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleTributario
     */
    select?: CreditTitleTributarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleTributario
     */
    omit?: CreditTitleTributarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleTributarioInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleComercial
   */

  export type AggregateCreditTitleComercial = {
    _count: CreditTitleComercialCountAggregateOutputType | null
    _min: CreditTitleComercialMinAggregateOutputType | null
    _max: CreditTitleComercialMaxAggregateOutputType | null
  }

  export type CreditTitleComercialMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCComercial | null
    sacadoNome: string | null
    sacadoDocumento: string | null
  }

  export type CreditTitleComercialMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCComercial | null
    sacadoNome: string | null
    sacadoDocumento: string | null
  }

  export type CreditTitleComercialCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    sacadoNome: number
    sacadoDocumento: number
    _all: number
  }


  export type CreditTitleComercialMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    sacadoNome?: true
    sacadoDocumento?: true
  }

  export type CreditTitleComercialMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    sacadoNome?: true
    sacadoDocumento?: true
  }

  export type CreditTitleComercialCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    sacadoNome?: true
    sacadoDocumento?: true
    _all?: true
  }

  export type CreditTitleComercialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleComercial to aggregate.
     */
    where?: CreditTitleComercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleComercials to fetch.
     */
    orderBy?: CreditTitleComercialOrderByWithRelationInput | CreditTitleComercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleComercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleComercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleComercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleComercials
    **/
    _count?: true | CreditTitleComercialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleComercialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleComercialMaxAggregateInputType
  }

  export type GetCreditTitleComercialAggregateType<T extends CreditTitleComercialAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleComercial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleComercial[P]>
      : GetScalarType<T[P], AggregateCreditTitleComercial[P]>
  }




  export type CreditTitleComercialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleComercialWhereInput
    orderBy?: CreditTitleComercialOrderByWithAggregationInput | CreditTitleComercialOrderByWithAggregationInput[]
    by: CreditTitleComercialScalarFieldEnum[] | CreditTitleComercialScalarFieldEnum
    having?: CreditTitleComercialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleComercialCountAggregateInputType | true
    _min?: CreditTitleComercialMinAggregateInputType
    _max?: CreditTitleComercialMaxAggregateInputType
  }

  export type CreditTitleComercialGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCComercial
    sacadoNome: string
    sacadoDocumento: string
    _count: CreditTitleComercialCountAggregateOutputType | null
    _min: CreditTitleComercialMinAggregateOutputType | null
    _max: CreditTitleComercialMaxAggregateOutputType | null
  }

  type GetCreditTitleComercialGroupByPayload<T extends CreditTitleComercialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleComercialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleComercialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleComercialGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleComercialGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleComercialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    sacadoNome?: boolean
    sacadoDocumento?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleComercial"]>

  export type CreditTitleComercialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    sacadoNome?: boolean
    sacadoDocumento?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleComercial"]>

  export type CreditTitleComercialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    sacadoNome?: boolean
    sacadoDocumento?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleComercial"]>

  export type CreditTitleComercialSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    sacadoNome?: boolean
    sacadoDocumento?: boolean
  }

  export type CreditTitleComercialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "sacadoNome" | "sacadoDocumento", ExtArgs["result"]["creditTitleComercial"]>
  export type CreditTitleComercialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleComercialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleComercialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleComercialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleComercial"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCComercial
      sacadoNome: string
      sacadoDocumento: string
    }, ExtArgs["result"]["creditTitleComercial"]>
    composites: {}
  }

  type CreditTitleComercialGetPayload<S extends boolean | null | undefined | CreditTitleComercialDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleComercialPayload, S>

  type CreditTitleComercialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleComercialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleComercialCountAggregateInputType | true
    }

  export interface CreditTitleComercialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleComercial'], meta: { name: 'CreditTitleComercial' } }
    /**
     * Find zero or one CreditTitleComercial that matches the filter.
     * @param {CreditTitleComercialFindUniqueArgs} args - Arguments to find a CreditTitleComercial
     * @example
     * // Get one CreditTitleComercial
     * const creditTitleComercial = await prisma.creditTitleComercial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleComercialFindUniqueArgs>(args: SelectSubset<T, CreditTitleComercialFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleComercial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleComercialFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleComercial
     * @example
     * // Get one CreditTitleComercial
     * const creditTitleComercial = await prisma.creditTitleComercial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleComercialFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleComercialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleComercial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialFindFirstArgs} args - Arguments to find a CreditTitleComercial
     * @example
     * // Get one CreditTitleComercial
     * const creditTitleComercial = await prisma.creditTitleComercial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleComercialFindFirstArgs>(args?: SelectSubset<T, CreditTitleComercialFindFirstArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleComercial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialFindFirstOrThrowArgs} args - Arguments to find a CreditTitleComercial
     * @example
     * // Get one CreditTitleComercial
     * const creditTitleComercial = await prisma.creditTitleComercial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleComercialFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleComercialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleComercials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleComercials
     * const creditTitleComercials = await prisma.creditTitleComercial.findMany()
     * 
     * // Get first 10 CreditTitleComercials
     * const creditTitleComercials = await prisma.creditTitleComercial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleComercialWithIdOnly = await prisma.creditTitleComercial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleComercialFindManyArgs>(args?: SelectSubset<T, CreditTitleComercialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleComercial.
     * @param {CreditTitleComercialCreateArgs} args - Arguments to create a CreditTitleComercial.
     * @example
     * // Create one CreditTitleComercial
     * const CreditTitleComercial = await prisma.creditTitleComercial.create({
     *   data: {
     *     // ... data to create a CreditTitleComercial
     *   }
     * })
     * 
     */
    create<T extends CreditTitleComercialCreateArgs>(args: SelectSubset<T, CreditTitleComercialCreateArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleComercials.
     * @param {CreditTitleComercialCreateManyArgs} args - Arguments to create many CreditTitleComercials.
     * @example
     * // Create many CreditTitleComercials
     * const creditTitleComercial = await prisma.creditTitleComercial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleComercialCreateManyArgs>(args?: SelectSubset<T, CreditTitleComercialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleComercials and returns the data saved in the database.
     * @param {CreditTitleComercialCreateManyAndReturnArgs} args - Arguments to create many CreditTitleComercials.
     * @example
     * // Create many CreditTitleComercials
     * const creditTitleComercial = await prisma.creditTitleComercial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleComercials and only return the `id`
     * const creditTitleComercialWithIdOnly = await prisma.creditTitleComercial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleComercialCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleComercialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleComercial.
     * @param {CreditTitleComercialDeleteArgs} args - Arguments to delete one CreditTitleComercial.
     * @example
     * // Delete one CreditTitleComercial
     * const CreditTitleComercial = await prisma.creditTitleComercial.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleComercial
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleComercialDeleteArgs>(args: SelectSubset<T, CreditTitleComercialDeleteArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleComercial.
     * @param {CreditTitleComercialUpdateArgs} args - Arguments to update one CreditTitleComercial.
     * @example
     * // Update one CreditTitleComercial
     * const creditTitleComercial = await prisma.creditTitleComercial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleComercialUpdateArgs>(args: SelectSubset<T, CreditTitleComercialUpdateArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleComercials.
     * @param {CreditTitleComercialDeleteManyArgs} args - Arguments to filter CreditTitleComercials to delete.
     * @example
     * // Delete a few CreditTitleComercials
     * const { count } = await prisma.creditTitleComercial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleComercialDeleteManyArgs>(args?: SelectSubset<T, CreditTitleComercialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleComercials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleComercials
     * const creditTitleComercial = await prisma.creditTitleComercial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleComercialUpdateManyArgs>(args: SelectSubset<T, CreditTitleComercialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleComercials and returns the data updated in the database.
     * @param {CreditTitleComercialUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleComercials.
     * @example
     * // Update many CreditTitleComercials
     * const creditTitleComercial = await prisma.creditTitleComercial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleComercials and only return the `id`
     * const creditTitleComercialWithIdOnly = await prisma.creditTitleComercial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleComercialUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleComercialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleComercial.
     * @param {CreditTitleComercialUpsertArgs} args - Arguments to update or create a CreditTitleComercial.
     * @example
     * // Update or create a CreditTitleComercial
     * const creditTitleComercial = await prisma.creditTitleComercial.upsert({
     *   create: {
     *     // ... data to create a CreditTitleComercial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleComercial we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleComercialUpsertArgs>(args: SelectSubset<T, CreditTitleComercialUpsertArgs<ExtArgs>>): Prisma__CreditTitleComercialClient<$Result.GetResult<Prisma.$CreditTitleComercialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleComercials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialCountArgs} args - Arguments to filter CreditTitleComercials to count.
     * @example
     * // Count the number of CreditTitleComercials
     * const count = await prisma.creditTitleComercial.count({
     *   where: {
     *     // ... the filter for the CreditTitleComercials we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleComercialCountArgs>(
      args?: Subset<T, CreditTitleComercialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleComercialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleComercial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleComercialAggregateArgs>(args: Subset<T, CreditTitleComercialAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleComercialAggregateType<T>>

    /**
     * Group by CreditTitleComercial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleComercialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleComercialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleComercialGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleComercialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleComercialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleComercialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleComercial model
   */
  readonly fields: CreditTitleComercialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleComercial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleComercialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleComercial model
   */
  interface CreditTitleComercialFieldRefs {
    readonly id: FieldRef<"CreditTitleComercial", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleComercial", 'String'>
    readonly subType: FieldRef<"CreditTitleComercial", 'TCComercial'>
    readonly sacadoNome: FieldRef<"CreditTitleComercial", 'String'>
    readonly sacadoDocumento: FieldRef<"CreditTitleComercial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleComercial findUnique
   */
  export type CreditTitleComercialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleComercial to fetch.
     */
    where: CreditTitleComercialWhereUniqueInput
  }

  /**
   * CreditTitleComercial findUniqueOrThrow
   */
  export type CreditTitleComercialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleComercial to fetch.
     */
    where: CreditTitleComercialWhereUniqueInput
  }

  /**
   * CreditTitleComercial findFirst
   */
  export type CreditTitleComercialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleComercial to fetch.
     */
    where?: CreditTitleComercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleComercials to fetch.
     */
    orderBy?: CreditTitleComercialOrderByWithRelationInput | CreditTitleComercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleComercials.
     */
    cursor?: CreditTitleComercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleComercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleComercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleComercials.
     */
    distinct?: CreditTitleComercialScalarFieldEnum | CreditTitleComercialScalarFieldEnum[]
  }

  /**
   * CreditTitleComercial findFirstOrThrow
   */
  export type CreditTitleComercialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleComercial to fetch.
     */
    where?: CreditTitleComercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleComercials to fetch.
     */
    orderBy?: CreditTitleComercialOrderByWithRelationInput | CreditTitleComercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleComercials.
     */
    cursor?: CreditTitleComercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleComercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleComercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleComercials.
     */
    distinct?: CreditTitleComercialScalarFieldEnum | CreditTitleComercialScalarFieldEnum[]
  }

  /**
   * CreditTitleComercial findMany
   */
  export type CreditTitleComercialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleComercials to fetch.
     */
    where?: CreditTitleComercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleComercials to fetch.
     */
    orderBy?: CreditTitleComercialOrderByWithRelationInput | CreditTitleComercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleComercials.
     */
    cursor?: CreditTitleComercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleComercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleComercials.
     */
    skip?: number
    distinct?: CreditTitleComercialScalarFieldEnum | CreditTitleComercialScalarFieldEnum[]
  }

  /**
   * CreditTitleComercial create
   */
  export type CreditTitleComercialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleComercial.
     */
    data: XOR<CreditTitleComercialCreateInput, CreditTitleComercialUncheckedCreateInput>
  }

  /**
   * CreditTitleComercial createMany
   */
  export type CreditTitleComercialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleComercials.
     */
    data: CreditTitleComercialCreateManyInput | CreditTitleComercialCreateManyInput[]
  }

  /**
   * CreditTitleComercial createManyAndReturn
   */
  export type CreditTitleComercialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleComercials.
     */
    data: CreditTitleComercialCreateManyInput | CreditTitleComercialCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleComercial update
   */
  export type CreditTitleComercialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleComercial.
     */
    data: XOR<CreditTitleComercialUpdateInput, CreditTitleComercialUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleComercial to update.
     */
    where: CreditTitleComercialWhereUniqueInput
  }

  /**
   * CreditTitleComercial updateMany
   */
  export type CreditTitleComercialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleComercials.
     */
    data: XOR<CreditTitleComercialUpdateManyMutationInput, CreditTitleComercialUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleComercials to update
     */
    where?: CreditTitleComercialWhereInput
    /**
     * Limit how many CreditTitleComercials to update.
     */
    limit?: number
  }

  /**
   * CreditTitleComercial updateManyAndReturn
   */
  export type CreditTitleComercialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleComercials.
     */
    data: XOR<CreditTitleComercialUpdateManyMutationInput, CreditTitleComercialUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleComercials to update
     */
    where?: CreditTitleComercialWhereInput
    /**
     * Limit how many CreditTitleComercials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleComercial upsert
   */
  export type CreditTitleComercialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleComercial to update in case it exists.
     */
    where: CreditTitleComercialWhereUniqueInput
    /**
     * In case the CreditTitleComercial found by the `where` argument doesn't exist, create a new CreditTitleComercial with this data.
     */
    create: XOR<CreditTitleComercialCreateInput, CreditTitleComercialUncheckedCreateInput>
    /**
     * In case the CreditTitleComercial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleComercialUpdateInput, CreditTitleComercialUncheckedUpdateInput>
  }

  /**
   * CreditTitleComercial delete
   */
  export type CreditTitleComercialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleComercial to delete.
     */
    where: CreditTitleComercialWhereUniqueInput
  }

  /**
   * CreditTitleComercial deleteMany
   */
  export type CreditTitleComercialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleComercials to delete
     */
    where?: CreditTitleComercialWhereInput
    /**
     * Limit how many CreditTitleComercials to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleComercial without action
   */
  export type CreditTitleComercialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleComercial
     */
    select?: CreditTitleComercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleComercial
     */
    omit?: CreditTitleComercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleComercialInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleFinanceiro
   */

  export type AggregateCreditTitleFinanceiro = {
    _count: CreditTitleFinanceiroCountAggregateOutputType | null
    _avg: CreditTitleFinanceiroAvgAggregateOutputType | null
    _sum: CreditTitleFinanceiroSumAggregateOutputType | null
    _min: CreditTitleFinanceiroMinAggregateOutputType | null
    _max: CreditTitleFinanceiroMaxAggregateOutputType | null
  }

  export type CreditTitleFinanceiroAvgAggregateOutputType = {
    taxaJurosAnual: number | null
  }

  export type CreditTitleFinanceiroSumAggregateOutputType = {
    taxaJurosAnual: number | null
  }

  export type CreditTitleFinanceiroMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCFinanceiro | null
    indexador: string | null
    taxaJurosAnual: number | null
    rating: string | null
  }

  export type CreditTitleFinanceiroMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCFinanceiro | null
    indexador: string | null
    taxaJurosAnual: number | null
    rating: string | null
  }

  export type CreditTitleFinanceiroCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    indexador: number
    taxaJurosAnual: number
    rating: number
    _all: number
  }


  export type CreditTitleFinanceiroAvgAggregateInputType = {
    taxaJurosAnual?: true
  }

  export type CreditTitleFinanceiroSumAggregateInputType = {
    taxaJurosAnual?: true
  }

  export type CreditTitleFinanceiroMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    indexador?: true
    taxaJurosAnual?: true
    rating?: true
  }

  export type CreditTitleFinanceiroMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    indexador?: true
    taxaJurosAnual?: true
    rating?: true
  }

  export type CreditTitleFinanceiroCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    indexador?: true
    taxaJurosAnual?: true
    rating?: true
    _all?: true
  }

  export type CreditTitleFinanceiroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleFinanceiro to aggregate.
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleFinanceiros to fetch.
     */
    orderBy?: CreditTitleFinanceiroOrderByWithRelationInput | CreditTitleFinanceiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleFinanceiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleFinanceiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleFinanceiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleFinanceiros
    **/
    _count?: true | CreditTitleFinanceiroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditTitleFinanceiroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditTitleFinanceiroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleFinanceiroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleFinanceiroMaxAggregateInputType
  }

  export type GetCreditTitleFinanceiroAggregateType<T extends CreditTitleFinanceiroAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleFinanceiro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleFinanceiro[P]>
      : GetScalarType<T[P], AggregateCreditTitleFinanceiro[P]>
  }




  export type CreditTitleFinanceiroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleFinanceiroWhereInput
    orderBy?: CreditTitleFinanceiroOrderByWithAggregationInput | CreditTitleFinanceiroOrderByWithAggregationInput[]
    by: CreditTitleFinanceiroScalarFieldEnum[] | CreditTitleFinanceiroScalarFieldEnum
    having?: CreditTitleFinanceiroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleFinanceiroCountAggregateInputType | true
    _avg?: CreditTitleFinanceiroAvgAggregateInputType
    _sum?: CreditTitleFinanceiroSumAggregateInputType
    _min?: CreditTitleFinanceiroMinAggregateInputType
    _max?: CreditTitleFinanceiroMaxAggregateInputType
  }

  export type CreditTitleFinanceiroGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCFinanceiro
    indexador: string | null
    taxaJurosAnual: number | null
    rating: string | null
    _count: CreditTitleFinanceiroCountAggregateOutputType | null
    _avg: CreditTitleFinanceiroAvgAggregateOutputType | null
    _sum: CreditTitleFinanceiroSumAggregateOutputType | null
    _min: CreditTitleFinanceiroMinAggregateOutputType | null
    _max: CreditTitleFinanceiroMaxAggregateOutputType | null
  }

  type GetCreditTitleFinanceiroGroupByPayload<T extends CreditTitleFinanceiroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleFinanceiroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleFinanceiroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleFinanceiroGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleFinanceiroGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleFinanceiroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    indexador?: boolean
    taxaJurosAnual?: boolean
    rating?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleFinanceiro"]>

  export type CreditTitleFinanceiroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    indexador?: boolean
    taxaJurosAnual?: boolean
    rating?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleFinanceiro"]>

  export type CreditTitleFinanceiroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    indexador?: boolean
    taxaJurosAnual?: boolean
    rating?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleFinanceiro"]>

  export type CreditTitleFinanceiroSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    indexador?: boolean
    taxaJurosAnual?: boolean
    rating?: boolean
  }

  export type CreditTitleFinanceiroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "indexador" | "taxaJurosAnual" | "rating", ExtArgs["result"]["creditTitleFinanceiro"]>
  export type CreditTitleFinanceiroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleFinanceiroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleFinanceiroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleFinanceiroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleFinanceiro"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCFinanceiro
      indexador: string | null
      taxaJurosAnual: number | null
      rating: string | null
    }, ExtArgs["result"]["creditTitleFinanceiro"]>
    composites: {}
  }

  type CreditTitleFinanceiroGetPayload<S extends boolean | null | undefined | CreditTitleFinanceiroDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleFinanceiroPayload, S>

  type CreditTitleFinanceiroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleFinanceiroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleFinanceiroCountAggregateInputType | true
    }

  export interface CreditTitleFinanceiroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleFinanceiro'], meta: { name: 'CreditTitleFinanceiro' } }
    /**
     * Find zero or one CreditTitleFinanceiro that matches the filter.
     * @param {CreditTitleFinanceiroFindUniqueArgs} args - Arguments to find a CreditTitleFinanceiro
     * @example
     * // Get one CreditTitleFinanceiro
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleFinanceiroFindUniqueArgs>(args: SelectSubset<T, CreditTitleFinanceiroFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleFinanceiro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleFinanceiroFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleFinanceiro
     * @example
     * // Get one CreditTitleFinanceiro
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleFinanceiroFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleFinanceiroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleFinanceiro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroFindFirstArgs} args - Arguments to find a CreditTitleFinanceiro
     * @example
     * // Get one CreditTitleFinanceiro
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleFinanceiroFindFirstArgs>(args?: SelectSubset<T, CreditTitleFinanceiroFindFirstArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleFinanceiro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroFindFirstOrThrowArgs} args - Arguments to find a CreditTitleFinanceiro
     * @example
     * // Get one CreditTitleFinanceiro
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleFinanceiroFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleFinanceiroFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleFinanceiros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleFinanceiros
     * const creditTitleFinanceiros = await prisma.creditTitleFinanceiro.findMany()
     * 
     * // Get first 10 CreditTitleFinanceiros
     * const creditTitleFinanceiros = await prisma.creditTitleFinanceiro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleFinanceiroWithIdOnly = await prisma.creditTitleFinanceiro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleFinanceiroFindManyArgs>(args?: SelectSubset<T, CreditTitleFinanceiroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleFinanceiro.
     * @param {CreditTitleFinanceiroCreateArgs} args - Arguments to create a CreditTitleFinanceiro.
     * @example
     * // Create one CreditTitleFinanceiro
     * const CreditTitleFinanceiro = await prisma.creditTitleFinanceiro.create({
     *   data: {
     *     // ... data to create a CreditTitleFinanceiro
     *   }
     * })
     * 
     */
    create<T extends CreditTitleFinanceiroCreateArgs>(args: SelectSubset<T, CreditTitleFinanceiroCreateArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleFinanceiros.
     * @param {CreditTitleFinanceiroCreateManyArgs} args - Arguments to create many CreditTitleFinanceiros.
     * @example
     * // Create many CreditTitleFinanceiros
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleFinanceiroCreateManyArgs>(args?: SelectSubset<T, CreditTitleFinanceiroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleFinanceiros and returns the data saved in the database.
     * @param {CreditTitleFinanceiroCreateManyAndReturnArgs} args - Arguments to create many CreditTitleFinanceiros.
     * @example
     * // Create many CreditTitleFinanceiros
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleFinanceiros and only return the `id`
     * const creditTitleFinanceiroWithIdOnly = await prisma.creditTitleFinanceiro.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleFinanceiroCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleFinanceiroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleFinanceiro.
     * @param {CreditTitleFinanceiroDeleteArgs} args - Arguments to delete one CreditTitleFinanceiro.
     * @example
     * // Delete one CreditTitleFinanceiro
     * const CreditTitleFinanceiro = await prisma.creditTitleFinanceiro.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleFinanceiro
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleFinanceiroDeleteArgs>(args: SelectSubset<T, CreditTitleFinanceiroDeleteArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleFinanceiro.
     * @param {CreditTitleFinanceiroUpdateArgs} args - Arguments to update one CreditTitleFinanceiro.
     * @example
     * // Update one CreditTitleFinanceiro
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleFinanceiroUpdateArgs>(args: SelectSubset<T, CreditTitleFinanceiroUpdateArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleFinanceiros.
     * @param {CreditTitleFinanceiroDeleteManyArgs} args - Arguments to filter CreditTitleFinanceiros to delete.
     * @example
     * // Delete a few CreditTitleFinanceiros
     * const { count } = await prisma.creditTitleFinanceiro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleFinanceiroDeleteManyArgs>(args?: SelectSubset<T, CreditTitleFinanceiroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleFinanceiros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleFinanceiros
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleFinanceiroUpdateManyArgs>(args: SelectSubset<T, CreditTitleFinanceiroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleFinanceiros and returns the data updated in the database.
     * @param {CreditTitleFinanceiroUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleFinanceiros.
     * @example
     * // Update many CreditTitleFinanceiros
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleFinanceiros and only return the `id`
     * const creditTitleFinanceiroWithIdOnly = await prisma.creditTitleFinanceiro.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleFinanceiroUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleFinanceiroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleFinanceiro.
     * @param {CreditTitleFinanceiroUpsertArgs} args - Arguments to update or create a CreditTitleFinanceiro.
     * @example
     * // Update or create a CreditTitleFinanceiro
     * const creditTitleFinanceiro = await prisma.creditTitleFinanceiro.upsert({
     *   create: {
     *     // ... data to create a CreditTitleFinanceiro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleFinanceiro we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleFinanceiroUpsertArgs>(args: SelectSubset<T, CreditTitleFinanceiroUpsertArgs<ExtArgs>>): Prisma__CreditTitleFinanceiroClient<$Result.GetResult<Prisma.$CreditTitleFinanceiroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleFinanceiros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroCountArgs} args - Arguments to filter CreditTitleFinanceiros to count.
     * @example
     * // Count the number of CreditTitleFinanceiros
     * const count = await prisma.creditTitleFinanceiro.count({
     *   where: {
     *     // ... the filter for the CreditTitleFinanceiros we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleFinanceiroCountArgs>(
      args?: Subset<T, CreditTitleFinanceiroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleFinanceiroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleFinanceiro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleFinanceiroAggregateArgs>(args: Subset<T, CreditTitleFinanceiroAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleFinanceiroAggregateType<T>>

    /**
     * Group by CreditTitleFinanceiro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleFinanceiroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleFinanceiroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleFinanceiroGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleFinanceiroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleFinanceiroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleFinanceiroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleFinanceiro model
   */
  readonly fields: CreditTitleFinanceiroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleFinanceiro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleFinanceiroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleFinanceiro model
   */
  interface CreditTitleFinanceiroFieldRefs {
    readonly id: FieldRef<"CreditTitleFinanceiro", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleFinanceiro", 'String'>
    readonly subType: FieldRef<"CreditTitleFinanceiro", 'TCFinanceiro'>
    readonly indexador: FieldRef<"CreditTitleFinanceiro", 'String'>
    readonly taxaJurosAnual: FieldRef<"CreditTitleFinanceiro", 'Float'>
    readonly rating: FieldRef<"CreditTitleFinanceiro", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleFinanceiro findUnique
   */
  export type CreditTitleFinanceiroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleFinanceiro to fetch.
     */
    where: CreditTitleFinanceiroWhereUniqueInput
  }

  /**
   * CreditTitleFinanceiro findUniqueOrThrow
   */
  export type CreditTitleFinanceiroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleFinanceiro to fetch.
     */
    where: CreditTitleFinanceiroWhereUniqueInput
  }

  /**
   * CreditTitleFinanceiro findFirst
   */
  export type CreditTitleFinanceiroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleFinanceiro to fetch.
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleFinanceiros to fetch.
     */
    orderBy?: CreditTitleFinanceiroOrderByWithRelationInput | CreditTitleFinanceiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleFinanceiros.
     */
    cursor?: CreditTitleFinanceiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleFinanceiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleFinanceiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleFinanceiros.
     */
    distinct?: CreditTitleFinanceiroScalarFieldEnum | CreditTitleFinanceiroScalarFieldEnum[]
  }

  /**
   * CreditTitleFinanceiro findFirstOrThrow
   */
  export type CreditTitleFinanceiroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleFinanceiro to fetch.
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleFinanceiros to fetch.
     */
    orderBy?: CreditTitleFinanceiroOrderByWithRelationInput | CreditTitleFinanceiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleFinanceiros.
     */
    cursor?: CreditTitleFinanceiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleFinanceiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleFinanceiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleFinanceiros.
     */
    distinct?: CreditTitleFinanceiroScalarFieldEnum | CreditTitleFinanceiroScalarFieldEnum[]
  }

  /**
   * CreditTitleFinanceiro findMany
   */
  export type CreditTitleFinanceiroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleFinanceiros to fetch.
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleFinanceiros to fetch.
     */
    orderBy?: CreditTitleFinanceiroOrderByWithRelationInput | CreditTitleFinanceiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleFinanceiros.
     */
    cursor?: CreditTitleFinanceiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleFinanceiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleFinanceiros.
     */
    skip?: number
    distinct?: CreditTitleFinanceiroScalarFieldEnum | CreditTitleFinanceiroScalarFieldEnum[]
  }

  /**
   * CreditTitleFinanceiro create
   */
  export type CreditTitleFinanceiroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleFinanceiro.
     */
    data: XOR<CreditTitleFinanceiroCreateInput, CreditTitleFinanceiroUncheckedCreateInput>
  }

  /**
   * CreditTitleFinanceiro createMany
   */
  export type CreditTitleFinanceiroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleFinanceiros.
     */
    data: CreditTitleFinanceiroCreateManyInput | CreditTitleFinanceiroCreateManyInput[]
  }

  /**
   * CreditTitleFinanceiro createManyAndReturn
   */
  export type CreditTitleFinanceiroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleFinanceiros.
     */
    data: CreditTitleFinanceiroCreateManyInput | CreditTitleFinanceiroCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleFinanceiro update
   */
  export type CreditTitleFinanceiroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleFinanceiro.
     */
    data: XOR<CreditTitleFinanceiroUpdateInput, CreditTitleFinanceiroUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleFinanceiro to update.
     */
    where: CreditTitleFinanceiroWhereUniqueInput
  }

  /**
   * CreditTitleFinanceiro updateMany
   */
  export type CreditTitleFinanceiroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleFinanceiros.
     */
    data: XOR<CreditTitleFinanceiroUpdateManyMutationInput, CreditTitleFinanceiroUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleFinanceiros to update
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * Limit how many CreditTitleFinanceiros to update.
     */
    limit?: number
  }

  /**
   * CreditTitleFinanceiro updateManyAndReturn
   */
  export type CreditTitleFinanceiroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleFinanceiros.
     */
    data: XOR<CreditTitleFinanceiroUpdateManyMutationInput, CreditTitleFinanceiroUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleFinanceiros to update
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * Limit how many CreditTitleFinanceiros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleFinanceiro upsert
   */
  export type CreditTitleFinanceiroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleFinanceiro to update in case it exists.
     */
    where: CreditTitleFinanceiroWhereUniqueInput
    /**
     * In case the CreditTitleFinanceiro found by the `where` argument doesn't exist, create a new CreditTitleFinanceiro with this data.
     */
    create: XOR<CreditTitleFinanceiroCreateInput, CreditTitleFinanceiroUncheckedCreateInput>
    /**
     * In case the CreditTitleFinanceiro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleFinanceiroUpdateInput, CreditTitleFinanceiroUncheckedUpdateInput>
  }

  /**
   * CreditTitleFinanceiro delete
   */
  export type CreditTitleFinanceiroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleFinanceiro to delete.
     */
    where: CreditTitleFinanceiroWhereUniqueInput
  }

  /**
   * CreditTitleFinanceiro deleteMany
   */
  export type CreditTitleFinanceiroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleFinanceiros to delete
     */
    where?: CreditTitleFinanceiroWhereInput
    /**
     * Limit how many CreditTitleFinanceiros to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleFinanceiro without action
   */
  export type CreditTitleFinanceiroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleFinanceiro
     */
    select?: CreditTitleFinanceiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleFinanceiro
     */
    omit?: CreditTitleFinanceiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleFinanceiroInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleJudicial
   */

  export type AggregateCreditTitleJudicial = {
    _count: CreditTitleJudicialCountAggregateOutputType | null
    _min: CreditTitleJudicialMinAggregateOutputType | null
    _max: CreditTitleJudicialMaxAggregateOutputType | null
  }

  export type CreditTitleJudicialMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCJudicial | null
    numeroProcesso: string | null
    tribunalOrigem: string | null
    varaOrigem: string | null
    natureza: string | null
    enteDevedor: string | null
  }

  export type CreditTitleJudicialMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCJudicial | null
    numeroProcesso: string | null
    tribunalOrigem: string | null
    varaOrigem: string | null
    natureza: string | null
    enteDevedor: string | null
  }

  export type CreditTitleJudicialCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    numeroProcesso: number
    tribunalOrigem: number
    varaOrigem: number
    natureza: number
    enteDevedor: number
    _all: number
  }


  export type CreditTitleJudicialMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    numeroProcesso?: true
    tribunalOrigem?: true
    varaOrigem?: true
    natureza?: true
    enteDevedor?: true
  }

  export type CreditTitleJudicialMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    numeroProcesso?: true
    tribunalOrigem?: true
    varaOrigem?: true
    natureza?: true
    enteDevedor?: true
  }

  export type CreditTitleJudicialCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    numeroProcesso?: true
    tribunalOrigem?: true
    varaOrigem?: true
    natureza?: true
    enteDevedor?: true
    _all?: true
  }

  export type CreditTitleJudicialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleJudicial to aggregate.
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleJudicials to fetch.
     */
    orderBy?: CreditTitleJudicialOrderByWithRelationInput | CreditTitleJudicialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleJudicialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleJudicials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleJudicials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleJudicials
    **/
    _count?: true | CreditTitleJudicialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleJudicialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleJudicialMaxAggregateInputType
  }

  export type GetCreditTitleJudicialAggregateType<T extends CreditTitleJudicialAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleJudicial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleJudicial[P]>
      : GetScalarType<T[P], AggregateCreditTitleJudicial[P]>
  }




  export type CreditTitleJudicialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleJudicialWhereInput
    orderBy?: CreditTitleJudicialOrderByWithAggregationInput | CreditTitleJudicialOrderByWithAggregationInput[]
    by: CreditTitleJudicialScalarFieldEnum[] | CreditTitleJudicialScalarFieldEnum
    having?: CreditTitleJudicialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleJudicialCountAggregateInputType | true
    _min?: CreditTitleJudicialMinAggregateInputType
    _max?: CreditTitleJudicialMaxAggregateInputType
  }

  export type CreditTitleJudicialGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCJudicial
    numeroProcesso: string
    tribunalOrigem: string
    varaOrigem: string | null
    natureza: string
    enteDevedor: string | null
    _count: CreditTitleJudicialCountAggregateOutputType | null
    _min: CreditTitleJudicialMinAggregateOutputType | null
    _max: CreditTitleJudicialMaxAggregateOutputType | null
  }

  type GetCreditTitleJudicialGroupByPayload<T extends CreditTitleJudicialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleJudicialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleJudicialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleJudicialGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleJudicialGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleJudicialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    numeroProcesso?: boolean
    tribunalOrigem?: boolean
    varaOrigem?: boolean
    natureza?: boolean
    enteDevedor?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleJudicial"]>

  export type CreditTitleJudicialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    numeroProcesso?: boolean
    tribunalOrigem?: boolean
    varaOrigem?: boolean
    natureza?: boolean
    enteDevedor?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleJudicial"]>

  export type CreditTitleJudicialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    numeroProcesso?: boolean
    tribunalOrigem?: boolean
    varaOrigem?: boolean
    natureza?: boolean
    enteDevedor?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleJudicial"]>

  export type CreditTitleJudicialSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    numeroProcesso?: boolean
    tribunalOrigem?: boolean
    varaOrigem?: boolean
    natureza?: boolean
    enteDevedor?: boolean
  }

  export type CreditTitleJudicialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "numeroProcesso" | "tribunalOrigem" | "varaOrigem" | "natureza" | "enteDevedor", ExtArgs["result"]["creditTitleJudicial"]>
  export type CreditTitleJudicialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleJudicialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleJudicialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleJudicialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleJudicial"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCJudicial
      numeroProcesso: string
      tribunalOrigem: string
      varaOrigem: string | null
      natureza: string
      enteDevedor: string | null
    }, ExtArgs["result"]["creditTitleJudicial"]>
    composites: {}
  }

  type CreditTitleJudicialGetPayload<S extends boolean | null | undefined | CreditTitleJudicialDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleJudicialPayload, S>

  type CreditTitleJudicialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleJudicialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleJudicialCountAggregateInputType | true
    }

  export interface CreditTitleJudicialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleJudicial'], meta: { name: 'CreditTitleJudicial' } }
    /**
     * Find zero or one CreditTitleJudicial that matches the filter.
     * @param {CreditTitleJudicialFindUniqueArgs} args - Arguments to find a CreditTitleJudicial
     * @example
     * // Get one CreditTitleJudicial
     * const creditTitleJudicial = await prisma.creditTitleJudicial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleJudicialFindUniqueArgs>(args: SelectSubset<T, CreditTitleJudicialFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleJudicial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleJudicialFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleJudicial
     * @example
     * // Get one CreditTitleJudicial
     * const creditTitleJudicial = await prisma.creditTitleJudicial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleJudicialFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleJudicialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleJudicial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialFindFirstArgs} args - Arguments to find a CreditTitleJudicial
     * @example
     * // Get one CreditTitleJudicial
     * const creditTitleJudicial = await prisma.creditTitleJudicial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleJudicialFindFirstArgs>(args?: SelectSubset<T, CreditTitleJudicialFindFirstArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleJudicial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialFindFirstOrThrowArgs} args - Arguments to find a CreditTitleJudicial
     * @example
     * // Get one CreditTitleJudicial
     * const creditTitleJudicial = await prisma.creditTitleJudicial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleJudicialFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleJudicialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleJudicials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleJudicials
     * const creditTitleJudicials = await prisma.creditTitleJudicial.findMany()
     * 
     * // Get first 10 CreditTitleJudicials
     * const creditTitleJudicials = await prisma.creditTitleJudicial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleJudicialWithIdOnly = await prisma.creditTitleJudicial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleJudicialFindManyArgs>(args?: SelectSubset<T, CreditTitleJudicialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleJudicial.
     * @param {CreditTitleJudicialCreateArgs} args - Arguments to create a CreditTitleJudicial.
     * @example
     * // Create one CreditTitleJudicial
     * const CreditTitleJudicial = await prisma.creditTitleJudicial.create({
     *   data: {
     *     // ... data to create a CreditTitleJudicial
     *   }
     * })
     * 
     */
    create<T extends CreditTitleJudicialCreateArgs>(args: SelectSubset<T, CreditTitleJudicialCreateArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleJudicials.
     * @param {CreditTitleJudicialCreateManyArgs} args - Arguments to create many CreditTitleJudicials.
     * @example
     * // Create many CreditTitleJudicials
     * const creditTitleJudicial = await prisma.creditTitleJudicial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleJudicialCreateManyArgs>(args?: SelectSubset<T, CreditTitleJudicialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleJudicials and returns the data saved in the database.
     * @param {CreditTitleJudicialCreateManyAndReturnArgs} args - Arguments to create many CreditTitleJudicials.
     * @example
     * // Create many CreditTitleJudicials
     * const creditTitleJudicial = await prisma.creditTitleJudicial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleJudicials and only return the `id`
     * const creditTitleJudicialWithIdOnly = await prisma.creditTitleJudicial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleJudicialCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleJudicialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleJudicial.
     * @param {CreditTitleJudicialDeleteArgs} args - Arguments to delete one CreditTitleJudicial.
     * @example
     * // Delete one CreditTitleJudicial
     * const CreditTitleJudicial = await prisma.creditTitleJudicial.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleJudicial
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleJudicialDeleteArgs>(args: SelectSubset<T, CreditTitleJudicialDeleteArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleJudicial.
     * @param {CreditTitleJudicialUpdateArgs} args - Arguments to update one CreditTitleJudicial.
     * @example
     * // Update one CreditTitleJudicial
     * const creditTitleJudicial = await prisma.creditTitleJudicial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleJudicialUpdateArgs>(args: SelectSubset<T, CreditTitleJudicialUpdateArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleJudicials.
     * @param {CreditTitleJudicialDeleteManyArgs} args - Arguments to filter CreditTitleJudicials to delete.
     * @example
     * // Delete a few CreditTitleJudicials
     * const { count } = await prisma.creditTitleJudicial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleJudicialDeleteManyArgs>(args?: SelectSubset<T, CreditTitleJudicialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleJudicials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleJudicials
     * const creditTitleJudicial = await prisma.creditTitleJudicial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleJudicialUpdateManyArgs>(args: SelectSubset<T, CreditTitleJudicialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleJudicials and returns the data updated in the database.
     * @param {CreditTitleJudicialUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleJudicials.
     * @example
     * // Update many CreditTitleJudicials
     * const creditTitleJudicial = await prisma.creditTitleJudicial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleJudicials and only return the `id`
     * const creditTitleJudicialWithIdOnly = await prisma.creditTitleJudicial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleJudicialUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleJudicialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleJudicial.
     * @param {CreditTitleJudicialUpsertArgs} args - Arguments to update or create a CreditTitleJudicial.
     * @example
     * // Update or create a CreditTitleJudicial
     * const creditTitleJudicial = await prisma.creditTitleJudicial.upsert({
     *   create: {
     *     // ... data to create a CreditTitleJudicial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleJudicial we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleJudicialUpsertArgs>(args: SelectSubset<T, CreditTitleJudicialUpsertArgs<ExtArgs>>): Prisma__CreditTitleJudicialClient<$Result.GetResult<Prisma.$CreditTitleJudicialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleJudicials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialCountArgs} args - Arguments to filter CreditTitleJudicials to count.
     * @example
     * // Count the number of CreditTitleJudicials
     * const count = await prisma.creditTitleJudicial.count({
     *   where: {
     *     // ... the filter for the CreditTitleJudicials we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleJudicialCountArgs>(
      args?: Subset<T, CreditTitleJudicialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleJudicialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleJudicial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleJudicialAggregateArgs>(args: Subset<T, CreditTitleJudicialAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleJudicialAggregateType<T>>

    /**
     * Group by CreditTitleJudicial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleJudicialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleJudicialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleJudicialGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleJudicialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleJudicialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleJudicialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleJudicial model
   */
  readonly fields: CreditTitleJudicialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleJudicial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleJudicialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleJudicial model
   */
  interface CreditTitleJudicialFieldRefs {
    readonly id: FieldRef<"CreditTitleJudicial", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleJudicial", 'String'>
    readonly subType: FieldRef<"CreditTitleJudicial", 'TCJudicial'>
    readonly numeroProcesso: FieldRef<"CreditTitleJudicial", 'String'>
    readonly tribunalOrigem: FieldRef<"CreditTitleJudicial", 'String'>
    readonly varaOrigem: FieldRef<"CreditTitleJudicial", 'String'>
    readonly natureza: FieldRef<"CreditTitleJudicial", 'String'>
    readonly enteDevedor: FieldRef<"CreditTitleJudicial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleJudicial findUnique
   */
  export type CreditTitleJudicialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleJudicial to fetch.
     */
    where: CreditTitleJudicialWhereUniqueInput
  }

  /**
   * CreditTitleJudicial findUniqueOrThrow
   */
  export type CreditTitleJudicialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleJudicial to fetch.
     */
    where: CreditTitleJudicialWhereUniqueInput
  }

  /**
   * CreditTitleJudicial findFirst
   */
  export type CreditTitleJudicialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleJudicial to fetch.
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleJudicials to fetch.
     */
    orderBy?: CreditTitleJudicialOrderByWithRelationInput | CreditTitleJudicialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleJudicials.
     */
    cursor?: CreditTitleJudicialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleJudicials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleJudicials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleJudicials.
     */
    distinct?: CreditTitleJudicialScalarFieldEnum | CreditTitleJudicialScalarFieldEnum[]
  }

  /**
   * CreditTitleJudicial findFirstOrThrow
   */
  export type CreditTitleJudicialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleJudicial to fetch.
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleJudicials to fetch.
     */
    orderBy?: CreditTitleJudicialOrderByWithRelationInput | CreditTitleJudicialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleJudicials.
     */
    cursor?: CreditTitleJudicialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleJudicials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleJudicials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleJudicials.
     */
    distinct?: CreditTitleJudicialScalarFieldEnum | CreditTitleJudicialScalarFieldEnum[]
  }

  /**
   * CreditTitleJudicial findMany
   */
  export type CreditTitleJudicialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleJudicials to fetch.
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleJudicials to fetch.
     */
    orderBy?: CreditTitleJudicialOrderByWithRelationInput | CreditTitleJudicialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleJudicials.
     */
    cursor?: CreditTitleJudicialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleJudicials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleJudicials.
     */
    skip?: number
    distinct?: CreditTitleJudicialScalarFieldEnum | CreditTitleJudicialScalarFieldEnum[]
  }

  /**
   * CreditTitleJudicial create
   */
  export type CreditTitleJudicialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleJudicial.
     */
    data: XOR<CreditTitleJudicialCreateInput, CreditTitleJudicialUncheckedCreateInput>
  }

  /**
   * CreditTitleJudicial createMany
   */
  export type CreditTitleJudicialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleJudicials.
     */
    data: CreditTitleJudicialCreateManyInput | CreditTitleJudicialCreateManyInput[]
  }

  /**
   * CreditTitleJudicial createManyAndReturn
   */
  export type CreditTitleJudicialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleJudicials.
     */
    data: CreditTitleJudicialCreateManyInput | CreditTitleJudicialCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleJudicial update
   */
  export type CreditTitleJudicialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleJudicial.
     */
    data: XOR<CreditTitleJudicialUpdateInput, CreditTitleJudicialUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleJudicial to update.
     */
    where: CreditTitleJudicialWhereUniqueInput
  }

  /**
   * CreditTitleJudicial updateMany
   */
  export type CreditTitleJudicialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleJudicials.
     */
    data: XOR<CreditTitleJudicialUpdateManyMutationInput, CreditTitleJudicialUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleJudicials to update
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * Limit how many CreditTitleJudicials to update.
     */
    limit?: number
  }

  /**
   * CreditTitleJudicial updateManyAndReturn
   */
  export type CreditTitleJudicialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleJudicials.
     */
    data: XOR<CreditTitleJudicialUpdateManyMutationInput, CreditTitleJudicialUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleJudicials to update
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * Limit how many CreditTitleJudicials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleJudicial upsert
   */
  export type CreditTitleJudicialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleJudicial to update in case it exists.
     */
    where: CreditTitleJudicialWhereUniqueInput
    /**
     * In case the CreditTitleJudicial found by the `where` argument doesn't exist, create a new CreditTitleJudicial with this data.
     */
    create: XOR<CreditTitleJudicialCreateInput, CreditTitleJudicialUncheckedCreateInput>
    /**
     * In case the CreditTitleJudicial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleJudicialUpdateInput, CreditTitleJudicialUncheckedUpdateInput>
  }

  /**
   * CreditTitleJudicial delete
   */
  export type CreditTitleJudicialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleJudicial to delete.
     */
    where: CreditTitleJudicialWhereUniqueInput
  }

  /**
   * CreditTitleJudicial deleteMany
   */
  export type CreditTitleJudicialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleJudicials to delete
     */
    where?: CreditTitleJudicialWhereInput
    /**
     * Limit how many CreditTitleJudicials to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleJudicial without action
   */
  export type CreditTitleJudicialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleJudicial
     */
    select?: CreditTitleJudicialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleJudicial
     */
    omit?: CreditTitleJudicialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleJudicialInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleRural
   */

  export type AggregateCreditTitleRural = {
    _count: CreditTitleRuralCountAggregateOutputType | null
    _avg: CreditTitleRuralAvgAggregateOutputType | null
    _sum: CreditTitleRuralSumAggregateOutputType | null
    _min: CreditTitleRuralMinAggregateOutputType | null
    _max: CreditTitleRuralMaxAggregateOutputType | null
  }

  export type CreditTitleRuralAvgAggregateOutputType = {
    areaFinanciadaHectares: number | null
  }

  export type CreditTitleRuralSumAggregateOutputType = {
    areaFinanciadaHectares: number | null
  }

  export type CreditTitleRuralMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCRural | null
    safra: string | null
    produtoAgricola: string | null
    areaFinanciadaHectares: number | null
    registroImovelRural: string | null
  }

  export type CreditTitleRuralMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCRural | null
    safra: string | null
    produtoAgricola: string | null
    areaFinanciadaHectares: number | null
    registroImovelRural: string | null
  }

  export type CreditTitleRuralCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    safra: number
    produtoAgricola: number
    areaFinanciadaHectares: number
    registroImovelRural: number
    _all: number
  }


  export type CreditTitleRuralAvgAggregateInputType = {
    areaFinanciadaHectares?: true
  }

  export type CreditTitleRuralSumAggregateInputType = {
    areaFinanciadaHectares?: true
  }

  export type CreditTitleRuralMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    safra?: true
    produtoAgricola?: true
    areaFinanciadaHectares?: true
    registroImovelRural?: true
  }

  export type CreditTitleRuralMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    safra?: true
    produtoAgricola?: true
    areaFinanciadaHectares?: true
    registroImovelRural?: true
  }

  export type CreditTitleRuralCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    safra?: true
    produtoAgricola?: true
    areaFinanciadaHectares?: true
    registroImovelRural?: true
    _all?: true
  }

  export type CreditTitleRuralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleRural to aggregate.
     */
    where?: CreditTitleRuralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleRurals to fetch.
     */
    orderBy?: CreditTitleRuralOrderByWithRelationInput | CreditTitleRuralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleRuralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleRurals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleRurals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleRurals
    **/
    _count?: true | CreditTitleRuralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditTitleRuralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditTitleRuralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleRuralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleRuralMaxAggregateInputType
  }

  export type GetCreditTitleRuralAggregateType<T extends CreditTitleRuralAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleRural]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleRural[P]>
      : GetScalarType<T[P], AggregateCreditTitleRural[P]>
  }




  export type CreditTitleRuralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleRuralWhereInput
    orderBy?: CreditTitleRuralOrderByWithAggregationInput | CreditTitleRuralOrderByWithAggregationInput[]
    by: CreditTitleRuralScalarFieldEnum[] | CreditTitleRuralScalarFieldEnum
    having?: CreditTitleRuralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleRuralCountAggregateInputType | true
    _avg?: CreditTitleRuralAvgAggregateInputType
    _sum?: CreditTitleRuralSumAggregateInputType
    _min?: CreditTitleRuralMinAggregateInputType
    _max?: CreditTitleRuralMaxAggregateInputType
  }

  export type CreditTitleRuralGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCRural
    safra: string | null
    produtoAgricola: string | null
    areaFinanciadaHectares: number | null
    registroImovelRural: string | null
    _count: CreditTitleRuralCountAggregateOutputType | null
    _avg: CreditTitleRuralAvgAggregateOutputType | null
    _sum: CreditTitleRuralSumAggregateOutputType | null
    _min: CreditTitleRuralMinAggregateOutputType | null
    _max: CreditTitleRuralMaxAggregateOutputType | null
  }

  type GetCreditTitleRuralGroupByPayload<T extends CreditTitleRuralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleRuralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleRuralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleRuralGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleRuralGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleRuralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    safra?: boolean
    produtoAgricola?: boolean
    areaFinanciadaHectares?: boolean
    registroImovelRural?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleRural"]>

  export type CreditTitleRuralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    safra?: boolean
    produtoAgricola?: boolean
    areaFinanciadaHectares?: boolean
    registroImovelRural?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleRural"]>

  export type CreditTitleRuralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    safra?: boolean
    produtoAgricola?: boolean
    areaFinanciadaHectares?: boolean
    registroImovelRural?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleRural"]>

  export type CreditTitleRuralSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    safra?: boolean
    produtoAgricola?: boolean
    areaFinanciadaHectares?: boolean
    registroImovelRural?: boolean
  }

  export type CreditTitleRuralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "safra" | "produtoAgricola" | "areaFinanciadaHectares" | "registroImovelRural", ExtArgs["result"]["creditTitleRural"]>
  export type CreditTitleRuralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleRuralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleRuralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleRuralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleRural"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCRural
      safra: string | null
      produtoAgricola: string | null
      areaFinanciadaHectares: number | null
      registroImovelRural: string | null
    }, ExtArgs["result"]["creditTitleRural"]>
    composites: {}
  }

  type CreditTitleRuralGetPayload<S extends boolean | null | undefined | CreditTitleRuralDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleRuralPayload, S>

  type CreditTitleRuralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleRuralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleRuralCountAggregateInputType | true
    }

  export interface CreditTitleRuralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleRural'], meta: { name: 'CreditTitleRural' } }
    /**
     * Find zero or one CreditTitleRural that matches the filter.
     * @param {CreditTitleRuralFindUniqueArgs} args - Arguments to find a CreditTitleRural
     * @example
     * // Get one CreditTitleRural
     * const creditTitleRural = await prisma.creditTitleRural.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleRuralFindUniqueArgs>(args: SelectSubset<T, CreditTitleRuralFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleRural that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleRuralFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleRural
     * @example
     * // Get one CreditTitleRural
     * const creditTitleRural = await prisma.creditTitleRural.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleRuralFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleRuralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleRural that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralFindFirstArgs} args - Arguments to find a CreditTitleRural
     * @example
     * // Get one CreditTitleRural
     * const creditTitleRural = await prisma.creditTitleRural.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleRuralFindFirstArgs>(args?: SelectSubset<T, CreditTitleRuralFindFirstArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleRural that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralFindFirstOrThrowArgs} args - Arguments to find a CreditTitleRural
     * @example
     * // Get one CreditTitleRural
     * const creditTitleRural = await prisma.creditTitleRural.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleRuralFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleRuralFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleRurals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleRurals
     * const creditTitleRurals = await prisma.creditTitleRural.findMany()
     * 
     * // Get first 10 CreditTitleRurals
     * const creditTitleRurals = await prisma.creditTitleRural.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleRuralWithIdOnly = await prisma.creditTitleRural.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleRuralFindManyArgs>(args?: SelectSubset<T, CreditTitleRuralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleRural.
     * @param {CreditTitleRuralCreateArgs} args - Arguments to create a CreditTitleRural.
     * @example
     * // Create one CreditTitleRural
     * const CreditTitleRural = await prisma.creditTitleRural.create({
     *   data: {
     *     // ... data to create a CreditTitleRural
     *   }
     * })
     * 
     */
    create<T extends CreditTitleRuralCreateArgs>(args: SelectSubset<T, CreditTitleRuralCreateArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleRurals.
     * @param {CreditTitleRuralCreateManyArgs} args - Arguments to create many CreditTitleRurals.
     * @example
     * // Create many CreditTitleRurals
     * const creditTitleRural = await prisma.creditTitleRural.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleRuralCreateManyArgs>(args?: SelectSubset<T, CreditTitleRuralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleRurals and returns the data saved in the database.
     * @param {CreditTitleRuralCreateManyAndReturnArgs} args - Arguments to create many CreditTitleRurals.
     * @example
     * // Create many CreditTitleRurals
     * const creditTitleRural = await prisma.creditTitleRural.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleRurals and only return the `id`
     * const creditTitleRuralWithIdOnly = await prisma.creditTitleRural.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleRuralCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleRuralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleRural.
     * @param {CreditTitleRuralDeleteArgs} args - Arguments to delete one CreditTitleRural.
     * @example
     * // Delete one CreditTitleRural
     * const CreditTitleRural = await prisma.creditTitleRural.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleRural
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleRuralDeleteArgs>(args: SelectSubset<T, CreditTitleRuralDeleteArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleRural.
     * @param {CreditTitleRuralUpdateArgs} args - Arguments to update one CreditTitleRural.
     * @example
     * // Update one CreditTitleRural
     * const creditTitleRural = await prisma.creditTitleRural.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleRuralUpdateArgs>(args: SelectSubset<T, CreditTitleRuralUpdateArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleRurals.
     * @param {CreditTitleRuralDeleteManyArgs} args - Arguments to filter CreditTitleRurals to delete.
     * @example
     * // Delete a few CreditTitleRurals
     * const { count } = await prisma.creditTitleRural.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleRuralDeleteManyArgs>(args?: SelectSubset<T, CreditTitleRuralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleRurals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleRurals
     * const creditTitleRural = await prisma.creditTitleRural.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleRuralUpdateManyArgs>(args: SelectSubset<T, CreditTitleRuralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleRurals and returns the data updated in the database.
     * @param {CreditTitleRuralUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleRurals.
     * @example
     * // Update many CreditTitleRurals
     * const creditTitleRural = await prisma.creditTitleRural.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleRurals and only return the `id`
     * const creditTitleRuralWithIdOnly = await prisma.creditTitleRural.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleRuralUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleRuralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleRural.
     * @param {CreditTitleRuralUpsertArgs} args - Arguments to update or create a CreditTitleRural.
     * @example
     * // Update or create a CreditTitleRural
     * const creditTitleRural = await prisma.creditTitleRural.upsert({
     *   create: {
     *     // ... data to create a CreditTitleRural
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleRural we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleRuralUpsertArgs>(args: SelectSubset<T, CreditTitleRuralUpsertArgs<ExtArgs>>): Prisma__CreditTitleRuralClient<$Result.GetResult<Prisma.$CreditTitleRuralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleRurals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralCountArgs} args - Arguments to filter CreditTitleRurals to count.
     * @example
     * // Count the number of CreditTitleRurals
     * const count = await prisma.creditTitleRural.count({
     *   where: {
     *     // ... the filter for the CreditTitleRurals we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleRuralCountArgs>(
      args?: Subset<T, CreditTitleRuralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleRuralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleRural.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleRuralAggregateArgs>(args: Subset<T, CreditTitleRuralAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleRuralAggregateType<T>>

    /**
     * Group by CreditTitleRural.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleRuralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleRuralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleRuralGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleRuralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleRuralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleRuralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleRural model
   */
  readonly fields: CreditTitleRuralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleRural.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleRuralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleRural model
   */
  interface CreditTitleRuralFieldRefs {
    readonly id: FieldRef<"CreditTitleRural", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleRural", 'String'>
    readonly subType: FieldRef<"CreditTitleRural", 'TCRural'>
    readonly safra: FieldRef<"CreditTitleRural", 'String'>
    readonly produtoAgricola: FieldRef<"CreditTitleRural", 'String'>
    readonly areaFinanciadaHectares: FieldRef<"CreditTitleRural", 'Float'>
    readonly registroImovelRural: FieldRef<"CreditTitleRural", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleRural findUnique
   */
  export type CreditTitleRuralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleRural to fetch.
     */
    where: CreditTitleRuralWhereUniqueInput
  }

  /**
   * CreditTitleRural findUniqueOrThrow
   */
  export type CreditTitleRuralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleRural to fetch.
     */
    where: CreditTitleRuralWhereUniqueInput
  }

  /**
   * CreditTitleRural findFirst
   */
  export type CreditTitleRuralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleRural to fetch.
     */
    where?: CreditTitleRuralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleRurals to fetch.
     */
    orderBy?: CreditTitleRuralOrderByWithRelationInput | CreditTitleRuralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleRurals.
     */
    cursor?: CreditTitleRuralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleRurals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleRurals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleRurals.
     */
    distinct?: CreditTitleRuralScalarFieldEnum | CreditTitleRuralScalarFieldEnum[]
  }

  /**
   * CreditTitleRural findFirstOrThrow
   */
  export type CreditTitleRuralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleRural to fetch.
     */
    where?: CreditTitleRuralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleRurals to fetch.
     */
    orderBy?: CreditTitleRuralOrderByWithRelationInput | CreditTitleRuralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleRurals.
     */
    cursor?: CreditTitleRuralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleRurals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleRurals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleRurals.
     */
    distinct?: CreditTitleRuralScalarFieldEnum | CreditTitleRuralScalarFieldEnum[]
  }

  /**
   * CreditTitleRural findMany
   */
  export type CreditTitleRuralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleRurals to fetch.
     */
    where?: CreditTitleRuralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleRurals to fetch.
     */
    orderBy?: CreditTitleRuralOrderByWithRelationInput | CreditTitleRuralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleRurals.
     */
    cursor?: CreditTitleRuralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleRurals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleRurals.
     */
    skip?: number
    distinct?: CreditTitleRuralScalarFieldEnum | CreditTitleRuralScalarFieldEnum[]
  }

  /**
   * CreditTitleRural create
   */
  export type CreditTitleRuralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleRural.
     */
    data: XOR<CreditTitleRuralCreateInput, CreditTitleRuralUncheckedCreateInput>
  }

  /**
   * CreditTitleRural createMany
   */
  export type CreditTitleRuralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleRurals.
     */
    data: CreditTitleRuralCreateManyInput | CreditTitleRuralCreateManyInput[]
  }

  /**
   * CreditTitleRural createManyAndReturn
   */
  export type CreditTitleRuralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleRurals.
     */
    data: CreditTitleRuralCreateManyInput | CreditTitleRuralCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleRural update
   */
  export type CreditTitleRuralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleRural.
     */
    data: XOR<CreditTitleRuralUpdateInput, CreditTitleRuralUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleRural to update.
     */
    where: CreditTitleRuralWhereUniqueInput
  }

  /**
   * CreditTitleRural updateMany
   */
  export type CreditTitleRuralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleRurals.
     */
    data: XOR<CreditTitleRuralUpdateManyMutationInput, CreditTitleRuralUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleRurals to update
     */
    where?: CreditTitleRuralWhereInput
    /**
     * Limit how many CreditTitleRurals to update.
     */
    limit?: number
  }

  /**
   * CreditTitleRural updateManyAndReturn
   */
  export type CreditTitleRuralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleRurals.
     */
    data: XOR<CreditTitleRuralUpdateManyMutationInput, CreditTitleRuralUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleRurals to update
     */
    where?: CreditTitleRuralWhereInput
    /**
     * Limit how many CreditTitleRurals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleRural upsert
   */
  export type CreditTitleRuralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleRural to update in case it exists.
     */
    where: CreditTitleRuralWhereUniqueInput
    /**
     * In case the CreditTitleRural found by the `where` argument doesn't exist, create a new CreditTitleRural with this data.
     */
    create: XOR<CreditTitleRuralCreateInput, CreditTitleRuralUncheckedCreateInput>
    /**
     * In case the CreditTitleRural was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleRuralUpdateInput, CreditTitleRuralUncheckedUpdateInput>
  }

  /**
   * CreditTitleRural delete
   */
  export type CreditTitleRuralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleRural to delete.
     */
    where: CreditTitleRuralWhereUniqueInput
  }

  /**
   * CreditTitleRural deleteMany
   */
  export type CreditTitleRuralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleRurals to delete
     */
    where?: CreditTitleRuralWhereInput
    /**
     * Limit how many CreditTitleRurals to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleRural without action
   */
  export type CreditTitleRuralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleRural
     */
    select?: CreditTitleRuralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleRural
     */
    omit?: CreditTitleRuralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleRuralInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleImobiliario
   */

  export type AggregateCreditTitleImobiliario = {
    _count: CreditTitleImobiliarioCountAggregateOutputType | null
    _min: CreditTitleImobiliarioMinAggregateOutputType | null
    _max: CreditTitleImobiliarioMaxAggregateOutputType | null
  }

  export type CreditTitleImobiliarioMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCImobiliario | null
    matriculaImovel: string | null
    enderecoLogradouro: string | null
    enderecoNumero: string | null
    enderecoComplemento: string | null
    enderecoBairro: string | null
    enderecoCidade: string | null
    enderecoEstado: string | null
    enderecoCep: string | null
    tipoGarantia: string | null
  }

  export type CreditTitleImobiliarioMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCImobiliario | null
    matriculaImovel: string | null
    enderecoLogradouro: string | null
    enderecoNumero: string | null
    enderecoComplemento: string | null
    enderecoBairro: string | null
    enderecoCidade: string | null
    enderecoEstado: string | null
    enderecoCep: string | null
    tipoGarantia: string | null
  }

  export type CreditTitleImobiliarioCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    matriculaImovel: number
    enderecoLogradouro: number
    enderecoNumero: number
    enderecoComplemento: number
    enderecoBairro: number
    enderecoCidade: number
    enderecoEstado: number
    enderecoCep: number
    tipoGarantia: number
    _all: number
  }


  export type CreditTitleImobiliarioMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    matriculaImovel?: true
    enderecoLogradouro?: true
    enderecoNumero?: true
    enderecoComplemento?: true
    enderecoBairro?: true
    enderecoCidade?: true
    enderecoEstado?: true
    enderecoCep?: true
    tipoGarantia?: true
  }

  export type CreditTitleImobiliarioMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    matriculaImovel?: true
    enderecoLogradouro?: true
    enderecoNumero?: true
    enderecoComplemento?: true
    enderecoBairro?: true
    enderecoCidade?: true
    enderecoEstado?: true
    enderecoCep?: true
    tipoGarantia?: true
  }

  export type CreditTitleImobiliarioCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    matriculaImovel?: true
    enderecoLogradouro?: true
    enderecoNumero?: true
    enderecoComplemento?: true
    enderecoBairro?: true
    enderecoCidade?: true
    enderecoEstado?: true
    enderecoCep?: true
    tipoGarantia?: true
    _all?: true
  }

  export type CreditTitleImobiliarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleImobiliario to aggregate.
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleImobiliarios to fetch.
     */
    orderBy?: CreditTitleImobiliarioOrderByWithRelationInput | CreditTitleImobiliarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleImobiliarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleImobiliarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleImobiliarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleImobiliarios
    **/
    _count?: true | CreditTitleImobiliarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleImobiliarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleImobiliarioMaxAggregateInputType
  }

  export type GetCreditTitleImobiliarioAggregateType<T extends CreditTitleImobiliarioAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleImobiliario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleImobiliario[P]>
      : GetScalarType<T[P], AggregateCreditTitleImobiliario[P]>
  }




  export type CreditTitleImobiliarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleImobiliarioWhereInput
    orderBy?: CreditTitleImobiliarioOrderByWithAggregationInput | CreditTitleImobiliarioOrderByWithAggregationInput[]
    by: CreditTitleImobiliarioScalarFieldEnum[] | CreditTitleImobiliarioScalarFieldEnum
    having?: CreditTitleImobiliarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleImobiliarioCountAggregateInputType | true
    _min?: CreditTitleImobiliarioMinAggregateInputType
    _max?: CreditTitleImobiliarioMaxAggregateInputType
  }

  export type CreditTitleImobiliarioGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCImobiliario
    matriculaImovel: string
    enderecoLogradouro: string
    enderecoNumero: string
    enderecoComplemento: string | null
    enderecoBairro: string
    enderecoCidade: string
    enderecoEstado: string
    enderecoCep: string
    tipoGarantia: string | null
    _count: CreditTitleImobiliarioCountAggregateOutputType | null
    _min: CreditTitleImobiliarioMinAggregateOutputType | null
    _max: CreditTitleImobiliarioMaxAggregateOutputType | null
  }

  type GetCreditTitleImobiliarioGroupByPayload<T extends CreditTitleImobiliarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleImobiliarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleImobiliarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleImobiliarioGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleImobiliarioGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleImobiliarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    matriculaImovel?: boolean
    enderecoLogradouro?: boolean
    enderecoNumero?: boolean
    enderecoComplemento?: boolean
    enderecoBairro?: boolean
    enderecoCidade?: boolean
    enderecoEstado?: boolean
    enderecoCep?: boolean
    tipoGarantia?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleImobiliario"]>

  export type CreditTitleImobiliarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    matriculaImovel?: boolean
    enderecoLogradouro?: boolean
    enderecoNumero?: boolean
    enderecoComplemento?: boolean
    enderecoBairro?: boolean
    enderecoCidade?: boolean
    enderecoEstado?: boolean
    enderecoCep?: boolean
    tipoGarantia?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleImobiliario"]>

  export type CreditTitleImobiliarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    matriculaImovel?: boolean
    enderecoLogradouro?: boolean
    enderecoNumero?: boolean
    enderecoComplemento?: boolean
    enderecoBairro?: boolean
    enderecoCidade?: boolean
    enderecoEstado?: boolean
    enderecoCep?: boolean
    tipoGarantia?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleImobiliario"]>

  export type CreditTitleImobiliarioSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    matriculaImovel?: boolean
    enderecoLogradouro?: boolean
    enderecoNumero?: boolean
    enderecoComplemento?: boolean
    enderecoBairro?: boolean
    enderecoCidade?: boolean
    enderecoEstado?: boolean
    enderecoCep?: boolean
    tipoGarantia?: boolean
  }

  export type CreditTitleImobiliarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "matriculaImovel" | "enderecoLogradouro" | "enderecoNumero" | "enderecoComplemento" | "enderecoBairro" | "enderecoCidade" | "enderecoEstado" | "enderecoCep" | "tipoGarantia", ExtArgs["result"]["creditTitleImobiliario"]>
  export type CreditTitleImobiliarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleImobiliarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleImobiliarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleImobiliarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleImobiliario"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCImobiliario
      matriculaImovel: string
      enderecoLogradouro: string
      enderecoNumero: string
      enderecoComplemento: string | null
      enderecoBairro: string
      enderecoCidade: string
      enderecoEstado: string
      enderecoCep: string
      tipoGarantia: string | null
    }, ExtArgs["result"]["creditTitleImobiliario"]>
    composites: {}
  }

  type CreditTitleImobiliarioGetPayload<S extends boolean | null | undefined | CreditTitleImobiliarioDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleImobiliarioPayload, S>

  type CreditTitleImobiliarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleImobiliarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleImobiliarioCountAggregateInputType | true
    }

  export interface CreditTitleImobiliarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleImobiliario'], meta: { name: 'CreditTitleImobiliario' } }
    /**
     * Find zero or one CreditTitleImobiliario that matches the filter.
     * @param {CreditTitleImobiliarioFindUniqueArgs} args - Arguments to find a CreditTitleImobiliario
     * @example
     * // Get one CreditTitleImobiliario
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleImobiliarioFindUniqueArgs>(args: SelectSubset<T, CreditTitleImobiliarioFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleImobiliario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleImobiliarioFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleImobiliario
     * @example
     * // Get one CreditTitleImobiliario
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleImobiliarioFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleImobiliarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleImobiliario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioFindFirstArgs} args - Arguments to find a CreditTitleImobiliario
     * @example
     * // Get one CreditTitleImobiliario
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleImobiliarioFindFirstArgs>(args?: SelectSubset<T, CreditTitleImobiliarioFindFirstArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleImobiliario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioFindFirstOrThrowArgs} args - Arguments to find a CreditTitleImobiliario
     * @example
     * // Get one CreditTitleImobiliario
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleImobiliarioFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleImobiliarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleImobiliarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleImobiliarios
     * const creditTitleImobiliarios = await prisma.creditTitleImobiliario.findMany()
     * 
     * // Get first 10 CreditTitleImobiliarios
     * const creditTitleImobiliarios = await prisma.creditTitleImobiliario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleImobiliarioWithIdOnly = await prisma.creditTitleImobiliario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleImobiliarioFindManyArgs>(args?: SelectSubset<T, CreditTitleImobiliarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleImobiliario.
     * @param {CreditTitleImobiliarioCreateArgs} args - Arguments to create a CreditTitleImobiliario.
     * @example
     * // Create one CreditTitleImobiliario
     * const CreditTitleImobiliario = await prisma.creditTitleImobiliario.create({
     *   data: {
     *     // ... data to create a CreditTitleImobiliario
     *   }
     * })
     * 
     */
    create<T extends CreditTitleImobiliarioCreateArgs>(args: SelectSubset<T, CreditTitleImobiliarioCreateArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleImobiliarios.
     * @param {CreditTitleImobiliarioCreateManyArgs} args - Arguments to create many CreditTitleImobiliarios.
     * @example
     * // Create many CreditTitleImobiliarios
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleImobiliarioCreateManyArgs>(args?: SelectSubset<T, CreditTitleImobiliarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleImobiliarios and returns the data saved in the database.
     * @param {CreditTitleImobiliarioCreateManyAndReturnArgs} args - Arguments to create many CreditTitleImobiliarios.
     * @example
     * // Create many CreditTitleImobiliarios
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleImobiliarios and only return the `id`
     * const creditTitleImobiliarioWithIdOnly = await prisma.creditTitleImobiliario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleImobiliarioCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleImobiliarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleImobiliario.
     * @param {CreditTitleImobiliarioDeleteArgs} args - Arguments to delete one CreditTitleImobiliario.
     * @example
     * // Delete one CreditTitleImobiliario
     * const CreditTitleImobiliario = await prisma.creditTitleImobiliario.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleImobiliario
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleImobiliarioDeleteArgs>(args: SelectSubset<T, CreditTitleImobiliarioDeleteArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleImobiliario.
     * @param {CreditTitleImobiliarioUpdateArgs} args - Arguments to update one CreditTitleImobiliario.
     * @example
     * // Update one CreditTitleImobiliario
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleImobiliarioUpdateArgs>(args: SelectSubset<T, CreditTitleImobiliarioUpdateArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleImobiliarios.
     * @param {CreditTitleImobiliarioDeleteManyArgs} args - Arguments to filter CreditTitleImobiliarios to delete.
     * @example
     * // Delete a few CreditTitleImobiliarios
     * const { count } = await prisma.creditTitleImobiliario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleImobiliarioDeleteManyArgs>(args?: SelectSubset<T, CreditTitleImobiliarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleImobiliarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleImobiliarios
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleImobiliarioUpdateManyArgs>(args: SelectSubset<T, CreditTitleImobiliarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleImobiliarios and returns the data updated in the database.
     * @param {CreditTitleImobiliarioUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleImobiliarios.
     * @example
     * // Update many CreditTitleImobiliarios
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleImobiliarios and only return the `id`
     * const creditTitleImobiliarioWithIdOnly = await prisma.creditTitleImobiliario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleImobiliarioUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleImobiliarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleImobiliario.
     * @param {CreditTitleImobiliarioUpsertArgs} args - Arguments to update or create a CreditTitleImobiliario.
     * @example
     * // Update or create a CreditTitleImobiliario
     * const creditTitleImobiliario = await prisma.creditTitleImobiliario.upsert({
     *   create: {
     *     // ... data to create a CreditTitleImobiliario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleImobiliario we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleImobiliarioUpsertArgs>(args: SelectSubset<T, CreditTitleImobiliarioUpsertArgs<ExtArgs>>): Prisma__CreditTitleImobiliarioClient<$Result.GetResult<Prisma.$CreditTitleImobiliarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleImobiliarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioCountArgs} args - Arguments to filter CreditTitleImobiliarios to count.
     * @example
     * // Count the number of CreditTitleImobiliarios
     * const count = await prisma.creditTitleImobiliario.count({
     *   where: {
     *     // ... the filter for the CreditTitleImobiliarios we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleImobiliarioCountArgs>(
      args?: Subset<T, CreditTitleImobiliarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleImobiliarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleImobiliario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleImobiliarioAggregateArgs>(args: Subset<T, CreditTitleImobiliarioAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleImobiliarioAggregateType<T>>

    /**
     * Group by CreditTitleImobiliario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleImobiliarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleImobiliarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleImobiliarioGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleImobiliarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleImobiliarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleImobiliarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleImobiliario model
   */
  readonly fields: CreditTitleImobiliarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleImobiliario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleImobiliarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleImobiliario model
   */
  interface CreditTitleImobiliarioFieldRefs {
    readonly id: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly subType: FieldRef<"CreditTitleImobiliario", 'TCImobiliario'>
    readonly matriculaImovel: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoLogradouro: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoNumero: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoComplemento: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoBairro: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoCidade: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoEstado: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly enderecoCep: FieldRef<"CreditTitleImobiliario", 'String'>
    readonly tipoGarantia: FieldRef<"CreditTitleImobiliario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleImobiliario findUnique
   */
  export type CreditTitleImobiliarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleImobiliario to fetch.
     */
    where: CreditTitleImobiliarioWhereUniqueInput
  }

  /**
   * CreditTitleImobiliario findUniqueOrThrow
   */
  export type CreditTitleImobiliarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleImobiliario to fetch.
     */
    where: CreditTitleImobiliarioWhereUniqueInput
  }

  /**
   * CreditTitleImobiliario findFirst
   */
  export type CreditTitleImobiliarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleImobiliario to fetch.
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleImobiliarios to fetch.
     */
    orderBy?: CreditTitleImobiliarioOrderByWithRelationInput | CreditTitleImobiliarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleImobiliarios.
     */
    cursor?: CreditTitleImobiliarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleImobiliarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleImobiliarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleImobiliarios.
     */
    distinct?: CreditTitleImobiliarioScalarFieldEnum | CreditTitleImobiliarioScalarFieldEnum[]
  }

  /**
   * CreditTitleImobiliario findFirstOrThrow
   */
  export type CreditTitleImobiliarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleImobiliario to fetch.
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleImobiliarios to fetch.
     */
    orderBy?: CreditTitleImobiliarioOrderByWithRelationInput | CreditTitleImobiliarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleImobiliarios.
     */
    cursor?: CreditTitleImobiliarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleImobiliarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleImobiliarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleImobiliarios.
     */
    distinct?: CreditTitleImobiliarioScalarFieldEnum | CreditTitleImobiliarioScalarFieldEnum[]
  }

  /**
   * CreditTitleImobiliario findMany
   */
  export type CreditTitleImobiliarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleImobiliarios to fetch.
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleImobiliarios to fetch.
     */
    orderBy?: CreditTitleImobiliarioOrderByWithRelationInput | CreditTitleImobiliarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleImobiliarios.
     */
    cursor?: CreditTitleImobiliarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleImobiliarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleImobiliarios.
     */
    skip?: number
    distinct?: CreditTitleImobiliarioScalarFieldEnum | CreditTitleImobiliarioScalarFieldEnum[]
  }

  /**
   * CreditTitleImobiliario create
   */
  export type CreditTitleImobiliarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleImobiliario.
     */
    data: XOR<CreditTitleImobiliarioCreateInput, CreditTitleImobiliarioUncheckedCreateInput>
  }

  /**
   * CreditTitleImobiliario createMany
   */
  export type CreditTitleImobiliarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleImobiliarios.
     */
    data: CreditTitleImobiliarioCreateManyInput | CreditTitleImobiliarioCreateManyInput[]
  }

  /**
   * CreditTitleImobiliario createManyAndReturn
   */
  export type CreditTitleImobiliarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleImobiliarios.
     */
    data: CreditTitleImobiliarioCreateManyInput | CreditTitleImobiliarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleImobiliario update
   */
  export type CreditTitleImobiliarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleImobiliario.
     */
    data: XOR<CreditTitleImobiliarioUpdateInput, CreditTitleImobiliarioUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleImobiliario to update.
     */
    where: CreditTitleImobiliarioWhereUniqueInput
  }

  /**
   * CreditTitleImobiliario updateMany
   */
  export type CreditTitleImobiliarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleImobiliarios.
     */
    data: XOR<CreditTitleImobiliarioUpdateManyMutationInput, CreditTitleImobiliarioUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleImobiliarios to update
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * Limit how many CreditTitleImobiliarios to update.
     */
    limit?: number
  }

  /**
   * CreditTitleImobiliario updateManyAndReturn
   */
  export type CreditTitleImobiliarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleImobiliarios.
     */
    data: XOR<CreditTitleImobiliarioUpdateManyMutationInput, CreditTitleImobiliarioUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleImobiliarios to update
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * Limit how many CreditTitleImobiliarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleImobiliario upsert
   */
  export type CreditTitleImobiliarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleImobiliario to update in case it exists.
     */
    where: CreditTitleImobiliarioWhereUniqueInput
    /**
     * In case the CreditTitleImobiliario found by the `where` argument doesn't exist, create a new CreditTitleImobiliario with this data.
     */
    create: XOR<CreditTitleImobiliarioCreateInput, CreditTitleImobiliarioUncheckedCreateInput>
    /**
     * In case the CreditTitleImobiliario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleImobiliarioUpdateInput, CreditTitleImobiliarioUncheckedUpdateInput>
  }

  /**
   * CreditTitleImobiliario delete
   */
  export type CreditTitleImobiliarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleImobiliario to delete.
     */
    where: CreditTitleImobiliarioWhereUniqueInput
  }

  /**
   * CreditTitleImobiliario deleteMany
   */
  export type CreditTitleImobiliarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleImobiliarios to delete
     */
    where?: CreditTitleImobiliarioWhereInput
    /**
     * Limit how many CreditTitleImobiliarios to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleImobiliario without action
   */
  export type CreditTitleImobiliarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleImobiliario
     */
    select?: CreditTitleImobiliarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleImobiliario
     */
    omit?: CreditTitleImobiliarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleImobiliarioInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleAmbiental
   */

  export type AggregateCreditTitleAmbiental = {
    _count: CreditTitleAmbientalCountAggregateOutputType | null
    _avg: CreditTitleAmbientalAvgAggregateOutputType | null
    _sum: CreditTitleAmbientalSumAggregateOutputType | null
    _min: CreditTitleAmbientalMinAggregateOutputType | null
    _max: CreditTitleAmbientalMaxAggregateOutputType | null
  }

  export type CreditTitleAmbientalAvgAggregateOutputType = {
    toneladasCO2Equivalente: number | null
    hectaresConservados: number | null
    volumeAguaEconomizadoM3: number | null
  }

  export type CreditTitleAmbientalSumAggregateOutputType = {
    toneladasCO2Equivalente: number | null
    hectaresConservados: number | null
    volumeAguaEconomizadoM3: number | null
  }

  export type CreditTitleAmbientalMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCAmbiental | null
    projetoVinculado: string | null
    metodologiaCertificacao: string | null
    toneladasCO2Equivalente: number | null
    hectaresConservados: number | null
    volumeAguaEconomizadoM3: number | null
  }

  export type CreditTitleAmbientalMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCAmbiental | null
    projetoVinculado: string | null
    metodologiaCertificacao: string | null
    toneladasCO2Equivalente: number | null
    hectaresConservados: number | null
    volumeAguaEconomizadoM3: number | null
  }

  export type CreditTitleAmbientalCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    projetoVinculado: number
    metodologiaCertificacao: number
    toneladasCO2Equivalente: number
    hectaresConservados: number
    volumeAguaEconomizadoM3: number
    _all: number
  }


  export type CreditTitleAmbientalAvgAggregateInputType = {
    toneladasCO2Equivalente?: true
    hectaresConservados?: true
    volumeAguaEconomizadoM3?: true
  }

  export type CreditTitleAmbientalSumAggregateInputType = {
    toneladasCO2Equivalente?: true
    hectaresConservados?: true
    volumeAguaEconomizadoM3?: true
  }

  export type CreditTitleAmbientalMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    projetoVinculado?: true
    metodologiaCertificacao?: true
    toneladasCO2Equivalente?: true
    hectaresConservados?: true
    volumeAguaEconomizadoM3?: true
  }

  export type CreditTitleAmbientalMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    projetoVinculado?: true
    metodologiaCertificacao?: true
    toneladasCO2Equivalente?: true
    hectaresConservados?: true
    volumeAguaEconomizadoM3?: true
  }

  export type CreditTitleAmbientalCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    projetoVinculado?: true
    metodologiaCertificacao?: true
    toneladasCO2Equivalente?: true
    hectaresConservados?: true
    volumeAguaEconomizadoM3?: true
    _all?: true
  }

  export type CreditTitleAmbientalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleAmbiental to aggregate.
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleAmbientals to fetch.
     */
    orderBy?: CreditTitleAmbientalOrderByWithRelationInput | CreditTitleAmbientalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleAmbientalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleAmbientals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleAmbientals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleAmbientals
    **/
    _count?: true | CreditTitleAmbientalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditTitleAmbientalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditTitleAmbientalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleAmbientalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleAmbientalMaxAggregateInputType
  }

  export type GetCreditTitleAmbientalAggregateType<T extends CreditTitleAmbientalAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleAmbiental]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleAmbiental[P]>
      : GetScalarType<T[P], AggregateCreditTitleAmbiental[P]>
  }




  export type CreditTitleAmbientalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleAmbientalWhereInput
    orderBy?: CreditTitleAmbientalOrderByWithAggregationInput | CreditTitleAmbientalOrderByWithAggregationInput[]
    by: CreditTitleAmbientalScalarFieldEnum[] | CreditTitleAmbientalScalarFieldEnum
    having?: CreditTitleAmbientalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleAmbientalCountAggregateInputType | true
    _avg?: CreditTitleAmbientalAvgAggregateInputType
    _sum?: CreditTitleAmbientalSumAggregateInputType
    _min?: CreditTitleAmbientalMinAggregateInputType
    _max?: CreditTitleAmbientalMaxAggregateInputType
  }

  export type CreditTitleAmbientalGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCAmbiental
    projetoVinculado: string | null
    metodologiaCertificacao: string | null
    toneladasCO2Equivalente: number | null
    hectaresConservados: number | null
    volumeAguaEconomizadoM3: number | null
    _count: CreditTitleAmbientalCountAggregateOutputType | null
    _avg: CreditTitleAmbientalAvgAggregateOutputType | null
    _sum: CreditTitleAmbientalSumAggregateOutputType | null
    _min: CreditTitleAmbientalMinAggregateOutputType | null
    _max: CreditTitleAmbientalMaxAggregateOutputType | null
  }

  type GetCreditTitleAmbientalGroupByPayload<T extends CreditTitleAmbientalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleAmbientalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleAmbientalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleAmbientalGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleAmbientalGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleAmbientalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    projetoVinculado?: boolean
    metodologiaCertificacao?: boolean
    toneladasCO2Equivalente?: boolean
    hectaresConservados?: boolean
    volumeAguaEconomizadoM3?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleAmbiental"]>

  export type CreditTitleAmbientalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    projetoVinculado?: boolean
    metodologiaCertificacao?: boolean
    toneladasCO2Equivalente?: boolean
    hectaresConservados?: boolean
    volumeAguaEconomizadoM3?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleAmbiental"]>

  export type CreditTitleAmbientalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    projetoVinculado?: boolean
    metodologiaCertificacao?: boolean
    toneladasCO2Equivalente?: boolean
    hectaresConservados?: boolean
    volumeAguaEconomizadoM3?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleAmbiental"]>

  export type CreditTitleAmbientalSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    projetoVinculado?: boolean
    metodologiaCertificacao?: boolean
    toneladasCO2Equivalente?: boolean
    hectaresConservados?: boolean
    volumeAguaEconomizadoM3?: boolean
  }

  export type CreditTitleAmbientalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "projetoVinculado" | "metodologiaCertificacao" | "toneladasCO2Equivalente" | "hectaresConservados" | "volumeAguaEconomizadoM3", ExtArgs["result"]["creditTitleAmbiental"]>
  export type CreditTitleAmbientalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleAmbientalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleAmbientalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleAmbientalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleAmbiental"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCAmbiental
      projetoVinculado: string | null
      metodologiaCertificacao: string | null
      toneladasCO2Equivalente: number | null
      hectaresConservados: number | null
      volumeAguaEconomizadoM3: number | null
    }, ExtArgs["result"]["creditTitleAmbiental"]>
    composites: {}
  }

  type CreditTitleAmbientalGetPayload<S extends boolean | null | undefined | CreditTitleAmbientalDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleAmbientalPayload, S>

  type CreditTitleAmbientalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleAmbientalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleAmbientalCountAggregateInputType | true
    }

  export interface CreditTitleAmbientalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleAmbiental'], meta: { name: 'CreditTitleAmbiental' } }
    /**
     * Find zero or one CreditTitleAmbiental that matches the filter.
     * @param {CreditTitleAmbientalFindUniqueArgs} args - Arguments to find a CreditTitleAmbiental
     * @example
     * // Get one CreditTitleAmbiental
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleAmbientalFindUniqueArgs>(args: SelectSubset<T, CreditTitleAmbientalFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleAmbiental that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleAmbientalFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleAmbiental
     * @example
     * // Get one CreditTitleAmbiental
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleAmbientalFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleAmbientalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleAmbiental that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalFindFirstArgs} args - Arguments to find a CreditTitleAmbiental
     * @example
     * // Get one CreditTitleAmbiental
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleAmbientalFindFirstArgs>(args?: SelectSubset<T, CreditTitleAmbientalFindFirstArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleAmbiental that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalFindFirstOrThrowArgs} args - Arguments to find a CreditTitleAmbiental
     * @example
     * // Get one CreditTitleAmbiental
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleAmbientalFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleAmbientalFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleAmbientals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleAmbientals
     * const creditTitleAmbientals = await prisma.creditTitleAmbiental.findMany()
     * 
     * // Get first 10 CreditTitleAmbientals
     * const creditTitleAmbientals = await prisma.creditTitleAmbiental.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleAmbientalWithIdOnly = await prisma.creditTitleAmbiental.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleAmbientalFindManyArgs>(args?: SelectSubset<T, CreditTitleAmbientalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleAmbiental.
     * @param {CreditTitleAmbientalCreateArgs} args - Arguments to create a CreditTitleAmbiental.
     * @example
     * // Create one CreditTitleAmbiental
     * const CreditTitleAmbiental = await prisma.creditTitleAmbiental.create({
     *   data: {
     *     // ... data to create a CreditTitleAmbiental
     *   }
     * })
     * 
     */
    create<T extends CreditTitleAmbientalCreateArgs>(args: SelectSubset<T, CreditTitleAmbientalCreateArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleAmbientals.
     * @param {CreditTitleAmbientalCreateManyArgs} args - Arguments to create many CreditTitleAmbientals.
     * @example
     * // Create many CreditTitleAmbientals
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleAmbientalCreateManyArgs>(args?: SelectSubset<T, CreditTitleAmbientalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleAmbientals and returns the data saved in the database.
     * @param {CreditTitleAmbientalCreateManyAndReturnArgs} args - Arguments to create many CreditTitleAmbientals.
     * @example
     * // Create many CreditTitleAmbientals
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleAmbientals and only return the `id`
     * const creditTitleAmbientalWithIdOnly = await prisma.creditTitleAmbiental.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleAmbientalCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleAmbientalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleAmbiental.
     * @param {CreditTitleAmbientalDeleteArgs} args - Arguments to delete one CreditTitleAmbiental.
     * @example
     * // Delete one CreditTitleAmbiental
     * const CreditTitleAmbiental = await prisma.creditTitleAmbiental.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleAmbiental
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleAmbientalDeleteArgs>(args: SelectSubset<T, CreditTitleAmbientalDeleteArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleAmbiental.
     * @param {CreditTitleAmbientalUpdateArgs} args - Arguments to update one CreditTitleAmbiental.
     * @example
     * // Update one CreditTitleAmbiental
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleAmbientalUpdateArgs>(args: SelectSubset<T, CreditTitleAmbientalUpdateArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleAmbientals.
     * @param {CreditTitleAmbientalDeleteManyArgs} args - Arguments to filter CreditTitleAmbientals to delete.
     * @example
     * // Delete a few CreditTitleAmbientals
     * const { count } = await prisma.creditTitleAmbiental.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleAmbientalDeleteManyArgs>(args?: SelectSubset<T, CreditTitleAmbientalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleAmbientals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleAmbientals
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleAmbientalUpdateManyArgs>(args: SelectSubset<T, CreditTitleAmbientalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleAmbientals and returns the data updated in the database.
     * @param {CreditTitleAmbientalUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleAmbientals.
     * @example
     * // Update many CreditTitleAmbientals
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleAmbientals and only return the `id`
     * const creditTitleAmbientalWithIdOnly = await prisma.creditTitleAmbiental.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleAmbientalUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleAmbientalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleAmbiental.
     * @param {CreditTitleAmbientalUpsertArgs} args - Arguments to update or create a CreditTitleAmbiental.
     * @example
     * // Update or create a CreditTitleAmbiental
     * const creditTitleAmbiental = await prisma.creditTitleAmbiental.upsert({
     *   create: {
     *     // ... data to create a CreditTitleAmbiental
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleAmbiental we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleAmbientalUpsertArgs>(args: SelectSubset<T, CreditTitleAmbientalUpsertArgs<ExtArgs>>): Prisma__CreditTitleAmbientalClient<$Result.GetResult<Prisma.$CreditTitleAmbientalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleAmbientals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalCountArgs} args - Arguments to filter CreditTitleAmbientals to count.
     * @example
     * // Count the number of CreditTitleAmbientals
     * const count = await prisma.creditTitleAmbiental.count({
     *   where: {
     *     // ... the filter for the CreditTitleAmbientals we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleAmbientalCountArgs>(
      args?: Subset<T, CreditTitleAmbientalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleAmbientalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleAmbiental.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleAmbientalAggregateArgs>(args: Subset<T, CreditTitleAmbientalAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleAmbientalAggregateType<T>>

    /**
     * Group by CreditTitleAmbiental.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleAmbientalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleAmbientalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleAmbientalGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleAmbientalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleAmbientalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleAmbientalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleAmbiental model
   */
  readonly fields: CreditTitleAmbientalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleAmbiental.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleAmbientalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleAmbiental model
   */
  interface CreditTitleAmbientalFieldRefs {
    readonly id: FieldRef<"CreditTitleAmbiental", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleAmbiental", 'String'>
    readonly subType: FieldRef<"CreditTitleAmbiental", 'TCAmbiental'>
    readonly projetoVinculado: FieldRef<"CreditTitleAmbiental", 'String'>
    readonly metodologiaCertificacao: FieldRef<"CreditTitleAmbiental", 'String'>
    readonly toneladasCO2Equivalente: FieldRef<"CreditTitleAmbiental", 'Float'>
    readonly hectaresConservados: FieldRef<"CreditTitleAmbiental", 'Float'>
    readonly volumeAguaEconomizadoM3: FieldRef<"CreditTitleAmbiental", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleAmbiental findUnique
   */
  export type CreditTitleAmbientalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleAmbiental to fetch.
     */
    where: CreditTitleAmbientalWhereUniqueInput
  }

  /**
   * CreditTitleAmbiental findUniqueOrThrow
   */
  export type CreditTitleAmbientalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleAmbiental to fetch.
     */
    where: CreditTitleAmbientalWhereUniqueInput
  }

  /**
   * CreditTitleAmbiental findFirst
   */
  export type CreditTitleAmbientalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleAmbiental to fetch.
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleAmbientals to fetch.
     */
    orderBy?: CreditTitleAmbientalOrderByWithRelationInput | CreditTitleAmbientalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleAmbientals.
     */
    cursor?: CreditTitleAmbientalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleAmbientals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleAmbientals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleAmbientals.
     */
    distinct?: CreditTitleAmbientalScalarFieldEnum | CreditTitleAmbientalScalarFieldEnum[]
  }

  /**
   * CreditTitleAmbiental findFirstOrThrow
   */
  export type CreditTitleAmbientalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleAmbiental to fetch.
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleAmbientals to fetch.
     */
    orderBy?: CreditTitleAmbientalOrderByWithRelationInput | CreditTitleAmbientalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleAmbientals.
     */
    cursor?: CreditTitleAmbientalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleAmbientals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleAmbientals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleAmbientals.
     */
    distinct?: CreditTitleAmbientalScalarFieldEnum | CreditTitleAmbientalScalarFieldEnum[]
  }

  /**
   * CreditTitleAmbiental findMany
   */
  export type CreditTitleAmbientalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleAmbientals to fetch.
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleAmbientals to fetch.
     */
    orderBy?: CreditTitleAmbientalOrderByWithRelationInput | CreditTitleAmbientalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleAmbientals.
     */
    cursor?: CreditTitleAmbientalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleAmbientals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleAmbientals.
     */
    skip?: number
    distinct?: CreditTitleAmbientalScalarFieldEnum | CreditTitleAmbientalScalarFieldEnum[]
  }

  /**
   * CreditTitleAmbiental create
   */
  export type CreditTitleAmbientalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleAmbiental.
     */
    data: XOR<CreditTitleAmbientalCreateInput, CreditTitleAmbientalUncheckedCreateInput>
  }

  /**
   * CreditTitleAmbiental createMany
   */
  export type CreditTitleAmbientalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleAmbientals.
     */
    data: CreditTitleAmbientalCreateManyInput | CreditTitleAmbientalCreateManyInput[]
  }

  /**
   * CreditTitleAmbiental createManyAndReturn
   */
  export type CreditTitleAmbientalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleAmbientals.
     */
    data: CreditTitleAmbientalCreateManyInput | CreditTitleAmbientalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleAmbiental update
   */
  export type CreditTitleAmbientalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleAmbiental.
     */
    data: XOR<CreditTitleAmbientalUpdateInput, CreditTitleAmbientalUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleAmbiental to update.
     */
    where: CreditTitleAmbientalWhereUniqueInput
  }

  /**
   * CreditTitleAmbiental updateMany
   */
  export type CreditTitleAmbientalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleAmbientals.
     */
    data: XOR<CreditTitleAmbientalUpdateManyMutationInput, CreditTitleAmbientalUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleAmbientals to update
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * Limit how many CreditTitleAmbientals to update.
     */
    limit?: number
  }

  /**
   * CreditTitleAmbiental updateManyAndReturn
   */
  export type CreditTitleAmbientalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleAmbientals.
     */
    data: XOR<CreditTitleAmbientalUpdateManyMutationInput, CreditTitleAmbientalUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleAmbientals to update
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * Limit how many CreditTitleAmbientals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleAmbiental upsert
   */
  export type CreditTitleAmbientalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleAmbiental to update in case it exists.
     */
    where: CreditTitleAmbientalWhereUniqueInput
    /**
     * In case the CreditTitleAmbiental found by the `where` argument doesn't exist, create a new CreditTitleAmbiental with this data.
     */
    create: XOR<CreditTitleAmbientalCreateInput, CreditTitleAmbientalUncheckedCreateInput>
    /**
     * In case the CreditTitleAmbiental was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleAmbientalUpdateInput, CreditTitleAmbientalUncheckedUpdateInput>
  }

  /**
   * CreditTitleAmbiental delete
   */
  export type CreditTitleAmbientalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleAmbiental to delete.
     */
    where: CreditTitleAmbientalWhereUniqueInput
  }

  /**
   * CreditTitleAmbiental deleteMany
   */
  export type CreditTitleAmbientalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleAmbientals to delete
     */
    where?: CreditTitleAmbientalWhereInput
    /**
     * Limit how many CreditTitleAmbientals to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleAmbiental without action
   */
  export type CreditTitleAmbientalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleAmbiental
     */
    select?: CreditTitleAmbientalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleAmbiental
     */
    omit?: CreditTitleAmbientalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleAmbientalInclude<ExtArgs> | null
  }


  /**
   * Model CreditTitleEspecial
   */

  export type AggregateCreditTitleEspecial = {
    _count: CreditTitleEspecialCountAggregateOutputType | null
    _min: CreditTitleEspecialMinAggregateOutputType | null
    _max: CreditTitleEspecialMaxAggregateOutputType | null
  }

  export type CreditTitleEspecialMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCEspecial | null
    processoRecuperacaoJudicial: string | null
    credorOriginal: string | null
    classeCreditoRJ: string | null
    administradoraConsorcio: string | null
    grupoConsorcio: string | null
    cotaConsorcio: string | null
  }

  export type CreditTitleEspecialMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    subType: $Enums.TCEspecial | null
    processoRecuperacaoJudicial: string | null
    credorOriginal: string | null
    classeCreditoRJ: string | null
    administradoraConsorcio: string | null
    grupoConsorcio: string | null
    cotaConsorcio: string | null
  }

  export type CreditTitleEspecialCountAggregateOutputType = {
    id: number
    creditTitleId: number
    subType: number
    processoRecuperacaoJudicial: number
    credorOriginal: number
    classeCreditoRJ: number
    administradoraConsorcio: number
    grupoConsorcio: number
    cotaConsorcio: number
    _all: number
  }


  export type CreditTitleEspecialMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    processoRecuperacaoJudicial?: true
    credorOriginal?: true
    classeCreditoRJ?: true
    administradoraConsorcio?: true
    grupoConsorcio?: true
    cotaConsorcio?: true
  }

  export type CreditTitleEspecialMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    processoRecuperacaoJudicial?: true
    credorOriginal?: true
    classeCreditoRJ?: true
    administradoraConsorcio?: true
    grupoConsorcio?: true
    cotaConsorcio?: true
  }

  export type CreditTitleEspecialCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    subType?: true
    processoRecuperacaoJudicial?: true
    credorOriginal?: true
    classeCreditoRJ?: true
    administradoraConsorcio?: true
    grupoConsorcio?: true
    cotaConsorcio?: true
    _all?: true
  }

  export type CreditTitleEspecialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleEspecial to aggregate.
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleEspecials to fetch.
     */
    orderBy?: CreditTitleEspecialOrderByWithRelationInput | CreditTitleEspecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTitleEspecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleEspecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleEspecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTitleEspecials
    **/
    _count?: true | CreditTitleEspecialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTitleEspecialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTitleEspecialMaxAggregateInputType
  }

  export type GetCreditTitleEspecialAggregateType<T extends CreditTitleEspecialAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTitleEspecial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTitleEspecial[P]>
      : GetScalarType<T[P], AggregateCreditTitleEspecial[P]>
  }




  export type CreditTitleEspecialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTitleEspecialWhereInput
    orderBy?: CreditTitleEspecialOrderByWithAggregationInput | CreditTitleEspecialOrderByWithAggregationInput[]
    by: CreditTitleEspecialScalarFieldEnum[] | CreditTitleEspecialScalarFieldEnum
    having?: CreditTitleEspecialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTitleEspecialCountAggregateInputType | true
    _min?: CreditTitleEspecialMinAggregateInputType
    _max?: CreditTitleEspecialMaxAggregateInputType
  }

  export type CreditTitleEspecialGroupByOutputType = {
    id: string
    creditTitleId: string
    subType: $Enums.TCEspecial
    processoRecuperacaoJudicial: string | null
    credorOriginal: string | null
    classeCreditoRJ: string | null
    administradoraConsorcio: string | null
    grupoConsorcio: string | null
    cotaConsorcio: string | null
    _count: CreditTitleEspecialCountAggregateOutputType | null
    _min: CreditTitleEspecialMinAggregateOutputType | null
    _max: CreditTitleEspecialMaxAggregateOutputType | null
  }

  type GetCreditTitleEspecialGroupByPayload<T extends CreditTitleEspecialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTitleEspecialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTitleEspecialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTitleEspecialGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTitleEspecialGroupByOutputType[P]>
        }
      >
    >


  export type CreditTitleEspecialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    processoRecuperacaoJudicial?: boolean
    credorOriginal?: boolean
    classeCreditoRJ?: boolean
    administradoraConsorcio?: boolean
    grupoConsorcio?: boolean
    cotaConsorcio?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleEspecial"]>

  export type CreditTitleEspecialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    processoRecuperacaoJudicial?: boolean
    credorOriginal?: boolean
    classeCreditoRJ?: boolean
    administradoraConsorcio?: boolean
    grupoConsorcio?: boolean
    cotaConsorcio?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleEspecial"]>

  export type CreditTitleEspecialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    processoRecuperacaoJudicial?: boolean
    credorOriginal?: boolean
    classeCreditoRJ?: boolean
    administradoraConsorcio?: boolean
    grupoConsorcio?: boolean
    cotaConsorcio?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTitleEspecial"]>

  export type CreditTitleEspecialSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    subType?: boolean
    processoRecuperacaoJudicial?: boolean
    credorOriginal?: boolean
    classeCreditoRJ?: boolean
    administradoraConsorcio?: boolean
    grupoConsorcio?: boolean
    cotaConsorcio?: boolean
  }

  export type CreditTitleEspecialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "subType" | "processoRecuperacaoJudicial" | "credorOriginal" | "classeCreditoRJ" | "administradoraConsorcio" | "grupoConsorcio" | "cotaConsorcio", ExtArgs["result"]["creditTitleEspecial"]>
  export type CreditTitleEspecialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleEspecialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }
  export type CreditTitleEspecialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
  }

  export type $CreditTitleEspecialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTitleEspecial"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      subType: $Enums.TCEspecial
      processoRecuperacaoJudicial: string | null
      credorOriginal: string | null
      classeCreditoRJ: string | null
      administradoraConsorcio: string | null
      grupoConsorcio: string | null
      cotaConsorcio: string | null
    }, ExtArgs["result"]["creditTitleEspecial"]>
    composites: {}
  }

  type CreditTitleEspecialGetPayload<S extends boolean | null | undefined | CreditTitleEspecialDefaultArgs> = $Result.GetResult<Prisma.$CreditTitleEspecialPayload, S>

  type CreditTitleEspecialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTitleEspecialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTitleEspecialCountAggregateInputType | true
    }

  export interface CreditTitleEspecialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTitleEspecial'], meta: { name: 'CreditTitleEspecial' } }
    /**
     * Find zero or one CreditTitleEspecial that matches the filter.
     * @param {CreditTitleEspecialFindUniqueArgs} args - Arguments to find a CreditTitleEspecial
     * @example
     * // Get one CreditTitleEspecial
     * const creditTitleEspecial = await prisma.creditTitleEspecial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTitleEspecialFindUniqueArgs>(args: SelectSubset<T, CreditTitleEspecialFindUniqueArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTitleEspecial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTitleEspecialFindUniqueOrThrowArgs} args - Arguments to find a CreditTitleEspecial
     * @example
     * // Get one CreditTitleEspecial
     * const creditTitleEspecial = await prisma.creditTitleEspecial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTitleEspecialFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTitleEspecialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleEspecial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialFindFirstArgs} args - Arguments to find a CreditTitleEspecial
     * @example
     * // Get one CreditTitleEspecial
     * const creditTitleEspecial = await prisma.creditTitleEspecial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTitleEspecialFindFirstArgs>(args?: SelectSubset<T, CreditTitleEspecialFindFirstArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTitleEspecial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialFindFirstOrThrowArgs} args - Arguments to find a CreditTitleEspecial
     * @example
     * // Get one CreditTitleEspecial
     * const creditTitleEspecial = await prisma.creditTitleEspecial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTitleEspecialFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTitleEspecialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTitleEspecials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTitleEspecials
     * const creditTitleEspecials = await prisma.creditTitleEspecial.findMany()
     * 
     * // Get first 10 CreditTitleEspecials
     * const creditTitleEspecials = await prisma.creditTitleEspecial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTitleEspecialWithIdOnly = await prisma.creditTitleEspecial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTitleEspecialFindManyArgs>(args?: SelectSubset<T, CreditTitleEspecialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTitleEspecial.
     * @param {CreditTitleEspecialCreateArgs} args - Arguments to create a CreditTitleEspecial.
     * @example
     * // Create one CreditTitleEspecial
     * const CreditTitleEspecial = await prisma.creditTitleEspecial.create({
     *   data: {
     *     // ... data to create a CreditTitleEspecial
     *   }
     * })
     * 
     */
    create<T extends CreditTitleEspecialCreateArgs>(args: SelectSubset<T, CreditTitleEspecialCreateArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTitleEspecials.
     * @param {CreditTitleEspecialCreateManyArgs} args - Arguments to create many CreditTitleEspecials.
     * @example
     * // Create many CreditTitleEspecials
     * const creditTitleEspecial = await prisma.creditTitleEspecial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTitleEspecialCreateManyArgs>(args?: SelectSubset<T, CreditTitleEspecialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTitleEspecials and returns the data saved in the database.
     * @param {CreditTitleEspecialCreateManyAndReturnArgs} args - Arguments to create many CreditTitleEspecials.
     * @example
     * // Create many CreditTitleEspecials
     * const creditTitleEspecial = await prisma.creditTitleEspecial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTitleEspecials and only return the `id`
     * const creditTitleEspecialWithIdOnly = await prisma.creditTitleEspecial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTitleEspecialCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTitleEspecialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTitleEspecial.
     * @param {CreditTitleEspecialDeleteArgs} args - Arguments to delete one CreditTitleEspecial.
     * @example
     * // Delete one CreditTitleEspecial
     * const CreditTitleEspecial = await prisma.creditTitleEspecial.delete({
     *   where: {
     *     // ... filter to delete one CreditTitleEspecial
     *   }
     * })
     * 
     */
    delete<T extends CreditTitleEspecialDeleteArgs>(args: SelectSubset<T, CreditTitleEspecialDeleteArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTitleEspecial.
     * @param {CreditTitleEspecialUpdateArgs} args - Arguments to update one CreditTitleEspecial.
     * @example
     * // Update one CreditTitleEspecial
     * const creditTitleEspecial = await prisma.creditTitleEspecial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTitleEspecialUpdateArgs>(args: SelectSubset<T, CreditTitleEspecialUpdateArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTitleEspecials.
     * @param {CreditTitleEspecialDeleteManyArgs} args - Arguments to filter CreditTitleEspecials to delete.
     * @example
     * // Delete a few CreditTitleEspecials
     * const { count } = await prisma.creditTitleEspecial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTitleEspecialDeleteManyArgs>(args?: SelectSubset<T, CreditTitleEspecialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleEspecials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTitleEspecials
     * const creditTitleEspecial = await prisma.creditTitleEspecial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTitleEspecialUpdateManyArgs>(args: SelectSubset<T, CreditTitleEspecialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTitleEspecials and returns the data updated in the database.
     * @param {CreditTitleEspecialUpdateManyAndReturnArgs} args - Arguments to update many CreditTitleEspecials.
     * @example
     * // Update many CreditTitleEspecials
     * const creditTitleEspecial = await prisma.creditTitleEspecial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTitleEspecials and only return the `id`
     * const creditTitleEspecialWithIdOnly = await prisma.creditTitleEspecial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTitleEspecialUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTitleEspecialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTitleEspecial.
     * @param {CreditTitleEspecialUpsertArgs} args - Arguments to update or create a CreditTitleEspecial.
     * @example
     * // Update or create a CreditTitleEspecial
     * const creditTitleEspecial = await prisma.creditTitleEspecial.upsert({
     *   create: {
     *     // ... data to create a CreditTitleEspecial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTitleEspecial we want to update
     *   }
     * })
     */
    upsert<T extends CreditTitleEspecialUpsertArgs>(args: SelectSubset<T, CreditTitleEspecialUpsertArgs<ExtArgs>>): Prisma__CreditTitleEspecialClient<$Result.GetResult<Prisma.$CreditTitleEspecialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTitleEspecials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialCountArgs} args - Arguments to filter CreditTitleEspecials to count.
     * @example
     * // Count the number of CreditTitleEspecials
     * const count = await prisma.creditTitleEspecial.count({
     *   where: {
     *     // ... the filter for the CreditTitleEspecials we want to count
     *   }
     * })
    **/
    count<T extends CreditTitleEspecialCountArgs>(
      args?: Subset<T, CreditTitleEspecialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTitleEspecialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTitleEspecial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTitleEspecialAggregateArgs>(args: Subset<T, CreditTitleEspecialAggregateArgs>): Prisma.PrismaPromise<GetCreditTitleEspecialAggregateType<T>>

    /**
     * Group by CreditTitleEspecial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTitleEspecialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTitleEspecialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTitleEspecialGroupByArgs['orderBy'] }
        : { orderBy?: CreditTitleEspecialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTitleEspecialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTitleEspecialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTitleEspecial model
   */
  readonly fields: CreditTitleEspecialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTitleEspecial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTitleEspecialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTitleEspecial model
   */
  interface CreditTitleEspecialFieldRefs {
    readonly id: FieldRef<"CreditTitleEspecial", 'String'>
    readonly creditTitleId: FieldRef<"CreditTitleEspecial", 'String'>
    readonly subType: FieldRef<"CreditTitleEspecial", 'TCEspecial'>
    readonly processoRecuperacaoJudicial: FieldRef<"CreditTitleEspecial", 'String'>
    readonly credorOriginal: FieldRef<"CreditTitleEspecial", 'String'>
    readonly classeCreditoRJ: FieldRef<"CreditTitleEspecial", 'String'>
    readonly administradoraConsorcio: FieldRef<"CreditTitleEspecial", 'String'>
    readonly grupoConsorcio: FieldRef<"CreditTitleEspecial", 'String'>
    readonly cotaConsorcio: FieldRef<"CreditTitleEspecial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditTitleEspecial findUnique
   */
  export type CreditTitleEspecialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleEspecial to fetch.
     */
    where: CreditTitleEspecialWhereUniqueInput
  }

  /**
   * CreditTitleEspecial findUniqueOrThrow
   */
  export type CreditTitleEspecialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleEspecial to fetch.
     */
    where: CreditTitleEspecialWhereUniqueInput
  }

  /**
   * CreditTitleEspecial findFirst
   */
  export type CreditTitleEspecialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleEspecial to fetch.
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleEspecials to fetch.
     */
    orderBy?: CreditTitleEspecialOrderByWithRelationInput | CreditTitleEspecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleEspecials.
     */
    cursor?: CreditTitleEspecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleEspecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleEspecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleEspecials.
     */
    distinct?: CreditTitleEspecialScalarFieldEnum | CreditTitleEspecialScalarFieldEnum[]
  }

  /**
   * CreditTitleEspecial findFirstOrThrow
   */
  export type CreditTitleEspecialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleEspecial to fetch.
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleEspecials to fetch.
     */
    orderBy?: CreditTitleEspecialOrderByWithRelationInput | CreditTitleEspecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTitleEspecials.
     */
    cursor?: CreditTitleEspecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleEspecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleEspecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTitleEspecials.
     */
    distinct?: CreditTitleEspecialScalarFieldEnum | CreditTitleEspecialScalarFieldEnum[]
  }

  /**
   * CreditTitleEspecial findMany
   */
  export type CreditTitleEspecialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * Filter, which CreditTitleEspecials to fetch.
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTitleEspecials to fetch.
     */
    orderBy?: CreditTitleEspecialOrderByWithRelationInput | CreditTitleEspecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTitleEspecials.
     */
    cursor?: CreditTitleEspecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTitleEspecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTitleEspecials.
     */
    skip?: number
    distinct?: CreditTitleEspecialScalarFieldEnum | CreditTitleEspecialScalarFieldEnum[]
  }

  /**
   * CreditTitleEspecial create
   */
  export type CreditTitleEspecialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTitleEspecial.
     */
    data: XOR<CreditTitleEspecialCreateInput, CreditTitleEspecialUncheckedCreateInput>
  }

  /**
   * CreditTitleEspecial createMany
   */
  export type CreditTitleEspecialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTitleEspecials.
     */
    data: CreditTitleEspecialCreateManyInput | CreditTitleEspecialCreateManyInput[]
  }

  /**
   * CreditTitleEspecial createManyAndReturn
   */
  export type CreditTitleEspecialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTitleEspecials.
     */
    data: CreditTitleEspecialCreateManyInput | CreditTitleEspecialCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleEspecial update
   */
  export type CreditTitleEspecialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTitleEspecial.
     */
    data: XOR<CreditTitleEspecialUpdateInput, CreditTitleEspecialUncheckedUpdateInput>
    /**
     * Choose, which CreditTitleEspecial to update.
     */
    where: CreditTitleEspecialWhereUniqueInput
  }

  /**
   * CreditTitleEspecial updateMany
   */
  export type CreditTitleEspecialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTitleEspecials.
     */
    data: XOR<CreditTitleEspecialUpdateManyMutationInput, CreditTitleEspecialUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleEspecials to update
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * Limit how many CreditTitleEspecials to update.
     */
    limit?: number
  }

  /**
   * CreditTitleEspecial updateManyAndReturn
   */
  export type CreditTitleEspecialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * The data used to update CreditTitleEspecials.
     */
    data: XOR<CreditTitleEspecialUpdateManyMutationInput, CreditTitleEspecialUncheckedUpdateManyInput>
    /**
     * Filter which CreditTitleEspecials to update
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * Limit how many CreditTitleEspecials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTitleEspecial upsert
   */
  export type CreditTitleEspecialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTitleEspecial to update in case it exists.
     */
    where: CreditTitleEspecialWhereUniqueInput
    /**
     * In case the CreditTitleEspecial found by the `where` argument doesn't exist, create a new CreditTitleEspecial with this data.
     */
    create: XOR<CreditTitleEspecialCreateInput, CreditTitleEspecialUncheckedCreateInput>
    /**
     * In case the CreditTitleEspecial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTitleEspecialUpdateInput, CreditTitleEspecialUncheckedUpdateInput>
  }

  /**
   * CreditTitleEspecial delete
   */
  export type CreditTitleEspecialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
    /**
     * Filter which CreditTitleEspecial to delete.
     */
    where: CreditTitleEspecialWhereUniqueInput
  }

  /**
   * CreditTitleEspecial deleteMany
   */
  export type CreditTitleEspecialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTitleEspecials to delete
     */
    where?: CreditTitleEspecialWhereInput
    /**
     * Limit how many CreditTitleEspecials to delete.
     */
    limit?: number
  }

  /**
   * CreditTitleEspecial without action
   */
  export type CreditTitleEspecialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTitleEspecial
     */
    select?: CreditTitleEspecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTitleEspecial
     */
    omit?: CreditTitleEspecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTitleEspecialInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    isPublic: boolean | null
    mimeType: string | null
    size: number | null
    storageLocation: string | null
    hash: string | null
    creditTitleId: string | null
    uploadedById: string | null
    uploadedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    isPublic: boolean | null
    mimeType: string | null
    size: number | null
    storageLocation: string | null
    hash: string | null
    creditTitleId: string | null
    uploadedById: string | null
    uploadedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    isPublic: number
    mimeType: number
    size: number
    storageLocation: number
    hash: number
    creditTitleId: number
    uploadedById: number
    uploadedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isPublic?: true
    mimeType?: true
    size?: true
    storageLocation?: true
    hash?: true
    creditTitleId?: true
    uploadedById?: true
    uploadedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isPublic?: true
    mimeType?: true
    size?: true
    storageLocation?: true
    hash?: true
    creditTitleId?: true
    uploadedById?: true
    uploadedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isPublic?: true
    mimeType?: true
    size?: true
    storageLocation?: true
    hash?: true
    creditTitleId?: true
    uploadedById?: true
    uploadedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string | null
    isPublic: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash: string | null
    creditTitleId: string
    uploadedById: string
    uploadedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isPublic?: boolean
    mimeType?: boolean
    size?: boolean
    storageLocation?: boolean
    hash?: boolean
    creditTitleId?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isPublic?: boolean
    mimeType?: boolean
    size?: boolean
    storageLocation?: boolean
    hash?: boolean
    creditTitleId?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isPublic?: boolean
    mimeType?: boolean
    size?: boolean
    storageLocation?: boolean
    hash?: boolean
    creditTitleId?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isPublic?: boolean
    mimeType?: boolean
    size?: boolean
    storageLocation?: boolean
    hash?: boolean
    creditTitleId?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "isPublic" | "mimeType" | "size" | "storageLocation" | "hash" | "creditTitleId" | "uploadedById" | "uploadedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      description: string | null
      isPublic: boolean
      mimeType: string
      size: number
      storageLocation: string
      hash: string | null
      creditTitleId: string
      uploadedById: string
      uploadedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly isPublic: FieldRef<"Document", 'Boolean'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly storageLocation: FieldRef<"Document", 'String'>
    readonly hash: FieldRef<"Document", 'String'>
    readonly creditTitleId: FieldRef<"Document", 'String'>
    readonly uploadedById: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    price: number | null
    quantityAvailable: number | null
    minBidIncrement: number | null
    reservePrice: number | null
  }

  export type OfferSumAggregateOutputType = {
    price: number | null
    quantityAvailable: number | null
    minBidIncrement: number | null
    reservePrice: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    sellerId: string | null
    price: number | null
    expiryDate: Date | null
    terms: string | null
    quantityAvailable: number | null
    offerType: $Enums.OfferType | null
    minBidIncrement: number | null
    reservePrice: number | null
    allowPartialPurchase: boolean | null
    status: $Enums.OfferStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    sellerId: string | null
    price: number | null
    expiryDate: Date | null
    terms: string | null
    quantityAvailable: number | null
    offerType: $Enums.OfferType | null
    minBidIncrement: number | null
    reservePrice: number | null
    allowPartialPurchase: boolean | null
    status: $Enums.OfferStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    creditTitleId: number
    sellerId: number
    price: number
    expiryDate: number
    terms: number
    quantityAvailable: number
    offerType: number
    minBidIncrement: number
    reservePrice: number
    allowPartialPurchase: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    price?: true
    quantityAvailable?: true
    minBidIncrement?: true
    reservePrice?: true
  }

  export type OfferSumAggregateInputType = {
    price?: true
    quantityAvailable?: true
    minBidIncrement?: true
    reservePrice?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    sellerId?: true
    price?: true
    expiryDate?: true
    terms?: true
    quantityAvailable?: true
    offerType?: true
    minBidIncrement?: true
    reservePrice?: true
    allowPartialPurchase?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    sellerId?: true
    price?: true
    expiryDate?: true
    terms?: true
    quantityAvailable?: true
    offerType?: true
    minBidIncrement?: true
    reservePrice?: true
    allowPartialPurchase?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    sellerId?: true
    price?: true
    expiryDate?: true
    terms?: true
    quantityAvailable?: true
    offerType?: true
    minBidIncrement?: true
    reservePrice?: true
    allowPartialPurchase?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    creditTitleId: string
    sellerId: string
    price: number
    expiryDate: Date | null
    terms: string | null
    quantityAvailable: number
    offerType: $Enums.OfferType
    minBidIncrement: number | null
    reservePrice: number | null
    allowPartialPurchase: boolean
    status: $Enums.OfferStatus
    createdAt: Date
    updatedAt: Date
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    price?: boolean
    expiryDate?: boolean
    terms?: boolean
    quantityAvailable?: boolean
    offerType?: boolean
    minBidIncrement?: boolean
    reservePrice?: boolean
    allowPartialPurchase?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    bids?: boolean | Offer$bidsArgs<ExtArgs>
    transactions?: boolean | Offer$transactionsArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    price?: boolean
    expiryDate?: boolean
    terms?: boolean
    quantityAvailable?: boolean
    offerType?: boolean
    minBidIncrement?: boolean
    reservePrice?: boolean
    allowPartialPurchase?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    price?: boolean
    expiryDate?: boolean
    terms?: boolean
    quantityAvailable?: boolean
    offerType?: boolean
    minBidIncrement?: boolean
    reservePrice?: boolean
    allowPartialPurchase?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    price?: boolean
    expiryDate?: boolean
    terms?: boolean
    quantityAvailable?: boolean
    offerType?: boolean
    minBidIncrement?: boolean
    reservePrice?: boolean
    allowPartialPurchase?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "sellerId" | "price" | "expiryDate" | "terms" | "quantityAvailable" | "offerType" | "minBidIncrement" | "reservePrice" | "allowPartialPurchase" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["offer"]>
  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    bids?: boolean | Offer$bidsArgs<ExtArgs>
    transactions?: boolean | Offer$transactionsArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
      bids: Prisma.$BidPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      sellerId: string
      price: number
      expiryDate: Date | null
      terms: string | null
      quantityAvailable: number
      offerType: $Enums.OfferType
      minBidIncrement: number | null
      reservePrice: number | null
      allowPartialPurchase: boolean
      status: $Enums.OfferStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers and returns the data updated in the database.
     * @param {OfferUpdateManyAndReturnArgs} args - Arguments to update many Offers.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bids<T extends Offer$bidsArgs<ExtArgs> = {}>(args?: Subset<T, Offer$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Offer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Offer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly creditTitleId: FieldRef<"Offer", 'String'>
    readonly sellerId: FieldRef<"Offer", 'String'>
    readonly price: FieldRef<"Offer", 'Float'>
    readonly expiryDate: FieldRef<"Offer", 'DateTime'>
    readonly terms: FieldRef<"Offer", 'String'>
    readonly quantityAvailable: FieldRef<"Offer", 'Int'>
    readonly offerType: FieldRef<"Offer", 'OfferType'>
    readonly minBidIncrement: FieldRef<"Offer", 'Float'>
    readonly reservePrice: FieldRef<"Offer", 'Float'>
    readonly allowPartialPurchase: FieldRef<"Offer", 'Boolean'>
    readonly status: FieldRef<"Offer", 'OfferStatus'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
  }

  /**
   * Offer updateManyAndReturn
   */
  export type OfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to delete.
     */
    limit?: number
  }

  /**
   * Offer.bids
   */
  export type Offer$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Offer.transactions
   */
  export type Offer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model Bid
   */

  export type AggregateBid = {
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  export type BidAvgAggregateOutputType = {
    amount: number | null
    quantity: number | null
  }

  export type BidSumAggregateOutputType = {
    amount: number | null
    quantity: number | null
  }

  export type BidMinAggregateOutputType = {
    id: string | null
    offerId: string | null
    bidderId: string | null
    amount: number | null
    quantity: number | null
    notes: string | null
    status: $Enums.BidStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidMaxAggregateOutputType = {
    id: string | null
    offerId: string | null
    bidderId: string | null
    amount: number | null
    quantity: number | null
    notes: string | null
    status: $Enums.BidStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidCountAggregateOutputType = {
    id: number
    offerId: number
    bidderId: number
    amount: number
    quantity: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BidAvgAggregateInputType = {
    amount?: true
    quantity?: true
  }

  export type BidSumAggregateInputType = {
    amount?: true
    quantity?: true
  }

  export type BidMinAggregateInputType = {
    id?: true
    offerId?: true
    bidderId?: true
    amount?: true
    quantity?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidMaxAggregateInputType = {
    id?: true
    offerId?: true
    bidderId?: true
    amount?: true
    quantity?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidCountAggregateInputType = {
    id?: true
    offerId?: true
    bidderId?: true
    amount?: true
    quantity?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bid to aggregate.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bids
    **/
    _count?: true | BidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidMaxAggregateInputType
  }

  export type GetBidAggregateType<T extends BidAggregateArgs> = {
        [P in keyof T & keyof AggregateBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBid[P]>
      : GetScalarType<T[P], AggregateBid[P]>
  }




  export type BidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
    orderBy?: BidOrderByWithAggregationInput | BidOrderByWithAggregationInput[]
    by: BidScalarFieldEnum[] | BidScalarFieldEnum
    having?: BidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidCountAggregateInputType | true
    _avg?: BidAvgAggregateInputType
    _sum?: BidSumAggregateInputType
    _min?: BidMinAggregateInputType
    _max?: BidMaxAggregateInputType
  }

  export type BidGroupByOutputType = {
    id: string
    offerId: string
    bidderId: string
    amount: number
    quantity: number
    notes: string | null
    status: $Enums.BidStatus
    createdAt: Date
    updatedAt: Date
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  type GetBidGroupByPayload<T extends BidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidGroupByOutputType[P]>
            : GetScalarType<T[P], BidGroupByOutputType[P]>
        }
      >
    >


  export type BidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    bidderId?: boolean
    amount?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | Bid$transactionsArgs<ExtArgs>
    _count?: boolean | BidCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    bidderId?: boolean
    amount?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    bidderId?: boolean
    amount?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectScalar = {
    id?: boolean
    offerId?: boolean
    bidderId?: boolean
    amount?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offerId" | "bidderId" | "amount" | "quantity" | "notes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["bid"]>
  export type BidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | Bid$transactionsArgs<ExtArgs>
    _count?: boolean | BidCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    bidder?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bid"
    objects: {
      offer: Prisma.$OfferPayload<ExtArgs>
      bidder: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offerId: string
      bidderId: string
      amount: number
      quantity: number
      notes: string | null
      status: $Enums.BidStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bid"]>
    composites: {}
  }

  type BidGetPayload<S extends boolean | null | undefined | BidDefaultArgs> = $Result.GetResult<Prisma.$BidPayload, S>

  type BidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BidCountAggregateInputType | true
    }

  export interface BidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bid'], meta: { name: 'Bid' } }
    /**
     * Find zero or one Bid that matches the filter.
     * @param {BidFindUniqueArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidFindUniqueArgs>(args: SelectSubset<T, BidFindUniqueArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BidFindUniqueOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidFindUniqueOrThrowArgs>(args: SelectSubset<T, BidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidFindFirstArgs>(args?: SelectSubset<T, BidFindFirstArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidFindFirstOrThrowArgs>(args?: SelectSubset<T, BidFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bids
     * const bids = await prisma.bid.findMany()
     * 
     * // Get first 10 Bids
     * const bids = await prisma.bid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidWithIdOnly = await prisma.bid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidFindManyArgs>(args?: SelectSubset<T, BidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bid.
     * @param {BidCreateArgs} args - Arguments to create a Bid.
     * @example
     * // Create one Bid
     * const Bid = await prisma.bid.create({
     *   data: {
     *     // ... data to create a Bid
     *   }
     * })
     * 
     */
    create<T extends BidCreateArgs>(args: SelectSubset<T, BidCreateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bids.
     * @param {BidCreateManyArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidCreateManyArgs>(args?: SelectSubset<T, BidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bids and returns the data saved in the database.
     * @param {BidCreateManyAndReturnArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidCreateManyAndReturnArgs>(args?: SelectSubset<T, BidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bid.
     * @param {BidDeleteArgs} args - Arguments to delete one Bid.
     * @example
     * // Delete one Bid
     * const Bid = await prisma.bid.delete({
     *   where: {
     *     // ... filter to delete one Bid
     *   }
     * })
     * 
     */
    delete<T extends BidDeleteArgs>(args: SelectSubset<T, BidDeleteArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bid.
     * @param {BidUpdateArgs} args - Arguments to update one Bid.
     * @example
     * // Update one Bid
     * const bid = await prisma.bid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidUpdateArgs>(args: SelectSubset<T, BidUpdateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bids.
     * @param {BidDeleteManyArgs} args - Arguments to filter Bids to delete.
     * @example
     * // Delete a few Bids
     * const { count } = await prisma.bid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidDeleteManyArgs>(args?: SelectSubset<T, BidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidUpdateManyArgs>(args: SelectSubset<T, BidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids and returns the data updated in the database.
     * @param {BidUpdateManyAndReturnArgs} args - Arguments to update many Bids.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BidUpdateManyAndReturnArgs>(args: SelectSubset<T, BidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bid.
     * @param {BidUpsertArgs} args - Arguments to update or create a Bid.
     * @example
     * // Update or create a Bid
     * const bid = await prisma.bid.upsert({
     *   create: {
     *     // ... data to create a Bid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bid we want to update
     *   }
     * })
     */
    upsert<T extends BidUpsertArgs>(args: SelectSubset<T, BidUpsertArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidCountArgs} args - Arguments to filter Bids to count.
     * @example
     * // Count the number of Bids
     * const count = await prisma.bid.count({
     *   where: {
     *     // ... the filter for the Bids we want to count
     *   }
     * })
    **/
    count<T extends BidCountArgs>(
      args?: Subset<T, BidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidAggregateArgs>(args: Subset<T, BidAggregateArgs>): Prisma.PrismaPromise<GetBidAggregateType<T>>

    /**
     * Group by Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidGroupByArgs['orderBy'] }
        : { orderBy?: BidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bid model
   */
  readonly fields: BidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer<T extends OfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferDefaultArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bidder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Bid$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Bid$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bid model
   */
  interface BidFieldRefs {
    readonly id: FieldRef<"Bid", 'String'>
    readonly offerId: FieldRef<"Bid", 'String'>
    readonly bidderId: FieldRef<"Bid", 'String'>
    readonly amount: FieldRef<"Bid", 'Float'>
    readonly quantity: FieldRef<"Bid", 'Int'>
    readonly notes: FieldRef<"Bid", 'String'>
    readonly status: FieldRef<"Bid", 'BidStatus'>
    readonly createdAt: FieldRef<"Bid", 'DateTime'>
    readonly updatedAt: FieldRef<"Bid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bid findUnique
   */
  export type BidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findUniqueOrThrow
   */
  export type BidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findFirst
   */
  export type BidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findFirstOrThrow
   */
  export type BidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findMany
   */
  export type BidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bids to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid create
   */
  export type BidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to create a Bid.
     */
    data: XOR<BidCreateInput, BidUncheckedCreateInput>
  }

  /**
   * Bid createMany
   */
  export type BidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
  }

  /**
   * Bid createManyAndReturn
   */
  export type BidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid update
   */
  export type BidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to update a Bid.
     */
    data: XOR<BidUpdateInput, BidUncheckedUpdateInput>
    /**
     * Choose, which Bid to update.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid updateMany
   */
  export type BidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
  }

  /**
   * Bid updateManyAndReturn
   */
  export type BidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid upsert
   */
  export type BidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The filter to search for the Bid to update in case it exists.
     */
    where: BidWhereUniqueInput
    /**
     * In case the Bid found by the `where` argument doesn't exist, create a new Bid with this data.
     */
    create: XOR<BidCreateInput, BidUncheckedCreateInput>
    /**
     * In case the Bid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidUpdateInput, BidUncheckedUpdateInput>
  }

  /**
   * Bid delete
   */
  export type BidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter which Bid to delete.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid deleteMany
   */
  export type BidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bids to delete
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to delete.
     */
    limit?: number
  }

  /**
   * Bid.transactions
   */
  export type Bid$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Bid without action
   */
  export type BidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type TransactionSumAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    sellerId: string | null
    buyerId: string | null
    price: number | null
    quantity: number | null
    offerId: string | null
    bidId: string | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    notes: string | null
    blockchainData: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    creditTitleId: string | null
    sellerId: string | null
    buyerId: string | null
    price: number | null
    quantity: number | null
    offerId: string | null
    bidId: string | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    notes: string | null
    blockchainData: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    creditTitleId: number
    sellerId: number
    buyerId: number
    price: number
    quantity: number
    offerId: number
    bidId: number
    type: number
    status: number
    notes: number
    blockchainData: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type TransactionSumAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    creditTitleId?: true
    sellerId?: true
    buyerId?: true
    price?: true
    quantity?: true
    offerId?: true
    bidId?: true
    type?: true
    status?: true
    notes?: true
    blockchainData?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    creditTitleId?: true
    sellerId?: true
    buyerId?: true
    price?: true
    quantity?: true
    offerId?: true
    bidId?: true
    type?: true
    status?: true
    notes?: true
    blockchainData?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    creditTitleId?: true
    sellerId?: true
    buyerId?: true
    price?: true
    quantity?: true
    offerId?: true
    bidId?: true
    type?: true
    status?: true
    notes?: true
    blockchainData?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity: number
    offerId: string | null
    bidId: string | null
    type: $Enums.TransactionType
    status: $Enums.TransactionStatus
    notes: string | null
    blockchainData: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    price?: boolean
    quantity?: boolean
    offerId?: boolean
    bidId?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    blockchainData?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    offer?: boolean | Transaction$offerArgs<ExtArgs>
    bid?: boolean | Transaction$bidArgs<ExtArgs>
    createdBy?: boolean | Transaction$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    price?: boolean
    quantity?: boolean
    offerId?: boolean
    bidId?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    blockchainData?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    offer?: boolean | Transaction$offerArgs<ExtArgs>
    bid?: boolean | Transaction$bidArgs<ExtArgs>
    createdBy?: boolean | Transaction$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    price?: boolean
    quantity?: boolean
    offerId?: boolean
    bidId?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    blockchainData?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    offer?: boolean | Transaction$offerArgs<ExtArgs>
    bid?: boolean | Transaction$bidArgs<ExtArgs>
    createdBy?: boolean | Transaction$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    creditTitleId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    price?: boolean
    quantity?: boolean
    offerId?: boolean
    bidId?: boolean
    type?: boolean
    status?: boolean
    notes?: boolean
    blockchainData?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditTitleId" | "sellerId" | "buyerId" | "price" | "quantity" | "offerId" | "bidId" | "type" | "status" | "notes" | "blockchainData" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    offer?: boolean | Transaction$offerArgs<ExtArgs>
    bid?: boolean | Transaction$bidArgs<ExtArgs>
    createdBy?: boolean | Transaction$createdByArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    offer?: boolean | Transaction$offerArgs<ExtArgs>
    bid?: boolean | Transaction$bidArgs<ExtArgs>
    createdBy?: boolean | Transaction$createdByArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditTitle?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    offer?: boolean | Transaction$offerArgs<ExtArgs>
    bid?: boolean | Transaction$bidArgs<ExtArgs>
    createdBy?: boolean | Transaction$createdByArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      creditTitle: Prisma.$CreditTitlePayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
      offer: Prisma.$OfferPayload<ExtArgs> | null
      bid: Prisma.$BidPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditTitleId: string
      sellerId: string
      buyerId: string
      price: number
      quantity: number
      offerId: string | null
      bidId: string | null
      type: $Enums.TransactionType
      status: $Enums.TransactionStatus
      notes: string | null
      blockchainData: string | null
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditTitle<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offer<T extends Transaction$offerArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$offerArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bid<T extends Transaction$bidArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$bidArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Transaction$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly creditTitleId: FieldRef<"Transaction", 'String'>
    readonly sellerId: FieldRef<"Transaction", 'String'>
    readonly buyerId: FieldRef<"Transaction", 'String'>
    readonly price: FieldRef<"Transaction", 'Float'>
    readonly quantity: FieldRef<"Transaction", 'Int'>
    readonly offerId: FieldRef<"Transaction", 'String'>
    readonly bidId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly blockchainData: FieldRef<"Transaction", 'String'>
    readonly createdById: FieldRef<"Transaction", 'String'>
    readonly updatedById: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.offer
   */
  export type Transaction$offerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
  }

  /**
   * Transaction.bid
   */
  export type Transaction$bidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
  }

  /**
   * Transaction.createdBy
   */
  export type Transaction$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Auction
   */

  export type AggregateAuction = {
    _count: AuctionCountAggregateOutputType | null
    _avg: AuctionAvgAggregateOutputType | null
    _sum: AuctionSumAggregateOutputType | null
    _min: AuctionMinAggregateOutputType | null
    _max: AuctionMaxAggregateOutputType | null
  }

  export type AuctionAvgAggregateOutputType = {
    startPrice: number | null
    minPrice: number | null
    finalPrice: number | null
  }

  export type AuctionSumAggregateOutputType = {
    startPrice: number | null
    minPrice: number | null
    finalPrice: number | null
  }

  export type AuctionMinAggregateOutputType = {
    id: string | null
    creditId: string | null
    sellerId: string | null
    type: string | null
    startPrice: number | null
    minPrice: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    winnerId: string | null
    finalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionMaxAggregateOutputType = {
    id: string | null
    creditId: string | null
    sellerId: string | null
    type: string | null
    startPrice: number | null
    minPrice: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    winnerId: string | null
    finalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionCountAggregateOutputType = {
    id: number
    creditId: number
    sellerId: number
    type: number
    startPrice: number
    minPrice: number
    startDate: number
    endDate: number
    status: number
    winnerId: number
    finalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuctionAvgAggregateInputType = {
    startPrice?: true
    minPrice?: true
    finalPrice?: true
  }

  export type AuctionSumAggregateInputType = {
    startPrice?: true
    minPrice?: true
    finalPrice?: true
  }

  export type AuctionMinAggregateInputType = {
    id?: true
    creditId?: true
    sellerId?: true
    type?: true
    startPrice?: true
    minPrice?: true
    startDate?: true
    endDate?: true
    status?: true
    winnerId?: true
    finalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionMaxAggregateInputType = {
    id?: true
    creditId?: true
    sellerId?: true
    type?: true
    startPrice?: true
    minPrice?: true
    startDate?: true
    endDate?: true
    status?: true
    winnerId?: true
    finalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionCountAggregateInputType = {
    id?: true
    creditId?: true
    sellerId?: true
    type?: true
    startPrice?: true
    minPrice?: true
    startDate?: true
    endDate?: true
    status?: true
    winnerId?: true
    finalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auction to aggregate.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auctions
    **/
    _count?: true | AuctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionMaxAggregateInputType
  }

  export type GetAuctionAggregateType<T extends AuctionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuction[P]>
      : GetScalarType<T[P], AggregateAuction[P]>
  }




  export type AuctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithAggregationInput | AuctionOrderByWithAggregationInput[]
    by: AuctionScalarFieldEnum[] | AuctionScalarFieldEnum
    having?: AuctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionCountAggregateInputType | true
    _avg?: AuctionAvgAggregateInputType
    _sum?: AuctionSumAggregateInputType
    _min?: AuctionMinAggregateInputType
    _max?: AuctionMaxAggregateInputType
  }

  export type AuctionGroupByOutputType = {
    id: string
    creditId: string
    sellerId: string
    type: string
    startPrice: number
    minPrice: number | null
    startDate: Date
    endDate: Date
    status: string
    winnerId: string | null
    finalPrice: number | null
    createdAt: Date
    updatedAt: Date
    _count: AuctionCountAggregateOutputType | null
    _avg: AuctionAvgAggregateOutputType | null
    _sum: AuctionSumAggregateOutputType | null
    _min: AuctionMinAggregateOutputType | null
    _max: AuctionMaxAggregateOutputType | null
  }

  type GetAuctionGroupByPayload<T extends AuctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionGroupByOutputType[P]>
        }
      >
    >


  export type AuctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditId?: boolean
    sellerId?: boolean
    type?: boolean
    startPrice?: boolean
    minPrice?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    winnerId?: boolean
    finalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    credit?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | Auction$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditId?: boolean
    sellerId?: boolean
    type?: boolean
    startPrice?: boolean
    minPrice?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    winnerId?: boolean
    finalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    credit?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | Auction$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditId?: boolean
    sellerId?: boolean
    type?: boolean
    startPrice?: boolean
    minPrice?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    winnerId?: boolean
    finalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    credit?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | Auction$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectScalar = {
    id?: boolean
    creditId?: boolean
    sellerId?: boolean
    type?: boolean
    startPrice?: boolean
    minPrice?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    winnerId?: boolean
    finalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuctionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditId" | "sellerId" | "type" | "startPrice" | "minPrice" | "startDate" | "endDate" | "status" | "winnerId" | "finalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["auction"]>
  export type AuctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | Auction$winnerArgs<ExtArgs>
  }
  export type AuctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | Auction$winnerArgs<ExtArgs>
  }
  export type AuctionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit?: boolean | CreditTitleDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    winner?: boolean | Auction$winnerArgs<ExtArgs>
  }

  export type $AuctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auction"
    objects: {
      credit: Prisma.$CreditTitlePayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
      winner: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditId: string
      sellerId: string
      type: string
      startPrice: number
      minPrice: number | null
      startDate: Date
      endDate: Date
      status: string
      winnerId: string | null
      finalPrice: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auction"]>
    composites: {}
  }

  type AuctionGetPayload<S extends boolean | null | undefined | AuctionDefaultArgs> = $Result.GetResult<Prisma.$AuctionPayload, S>

  type AuctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionCountAggregateInputType | true
    }

  export interface AuctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auction'], meta: { name: 'Auction' } }
    /**
     * Find zero or one Auction that matches the filter.
     * @param {AuctionFindUniqueArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionFindUniqueArgs>(args: SelectSubset<T, AuctionFindUniqueArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionFindUniqueOrThrowArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindFirstArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionFindFirstArgs>(args?: SelectSubset<T, AuctionFindFirstArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindFirstOrThrowArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auctions
     * const auctions = await prisma.auction.findMany()
     * 
     * // Get first 10 Auctions
     * const auctions = await prisma.auction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionWithIdOnly = await prisma.auction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionFindManyArgs>(args?: SelectSubset<T, AuctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auction.
     * @param {AuctionCreateArgs} args - Arguments to create a Auction.
     * @example
     * // Create one Auction
     * const Auction = await prisma.auction.create({
     *   data: {
     *     // ... data to create a Auction
     *   }
     * })
     * 
     */
    create<T extends AuctionCreateArgs>(args: SelectSubset<T, AuctionCreateArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auctions.
     * @param {AuctionCreateManyArgs} args - Arguments to create many Auctions.
     * @example
     * // Create many Auctions
     * const auction = await prisma.auction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionCreateManyArgs>(args?: SelectSubset<T, AuctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auctions and returns the data saved in the database.
     * @param {AuctionCreateManyAndReturnArgs} args - Arguments to create many Auctions.
     * @example
     * // Create many Auctions
     * const auction = await prisma.auction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auctions and only return the `id`
     * const auctionWithIdOnly = await prisma.auction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auction.
     * @param {AuctionDeleteArgs} args - Arguments to delete one Auction.
     * @example
     * // Delete one Auction
     * const Auction = await prisma.auction.delete({
     *   where: {
     *     // ... filter to delete one Auction
     *   }
     * })
     * 
     */
    delete<T extends AuctionDeleteArgs>(args: SelectSubset<T, AuctionDeleteArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auction.
     * @param {AuctionUpdateArgs} args - Arguments to update one Auction.
     * @example
     * // Update one Auction
     * const auction = await prisma.auction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionUpdateArgs>(args: SelectSubset<T, AuctionUpdateArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auctions.
     * @param {AuctionDeleteManyArgs} args - Arguments to filter Auctions to delete.
     * @example
     * // Delete a few Auctions
     * const { count } = await prisma.auction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionDeleteManyArgs>(args?: SelectSubset<T, AuctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auctions
     * const auction = await prisma.auction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionUpdateManyArgs>(args: SelectSubset<T, AuctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auctions and returns the data updated in the database.
     * @param {AuctionUpdateManyAndReturnArgs} args - Arguments to update many Auctions.
     * @example
     * // Update many Auctions
     * const auction = await prisma.auction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auctions and only return the `id`
     * const auctionWithIdOnly = await prisma.auction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auction.
     * @param {AuctionUpsertArgs} args - Arguments to update or create a Auction.
     * @example
     * // Update or create a Auction
     * const auction = await prisma.auction.upsert({
     *   create: {
     *     // ... data to create a Auction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auction we want to update
     *   }
     * })
     */
    upsert<T extends AuctionUpsertArgs>(args: SelectSubset<T, AuctionUpsertArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionCountArgs} args - Arguments to filter Auctions to count.
     * @example
     * // Count the number of Auctions
     * const count = await prisma.auction.count({
     *   where: {
     *     // ... the filter for the Auctions we want to count
     *   }
     * })
    **/
    count<T extends AuctionCountArgs>(
      args?: Subset<T, AuctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionAggregateArgs>(args: Subset<T, AuctionAggregateArgs>): Prisma.PrismaPromise<GetAuctionAggregateType<T>>

    /**
     * Group by Auction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionGroupByArgs['orderBy'] }
        : { orderBy?: AuctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auction model
   */
  readonly fields: AuctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit<T extends CreditTitleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditTitleDefaultArgs<ExtArgs>>): Prisma__CreditTitleClient<$Result.GetResult<Prisma.$CreditTitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    winner<T extends Auction$winnerArgs<ExtArgs> = {}>(args?: Subset<T, Auction$winnerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auction model
   */
  interface AuctionFieldRefs {
    readonly id: FieldRef<"Auction", 'String'>
    readonly creditId: FieldRef<"Auction", 'String'>
    readonly sellerId: FieldRef<"Auction", 'String'>
    readonly type: FieldRef<"Auction", 'String'>
    readonly startPrice: FieldRef<"Auction", 'Float'>
    readonly minPrice: FieldRef<"Auction", 'Float'>
    readonly startDate: FieldRef<"Auction", 'DateTime'>
    readonly endDate: FieldRef<"Auction", 'DateTime'>
    readonly status: FieldRef<"Auction", 'String'>
    readonly winnerId: FieldRef<"Auction", 'String'>
    readonly finalPrice: FieldRef<"Auction", 'Float'>
    readonly createdAt: FieldRef<"Auction", 'DateTime'>
    readonly updatedAt: FieldRef<"Auction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Auction findUnique
   */
  export type AuctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction findUniqueOrThrow
   */
  export type AuctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction findFirst
   */
  export type AuctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auctions.
     */
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Auction findFirstOrThrow
   */
  export type AuctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auctions.
     */
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Auction findMany
   */
  export type AuctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auctions to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Auction create
   */
  export type AuctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The data needed to create a Auction.
     */
    data: XOR<AuctionCreateInput, AuctionUncheckedCreateInput>
  }

  /**
   * Auction createMany
   */
  export type AuctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auctions.
     */
    data: AuctionCreateManyInput | AuctionCreateManyInput[]
  }

  /**
   * Auction createManyAndReturn
   */
  export type AuctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * The data used to create many Auctions.
     */
    data: AuctionCreateManyInput | AuctionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auction update
   */
  export type AuctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The data needed to update a Auction.
     */
    data: XOR<AuctionUpdateInput, AuctionUncheckedUpdateInput>
    /**
     * Choose, which Auction to update.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction updateMany
   */
  export type AuctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auctions.
     */
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyInput>
    /**
     * Filter which Auctions to update
     */
    where?: AuctionWhereInput
    /**
     * Limit how many Auctions to update.
     */
    limit?: number
  }

  /**
   * Auction updateManyAndReturn
   */
  export type AuctionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * The data used to update Auctions.
     */
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyInput>
    /**
     * Filter which Auctions to update
     */
    where?: AuctionWhereInput
    /**
     * Limit how many Auctions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auction upsert
   */
  export type AuctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The filter to search for the Auction to update in case it exists.
     */
    where: AuctionWhereUniqueInput
    /**
     * In case the Auction found by the `where` argument doesn't exist, create a new Auction with this data.
     */
    create: XOR<AuctionCreateInput, AuctionUncheckedCreateInput>
    /**
     * In case the Auction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionUpdateInput, AuctionUncheckedUpdateInput>
  }

  /**
   * Auction delete
   */
  export type AuctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter which Auction to delete.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction deleteMany
   */
  export type AuctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auctions to delete
     */
    where?: AuctionWhereInput
    /**
     * Limit how many Auctions to delete.
     */
    limit?: number
  }

  /**
   * Auction.winner
   */
  export type Auction$winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Auction without action
   */
  export type AuctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
  }


  /**
   * Model Settlement
   */

  export type AggregateSettlement = {
    _count: SettlementCountAggregateOutputType | null
    _avg: SettlementAvgAggregateOutputType | null
    _sum: SettlementSumAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  export type SettlementAvgAggregateOutputType = {
    totalValue: number | null
  }

  export type SettlementSumAggregateOutputType = {
    totalValue: number | null
  }

  export type SettlementMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    totalValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettlementMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    totalValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettlementCountAggregateOutputType = {
    id: number
    type: number
    status: number
    totalValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettlementAvgAggregateInputType = {
    totalValue?: true
  }

  export type SettlementSumAggregateInputType = {
    totalValue?: true
  }

  export type SettlementMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    totalValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettlementMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    totalValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettlementCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    totalValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settlement to aggregate.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settlements
    **/
    _count?: true | SettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementMaxAggregateInputType
  }

  export type GetSettlementAggregateType<T extends SettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlement[P]>
      : GetScalarType<T[P], AggregateSettlement[P]>
  }




  export type SettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementWhereInput
    orderBy?: SettlementOrderByWithAggregationInput | SettlementOrderByWithAggregationInput[]
    by: SettlementScalarFieldEnum[] | SettlementScalarFieldEnum
    having?: SettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementCountAggregateInputType | true
    _avg?: SettlementAvgAggregateInputType
    _sum?: SettlementSumAggregateInputType
    _min?: SettlementMinAggregateInputType
    _max?: SettlementMaxAggregateInputType
  }

  export type SettlementGroupByOutputType = {
    id: string
    type: string
    status: string
    totalValue: number
    createdAt: Date
    updatedAt: Date
    _count: SettlementCountAggregateOutputType | null
    _avg: SettlementAvgAggregateOutputType | null
    _sum: SettlementSumAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  type GetSettlementGroupByPayload<T extends SettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementGroupByOutputType[P]>
        }
      >
    >


  export type SettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    totalValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | Settlement$participantsArgs<ExtArgs>
    _count?: boolean | SettlementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    totalValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    totalValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    totalValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "totalValue" | "createdAt" | "updatedAt", ExtArgs["result"]["settlement"]>
  export type SettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Settlement$participantsArgs<ExtArgs>
    _count?: boolean | SettlementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SettlementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settlement"
    objects: {
      participants: Prisma.$SettlementParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      status: string
      totalValue: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settlement"]>
    composites: {}
  }

  type SettlementGetPayload<S extends boolean | null | undefined | SettlementDefaultArgs> = $Result.GetResult<Prisma.$SettlementPayload, S>

  type SettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettlementCountAggregateInputType | true
    }

  export interface SettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settlement'], meta: { name: 'Settlement' } }
    /**
     * Find zero or one Settlement that matches the filter.
     * @param {SettlementFindUniqueArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettlementFindUniqueArgs>(args: SelectSubset<T, SettlementFindUniqueArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettlementFindUniqueOrThrowArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, SettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettlementFindFirstArgs>(args?: SelectSubset<T, SettlementFindFirstArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstOrThrowArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, SettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settlements
     * const settlements = await prisma.settlement.findMany()
     * 
     * // Get first 10 Settlements
     * const settlements = await prisma.settlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlementWithIdOnly = await prisma.settlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettlementFindManyArgs>(args?: SelectSubset<T, SettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settlement.
     * @param {SettlementCreateArgs} args - Arguments to create a Settlement.
     * @example
     * // Create one Settlement
     * const Settlement = await prisma.settlement.create({
     *   data: {
     *     // ... data to create a Settlement
     *   }
     * })
     * 
     */
    create<T extends SettlementCreateArgs>(args: SelectSubset<T, SettlementCreateArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settlements.
     * @param {SettlementCreateManyArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlement = await prisma.settlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettlementCreateManyArgs>(args?: SelectSubset<T, SettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settlements and returns the data saved in the database.
     * @param {SettlementCreateManyAndReturnArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlement = await prisma.settlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settlements and only return the `id`
     * const settlementWithIdOnly = await prisma.settlement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, SettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settlement.
     * @param {SettlementDeleteArgs} args - Arguments to delete one Settlement.
     * @example
     * // Delete one Settlement
     * const Settlement = await prisma.settlement.delete({
     *   where: {
     *     // ... filter to delete one Settlement
     *   }
     * })
     * 
     */
    delete<T extends SettlementDeleteArgs>(args: SelectSubset<T, SettlementDeleteArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settlement.
     * @param {SettlementUpdateArgs} args - Arguments to update one Settlement.
     * @example
     * // Update one Settlement
     * const settlement = await prisma.settlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettlementUpdateArgs>(args: SelectSubset<T, SettlementUpdateArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settlements.
     * @param {SettlementDeleteManyArgs} args - Arguments to filter Settlements to delete.
     * @example
     * // Delete a few Settlements
     * const { count } = await prisma.settlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettlementDeleteManyArgs>(args?: SelectSubset<T, SettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settlements
     * const settlement = await prisma.settlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettlementUpdateManyArgs>(args: SelectSubset<T, SettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements and returns the data updated in the database.
     * @param {SettlementUpdateManyAndReturnArgs} args - Arguments to update many Settlements.
     * @example
     * // Update many Settlements
     * const settlement = await prisma.settlement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settlements and only return the `id`
     * const settlementWithIdOnly = await prisma.settlement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettlementUpdateManyAndReturnArgs>(args: SelectSubset<T, SettlementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settlement.
     * @param {SettlementUpsertArgs} args - Arguments to update or create a Settlement.
     * @example
     * // Update or create a Settlement
     * const settlement = await prisma.settlement.upsert({
     *   create: {
     *     // ... data to create a Settlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settlement we want to update
     *   }
     * })
     */
    upsert<T extends SettlementUpsertArgs>(args: SelectSubset<T, SettlementUpsertArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementCountArgs} args - Arguments to filter Settlements to count.
     * @example
     * // Count the number of Settlements
     * const count = await prisma.settlement.count({
     *   where: {
     *     // ... the filter for the Settlements we want to count
     *   }
     * })
    **/
    count<T extends SettlementCountArgs>(
      args?: Subset<T, SettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementAggregateArgs>(args: Subset<T, SettlementAggregateArgs>): Prisma.PrismaPromise<GetSettlementAggregateType<T>>

    /**
     * Group by Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettlementGroupByArgs['orderBy'] }
        : { orderBy?: SettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settlement model
   */
  readonly fields: SettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Settlement$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Settlement$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settlement model
   */
  interface SettlementFieldRefs {
    readonly id: FieldRef<"Settlement", 'String'>
    readonly type: FieldRef<"Settlement", 'String'>
    readonly status: FieldRef<"Settlement", 'String'>
    readonly totalValue: FieldRef<"Settlement", 'Float'>
    readonly createdAt: FieldRef<"Settlement", 'DateTime'>
    readonly updatedAt: FieldRef<"Settlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settlement findUnique
   */
  export type SettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement findUniqueOrThrow
   */
  export type SettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement findFirst
   */
  export type SettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     */
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement findFirstOrThrow
   */
  export type SettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     */
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement findMany
   */
  export type SettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlements to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement create
   */
  export type SettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a Settlement.
     */
    data: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
  }

  /**
   * Settlement createMany
   */
  export type SettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settlements.
     */
    data: SettlementCreateManyInput | SettlementCreateManyInput[]
  }

  /**
   * Settlement createManyAndReturn
   */
  export type SettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * The data used to create many Settlements.
     */
    data: SettlementCreateManyInput | SettlementCreateManyInput[]
  }

  /**
   * Settlement update
   */
  export type SettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a Settlement.
     */
    data: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
    /**
     * Choose, which Settlement to update.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement updateMany
   */
  export type SettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settlements.
     */
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyInput>
    /**
     * Filter which Settlements to update
     */
    where?: SettlementWhereInput
    /**
     * Limit how many Settlements to update.
     */
    limit?: number
  }

  /**
   * Settlement updateManyAndReturn
   */
  export type SettlementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * The data used to update Settlements.
     */
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyInput>
    /**
     * Filter which Settlements to update
     */
    where?: SettlementWhereInput
    /**
     * Limit how many Settlements to update.
     */
    limit?: number
  }

  /**
   * Settlement upsert
   */
  export type SettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the Settlement to update in case it exists.
     */
    where: SettlementWhereUniqueInput
    /**
     * In case the Settlement found by the `where` argument doesn't exist, create a new Settlement with this data.
     */
    create: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
    /**
     * In case the Settlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
  }

  /**
   * Settlement delete
   */
  export type SettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter which Settlement to delete.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement deleteMany
   */
  export type SettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settlements to delete
     */
    where?: SettlementWhereInput
    /**
     * Limit how many Settlements to delete.
     */
    limit?: number
  }

  /**
   * Settlement.participants
   */
  export type Settlement$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    where?: SettlementParticipantWhereInput
    orderBy?: SettlementParticipantOrderByWithRelationInput | SettlementParticipantOrderByWithRelationInput[]
    cursor?: SettlementParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementParticipantScalarFieldEnum | SettlementParticipantScalarFieldEnum[]
  }

  /**
   * Settlement without action
   */
  export type SettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
  }


  /**
   * Model SettlementParticipant
   */

  export type AggregateSettlementParticipant = {
    _count: SettlementParticipantCountAggregateOutputType | null
    _avg: SettlementParticipantAvgAggregateOutputType | null
    _sum: SettlementParticipantSumAggregateOutputType | null
    _min: SettlementParticipantMinAggregateOutputType | null
    _max: SettlementParticipantMaxAggregateOutputType | null
  }

  export type SettlementParticipantAvgAggregateOutputType = {
    value: number | null
  }

  export type SettlementParticipantSumAggregateOutputType = {
    value: number | null
  }

  export type SettlementParticipantMinAggregateOutputType = {
    id: string | null
    settlementId: string | null
    userId: string | null
    role: string | null
    value: number | null
    status: string | null
  }

  export type SettlementParticipantMaxAggregateOutputType = {
    id: string | null
    settlementId: string | null
    userId: string | null
    role: string | null
    value: number | null
    status: string | null
  }

  export type SettlementParticipantCountAggregateOutputType = {
    id: number
    settlementId: number
    userId: number
    role: number
    value: number
    status: number
    _all: number
  }


  export type SettlementParticipantAvgAggregateInputType = {
    value?: true
  }

  export type SettlementParticipantSumAggregateInputType = {
    value?: true
  }

  export type SettlementParticipantMinAggregateInputType = {
    id?: true
    settlementId?: true
    userId?: true
    role?: true
    value?: true
    status?: true
  }

  export type SettlementParticipantMaxAggregateInputType = {
    id?: true
    settlementId?: true
    userId?: true
    role?: true
    value?: true
    status?: true
  }

  export type SettlementParticipantCountAggregateInputType = {
    id?: true
    settlementId?: true
    userId?: true
    role?: true
    value?: true
    status?: true
    _all?: true
  }

  export type SettlementParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettlementParticipant to aggregate.
     */
    where?: SettlementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementParticipants to fetch.
     */
    orderBy?: SettlementParticipantOrderByWithRelationInput | SettlementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettlementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettlementParticipants
    **/
    _count?: true | SettlementParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettlementParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettlementParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementParticipantMaxAggregateInputType
  }

  export type GetSettlementParticipantAggregateType<T extends SettlementParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlementParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlementParticipant[P]>
      : GetScalarType<T[P], AggregateSettlementParticipant[P]>
  }




  export type SettlementParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementParticipantWhereInput
    orderBy?: SettlementParticipantOrderByWithAggregationInput | SettlementParticipantOrderByWithAggregationInput[]
    by: SettlementParticipantScalarFieldEnum[] | SettlementParticipantScalarFieldEnum
    having?: SettlementParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementParticipantCountAggregateInputType | true
    _avg?: SettlementParticipantAvgAggregateInputType
    _sum?: SettlementParticipantSumAggregateInputType
    _min?: SettlementParticipantMinAggregateInputType
    _max?: SettlementParticipantMaxAggregateInputType
  }

  export type SettlementParticipantGroupByOutputType = {
    id: string
    settlementId: string
    userId: string
    role: string
    value: number
    status: string
    _count: SettlementParticipantCountAggregateOutputType | null
    _avg: SettlementParticipantAvgAggregateOutputType | null
    _sum: SettlementParticipantSumAggregateOutputType | null
    _min: SettlementParticipantMinAggregateOutputType | null
    _max: SettlementParticipantMaxAggregateOutputType | null
  }

  type GetSettlementParticipantGroupByPayload<T extends SettlementParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettlementParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementParticipantGroupByOutputType[P]>
        }
      >
    >


  export type SettlementParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settlementId?: boolean
    userId?: boolean
    role?: boolean
    value?: boolean
    status?: boolean
    settlement?: boolean | SettlementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlementParticipant"]>

  export type SettlementParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settlementId?: boolean
    userId?: boolean
    role?: boolean
    value?: boolean
    status?: boolean
    settlement?: boolean | SettlementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlementParticipant"]>

  export type SettlementParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settlementId?: boolean
    userId?: boolean
    role?: boolean
    value?: boolean
    status?: boolean
    settlement?: boolean | SettlementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlementParticipant"]>

  export type SettlementParticipantSelectScalar = {
    id?: boolean
    settlementId?: boolean
    userId?: boolean
    role?: boolean
    value?: boolean
    status?: boolean
  }

  export type SettlementParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "settlementId" | "userId" | "role" | "value" | "status", ExtArgs["result"]["settlementParticipant"]>
  export type SettlementParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlement?: boolean | SettlementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SettlementParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlement?: boolean | SettlementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SettlementParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlement?: boolean | SettlementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SettlementParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettlementParticipant"
    objects: {
      settlement: Prisma.$SettlementPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      settlementId: string
      userId: string
      role: string
      value: number
      status: string
    }, ExtArgs["result"]["settlementParticipant"]>
    composites: {}
  }

  type SettlementParticipantGetPayload<S extends boolean | null | undefined | SettlementParticipantDefaultArgs> = $Result.GetResult<Prisma.$SettlementParticipantPayload, S>

  type SettlementParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettlementParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettlementParticipantCountAggregateInputType | true
    }

  export interface SettlementParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettlementParticipant'], meta: { name: 'SettlementParticipant' } }
    /**
     * Find zero or one SettlementParticipant that matches the filter.
     * @param {SettlementParticipantFindUniqueArgs} args - Arguments to find a SettlementParticipant
     * @example
     * // Get one SettlementParticipant
     * const settlementParticipant = await prisma.settlementParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettlementParticipantFindUniqueArgs>(args: SelectSubset<T, SettlementParticipantFindUniqueArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SettlementParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettlementParticipantFindUniqueOrThrowArgs} args - Arguments to find a SettlementParticipant
     * @example
     * // Get one SettlementParticipant
     * const settlementParticipant = await prisma.settlementParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettlementParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, SettlementParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettlementParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantFindFirstArgs} args - Arguments to find a SettlementParticipant
     * @example
     * // Get one SettlementParticipant
     * const settlementParticipant = await prisma.settlementParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettlementParticipantFindFirstArgs>(args?: SelectSubset<T, SettlementParticipantFindFirstArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettlementParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantFindFirstOrThrowArgs} args - Arguments to find a SettlementParticipant
     * @example
     * // Get one SettlementParticipant
     * const settlementParticipant = await prisma.settlementParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettlementParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, SettlementParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SettlementParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettlementParticipants
     * const settlementParticipants = await prisma.settlementParticipant.findMany()
     * 
     * // Get first 10 SettlementParticipants
     * const settlementParticipants = await prisma.settlementParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlementParticipantWithIdOnly = await prisma.settlementParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettlementParticipantFindManyArgs>(args?: SelectSubset<T, SettlementParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SettlementParticipant.
     * @param {SettlementParticipantCreateArgs} args - Arguments to create a SettlementParticipant.
     * @example
     * // Create one SettlementParticipant
     * const SettlementParticipant = await prisma.settlementParticipant.create({
     *   data: {
     *     // ... data to create a SettlementParticipant
     *   }
     * })
     * 
     */
    create<T extends SettlementParticipantCreateArgs>(args: SelectSubset<T, SettlementParticipantCreateArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SettlementParticipants.
     * @param {SettlementParticipantCreateManyArgs} args - Arguments to create many SettlementParticipants.
     * @example
     * // Create many SettlementParticipants
     * const settlementParticipant = await prisma.settlementParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettlementParticipantCreateManyArgs>(args?: SelectSubset<T, SettlementParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SettlementParticipants and returns the data saved in the database.
     * @param {SettlementParticipantCreateManyAndReturnArgs} args - Arguments to create many SettlementParticipants.
     * @example
     * // Create many SettlementParticipants
     * const settlementParticipant = await prisma.settlementParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SettlementParticipants and only return the `id`
     * const settlementParticipantWithIdOnly = await prisma.settlementParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettlementParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, SettlementParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SettlementParticipant.
     * @param {SettlementParticipantDeleteArgs} args - Arguments to delete one SettlementParticipant.
     * @example
     * // Delete one SettlementParticipant
     * const SettlementParticipant = await prisma.settlementParticipant.delete({
     *   where: {
     *     // ... filter to delete one SettlementParticipant
     *   }
     * })
     * 
     */
    delete<T extends SettlementParticipantDeleteArgs>(args: SelectSubset<T, SettlementParticipantDeleteArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SettlementParticipant.
     * @param {SettlementParticipantUpdateArgs} args - Arguments to update one SettlementParticipant.
     * @example
     * // Update one SettlementParticipant
     * const settlementParticipant = await prisma.settlementParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettlementParticipantUpdateArgs>(args: SelectSubset<T, SettlementParticipantUpdateArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SettlementParticipants.
     * @param {SettlementParticipantDeleteManyArgs} args - Arguments to filter SettlementParticipants to delete.
     * @example
     * // Delete a few SettlementParticipants
     * const { count } = await prisma.settlementParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettlementParticipantDeleteManyArgs>(args?: SelectSubset<T, SettlementParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettlementParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettlementParticipants
     * const settlementParticipant = await prisma.settlementParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettlementParticipantUpdateManyArgs>(args: SelectSubset<T, SettlementParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettlementParticipants and returns the data updated in the database.
     * @param {SettlementParticipantUpdateManyAndReturnArgs} args - Arguments to update many SettlementParticipants.
     * @example
     * // Update many SettlementParticipants
     * const settlementParticipant = await prisma.settlementParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SettlementParticipants and only return the `id`
     * const settlementParticipantWithIdOnly = await prisma.settlementParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettlementParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, SettlementParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SettlementParticipant.
     * @param {SettlementParticipantUpsertArgs} args - Arguments to update or create a SettlementParticipant.
     * @example
     * // Update or create a SettlementParticipant
     * const settlementParticipant = await prisma.settlementParticipant.upsert({
     *   create: {
     *     // ... data to create a SettlementParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettlementParticipant we want to update
     *   }
     * })
     */
    upsert<T extends SettlementParticipantUpsertArgs>(args: SelectSubset<T, SettlementParticipantUpsertArgs<ExtArgs>>): Prisma__SettlementParticipantClient<$Result.GetResult<Prisma.$SettlementParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SettlementParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantCountArgs} args - Arguments to filter SettlementParticipants to count.
     * @example
     * // Count the number of SettlementParticipants
     * const count = await prisma.settlementParticipant.count({
     *   where: {
     *     // ... the filter for the SettlementParticipants we want to count
     *   }
     * })
    **/
    count<T extends SettlementParticipantCountArgs>(
      args?: Subset<T, SettlementParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettlementParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementParticipantAggregateArgs>(args: Subset<T, SettlementParticipantAggregateArgs>): Prisma.PrismaPromise<GetSettlementParticipantAggregateType<T>>

    /**
     * Group by SettlementParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettlementParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettlementParticipantGroupByArgs['orderBy'] }
        : { orderBy?: SettlementParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettlementParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettlementParticipant model
   */
  readonly fields: SettlementParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettlementParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettlementParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settlement<T extends SettlementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettlementDefaultArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettlementParticipant model
   */
  interface SettlementParticipantFieldRefs {
    readonly id: FieldRef<"SettlementParticipant", 'String'>
    readonly settlementId: FieldRef<"SettlementParticipant", 'String'>
    readonly userId: FieldRef<"SettlementParticipant", 'String'>
    readonly role: FieldRef<"SettlementParticipant", 'String'>
    readonly value: FieldRef<"SettlementParticipant", 'Float'>
    readonly status: FieldRef<"SettlementParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SettlementParticipant findUnique
   */
  export type SettlementParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SettlementParticipant to fetch.
     */
    where: SettlementParticipantWhereUniqueInput
  }

  /**
   * SettlementParticipant findUniqueOrThrow
   */
  export type SettlementParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SettlementParticipant to fetch.
     */
    where: SettlementParticipantWhereUniqueInput
  }

  /**
   * SettlementParticipant findFirst
   */
  export type SettlementParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SettlementParticipant to fetch.
     */
    where?: SettlementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementParticipants to fetch.
     */
    orderBy?: SettlementParticipantOrderByWithRelationInput | SettlementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettlementParticipants.
     */
    cursor?: SettlementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettlementParticipants.
     */
    distinct?: SettlementParticipantScalarFieldEnum | SettlementParticipantScalarFieldEnum[]
  }

  /**
   * SettlementParticipant findFirstOrThrow
   */
  export type SettlementParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SettlementParticipant to fetch.
     */
    where?: SettlementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementParticipants to fetch.
     */
    orderBy?: SettlementParticipantOrderByWithRelationInput | SettlementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettlementParticipants.
     */
    cursor?: SettlementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettlementParticipants.
     */
    distinct?: SettlementParticipantScalarFieldEnum | SettlementParticipantScalarFieldEnum[]
  }

  /**
   * SettlementParticipant findMany
   */
  export type SettlementParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SettlementParticipants to fetch.
     */
    where?: SettlementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementParticipants to fetch.
     */
    orderBy?: SettlementParticipantOrderByWithRelationInput | SettlementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettlementParticipants.
     */
    cursor?: SettlementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementParticipants.
     */
    skip?: number
    distinct?: SettlementParticipantScalarFieldEnum | SettlementParticipantScalarFieldEnum[]
  }

  /**
   * SettlementParticipant create
   */
  export type SettlementParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a SettlementParticipant.
     */
    data: XOR<SettlementParticipantCreateInput, SettlementParticipantUncheckedCreateInput>
  }

  /**
   * SettlementParticipant createMany
   */
  export type SettlementParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettlementParticipants.
     */
    data: SettlementParticipantCreateManyInput | SettlementParticipantCreateManyInput[]
  }

  /**
   * SettlementParticipant createManyAndReturn
   */
  export type SettlementParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many SettlementParticipants.
     */
    data: SettlementParticipantCreateManyInput | SettlementParticipantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SettlementParticipant update
   */
  export type SettlementParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a SettlementParticipant.
     */
    data: XOR<SettlementParticipantUpdateInput, SettlementParticipantUncheckedUpdateInput>
    /**
     * Choose, which SettlementParticipant to update.
     */
    where: SettlementParticipantWhereUniqueInput
  }

  /**
   * SettlementParticipant updateMany
   */
  export type SettlementParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettlementParticipants.
     */
    data: XOR<SettlementParticipantUpdateManyMutationInput, SettlementParticipantUncheckedUpdateManyInput>
    /**
     * Filter which SettlementParticipants to update
     */
    where?: SettlementParticipantWhereInput
    /**
     * Limit how many SettlementParticipants to update.
     */
    limit?: number
  }

  /**
   * SettlementParticipant updateManyAndReturn
   */
  export type SettlementParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * The data used to update SettlementParticipants.
     */
    data: XOR<SettlementParticipantUpdateManyMutationInput, SettlementParticipantUncheckedUpdateManyInput>
    /**
     * Filter which SettlementParticipants to update
     */
    where?: SettlementParticipantWhereInput
    /**
     * Limit how many SettlementParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SettlementParticipant upsert
   */
  export type SettlementParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the SettlementParticipant to update in case it exists.
     */
    where: SettlementParticipantWhereUniqueInput
    /**
     * In case the SettlementParticipant found by the `where` argument doesn't exist, create a new SettlementParticipant with this data.
     */
    create: XOR<SettlementParticipantCreateInput, SettlementParticipantUncheckedCreateInput>
    /**
     * In case the SettlementParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettlementParticipantUpdateInput, SettlementParticipantUncheckedUpdateInput>
  }

  /**
   * SettlementParticipant delete
   */
  export type SettlementParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
    /**
     * Filter which SettlementParticipant to delete.
     */
    where: SettlementParticipantWhereUniqueInput
  }

  /**
   * SettlementParticipant deleteMany
   */
  export type SettlementParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettlementParticipants to delete
     */
    where?: SettlementParticipantWhereInput
    /**
     * Limit how many SettlementParticipants to delete.
     */
    limit?: number
  }

  /**
   * SettlementParticipant without action
   */
  export type SettlementParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementParticipant
     */
    select?: SettlementParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettlementParticipant
     */
    omit?: SettlementParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "read" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string
      details: string
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model FiscalObligation
   */

  export type AggregateFiscalObligation = {
    _count: FiscalObligationCountAggregateOutputType | null
    _avg: FiscalObligationAvgAggregateOutputType | null
    _sum: FiscalObligationSumAggregateOutputType | null
    _min: FiscalObligationMinAggregateOutputType | null
    _max: FiscalObligationMaxAggregateOutputType | null
  }

  export type FiscalObligationAvgAggregateOutputType = {
    amount: number | null
    taxBase: number | null
    taxRate: number | null
    taxValue: number | null
    taxInterest: number | null
    taxFine: number | null
    taxTotal: number | null
  }

  export type FiscalObligationSumAggregateOutputType = {
    amount: number | null
    taxBase: number | null
    taxRate: number | null
    taxValue: number | null
    taxInterest: number | null
    taxFine: number | null
    taxTotal: number | null
  }

  export type FiscalObligationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    amount: number | null
    currency: string | null
    dueDate: Date | null
    taxCode: string | null
    taxName: string | null
    taxType: string | null
    taxPeriod: string | null
    taxBase: number | null
    taxRate: number | null
    taxValue: number | null
    taxInterest: number | null
    taxFine: number | null
    taxTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalObligationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    amount: number | null
    currency: string | null
    dueDate: Date | null
    taxCode: string | null
    taxName: string | null
    taxType: string | null
    taxPeriod: string | null
    taxBase: number | null
    taxRate: number | null
    taxValue: number | null
    taxInterest: number | null
    taxFine: number | null
    taxTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalObligationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    type: number
    status: number
    amount: number
    currency: number
    dueDate: number
    taxCode: number
    taxName: number
    taxType: number
    taxPeriod: number
    taxBase: number
    taxRate: number
    taxValue: number
    taxInterest: number
    taxFine: number
    taxTotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FiscalObligationAvgAggregateInputType = {
    amount?: true
    taxBase?: true
    taxRate?: true
    taxValue?: true
    taxInterest?: true
    taxFine?: true
    taxTotal?: true
  }

  export type FiscalObligationSumAggregateInputType = {
    amount?: true
    taxBase?: true
    taxRate?: true
    taxValue?: true
    taxInterest?: true
    taxFine?: true
    taxTotal?: true
  }

  export type FiscalObligationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    amount?: true
    currency?: true
    dueDate?: true
    taxCode?: true
    taxName?: true
    taxType?: true
    taxPeriod?: true
    taxBase?: true
    taxRate?: true
    taxValue?: true
    taxInterest?: true
    taxFine?: true
    taxTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalObligationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    amount?: true
    currency?: true
    dueDate?: true
    taxCode?: true
    taxName?: true
    taxType?: true
    taxPeriod?: true
    taxBase?: true
    taxRate?: true
    taxValue?: true
    taxInterest?: true
    taxFine?: true
    taxTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalObligationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    amount?: true
    currency?: true
    dueDate?: true
    taxCode?: true
    taxName?: true
    taxType?: true
    taxPeriod?: true
    taxBase?: true
    taxRate?: true
    taxValue?: true
    taxInterest?: true
    taxFine?: true
    taxTotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FiscalObligationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalObligation to aggregate.
     */
    where?: FiscalObligationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalObligations to fetch.
     */
    orderBy?: FiscalObligationOrderByWithRelationInput | FiscalObligationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiscalObligationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalObligations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalObligations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiscalObligations
    **/
    _count?: true | FiscalObligationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiscalObligationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiscalObligationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalObligationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalObligationMaxAggregateInputType
  }

  export type GetFiscalObligationAggregateType<T extends FiscalObligationAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalObligation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalObligation[P]>
      : GetScalarType<T[P], AggregateFiscalObligation[P]>
  }




  export type FiscalObligationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalObligationWhereInput
    orderBy?: FiscalObligationOrderByWithAggregationInput | FiscalObligationOrderByWithAggregationInput[]
    by: FiscalObligationScalarFieldEnum[] | FiscalObligationScalarFieldEnum
    having?: FiscalObligationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalObligationCountAggregateInputType | true
    _avg?: FiscalObligationAvgAggregateInputType
    _sum?: FiscalObligationSumAggregateInputType
    _min?: FiscalObligationMinAggregateInputType
    _max?: FiscalObligationMaxAggregateInputType
  }

  export type FiscalObligationGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date
    taxCode: string | null
    taxName: string | null
    taxType: string | null
    taxPeriod: string | null
    taxBase: number | null
    taxRate: number | null
    taxValue: number | null
    taxInterest: number | null
    taxFine: number | null
    taxTotal: number | null
    createdAt: Date
    updatedAt: Date
    _count: FiscalObligationCountAggregateOutputType | null
    _avg: FiscalObligationAvgAggregateOutputType | null
    _sum: FiscalObligationSumAggregateOutputType | null
    _min: FiscalObligationMinAggregateOutputType | null
    _max: FiscalObligationMaxAggregateOutputType | null
  }

  type GetFiscalObligationGroupByPayload<T extends FiscalObligationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalObligationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalObligationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalObligationGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalObligationGroupByOutputType[P]>
        }
      >
    >


  export type FiscalObligationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    taxCode?: boolean
    taxName?: boolean
    taxType?: boolean
    taxPeriod?: boolean
    taxBase?: boolean
    taxRate?: boolean
    taxValue?: boolean
    taxInterest?: boolean
    taxFine?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalObligation"]>

  export type FiscalObligationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    taxCode?: boolean
    taxName?: boolean
    taxType?: boolean
    taxPeriod?: boolean
    taxBase?: boolean
    taxRate?: boolean
    taxValue?: boolean
    taxInterest?: boolean
    taxFine?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalObligation"]>

  export type FiscalObligationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    taxCode?: boolean
    taxName?: boolean
    taxType?: boolean
    taxPeriod?: boolean
    taxBase?: boolean
    taxRate?: boolean
    taxValue?: boolean
    taxInterest?: boolean
    taxFine?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalObligation"]>

  export type FiscalObligationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    taxCode?: boolean
    taxName?: boolean
    taxType?: boolean
    taxPeriod?: boolean
    taxBase?: boolean
    taxRate?: boolean
    taxValue?: boolean
    taxInterest?: boolean
    taxFine?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FiscalObligationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "type" | "status" | "amount" | "currency" | "dueDate" | "taxCode" | "taxName" | "taxType" | "taxPeriod" | "taxBase" | "taxRate" | "taxValue" | "taxInterest" | "taxFine" | "taxTotal" | "createdAt" | "updatedAt", ExtArgs["result"]["fiscalObligation"]>
  export type FiscalObligationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FiscalObligationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FiscalObligationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FiscalObligationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FiscalObligation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      type: string
      status: string
      amount: number
      currency: string
      dueDate: Date
      taxCode: string | null
      taxName: string | null
      taxType: string | null
      taxPeriod: string | null
      taxBase: number | null
      taxRate: number | null
      taxValue: number | null
      taxInterest: number | null
      taxFine: number | null
      taxTotal: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fiscalObligation"]>
    composites: {}
  }

  type FiscalObligationGetPayload<S extends boolean | null | undefined | FiscalObligationDefaultArgs> = $Result.GetResult<Prisma.$FiscalObligationPayload, S>

  type FiscalObligationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FiscalObligationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FiscalObligationCountAggregateInputType | true
    }

  export interface FiscalObligationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiscalObligation'], meta: { name: 'FiscalObligation' } }
    /**
     * Find zero or one FiscalObligation that matches the filter.
     * @param {FiscalObligationFindUniqueArgs} args - Arguments to find a FiscalObligation
     * @example
     * // Get one FiscalObligation
     * const fiscalObligation = await prisma.fiscalObligation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FiscalObligationFindUniqueArgs>(args: SelectSubset<T, FiscalObligationFindUniqueArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FiscalObligation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FiscalObligationFindUniqueOrThrowArgs} args - Arguments to find a FiscalObligation
     * @example
     * // Get one FiscalObligation
     * const fiscalObligation = await prisma.fiscalObligation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FiscalObligationFindUniqueOrThrowArgs>(args: SelectSubset<T, FiscalObligationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FiscalObligation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationFindFirstArgs} args - Arguments to find a FiscalObligation
     * @example
     * // Get one FiscalObligation
     * const fiscalObligation = await prisma.fiscalObligation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FiscalObligationFindFirstArgs>(args?: SelectSubset<T, FiscalObligationFindFirstArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FiscalObligation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationFindFirstOrThrowArgs} args - Arguments to find a FiscalObligation
     * @example
     * // Get one FiscalObligation
     * const fiscalObligation = await prisma.fiscalObligation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FiscalObligationFindFirstOrThrowArgs>(args?: SelectSubset<T, FiscalObligationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FiscalObligations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalObligations
     * const fiscalObligations = await prisma.fiscalObligation.findMany()
     * 
     * // Get first 10 FiscalObligations
     * const fiscalObligations = await prisma.fiscalObligation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalObligationWithIdOnly = await prisma.fiscalObligation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FiscalObligationFindManyArgs>(args?: SelectSubset<T, FiscalObligationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FiscalObligation.
     * @param {FiscalObligationCreateArgs} args - Arguments to create a FiscalObligation.
     * @example
     * // Create one FiscalObligation
     * const FiscalObligation = await prisma.fiscalObligation.create({
     *   data: {
     *     // ... data to create a FiscalObligation
     *   }
     * })
     * 
     */
    create<T extends FiscalObligationCreateArgs>(args: SelectSubset<T, FiscalObligationCreateArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FiscalObligations.
     * @param {FiscalObligationCreateManyArgs} args - Arguments to create many FiscalObligations.
     * @example
     * // Create many FiscalObligations
     * const fiscalObligation = await prisma.fiscalObligation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FiscalObligationCreateManyArgs>(args?: SelectSubset<T, FiscalObligationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FiscalObligations and returns the data saved in the database.
     * @param {FiscalObligationCreateManyAndReturnArgs} args - Arguments to create many FiscalObligations.
     * @example
     * // Create many FiscalObligations
     * const fiscalObligation = await prisma.fiscalObligation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FiscalObligations and only return the `id`
     * const fiscalObligationWithIdOnly = await prisma.fiscalObligation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FiscalObligationCreateManyAndReturnArgs>(args?: SelectSubset<T, FiscalObligationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FiscalObligation.
     * @param {FiscalObligationDeleteArgs} args - Arguments to delete one FiscalObligation.
     * @example
     * // Delete one FiscalObligation
     * const FiscalObligation = await prisma.fiscalObligation.delete({
     *   where: {
     *     // ... filter to delete one FiscalObligation
     *   }
     * })
     * 
     */
    delete<T extends FiscalObligationDeleteArgs>(args: SelectSubset<T, FiscalObligationDeleteArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FiscalObligation.
     * @param {FiscalObligationUpdateArgs} args - Arguments to update one FiscalObligation.
     * @example
     * // Update one FiscalObligation
     * const fiscalObligation = await prisma.fiscalObligation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FiscalObligationUpdateArgs>(args: SelectSubset<T, FiscalObligationUpdateArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FiscalObligations.
     * @param {FiscalObligationDeleteManyArgs} args - Arguments to filter FiscalObligations to delete.
     * @example
     * // Delete a few FiscalObligations
     * const { count } = await prisma.fiscalObligation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FiscalObligationDeleteManyArgs>(args?: SelectSubset<T, FiscalObligationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalObligations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalObligations
     * const fiscalObligation = await prisma.fiscalObligation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FiscalObligationUpdateManyArgs>(args: SelectSubset<T, FiscalObligationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalObligations and returns the data updated in the database.
     * @param {FiscalObligationUpdateManyAndReturnArgs} args - Arguments to update many FiscalObligations.
     * @example
     * // Update many FiscalObligations
     * const fiscalObligation = await prisma.fiscalObligation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FiscalObligations and only return the `id`
     * const fiscalObligationWithIdOnly = await prisma.fiscalObligation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FiscalObligationUpdateManyAndReturnArgs>(args: SelectSubset<T, FiscalObligationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FiscalObligation.
     * @param {FiscalObligationUpsertArgs} args - Arguments to update or create a FiscalObligation.
     * @example
     * // Update or create a FiscalObligation
     * const fiscalObligation = await prisma.fiscalObligation.upsert({
     *   create: {
     *     // ... data to create a FiscalObligation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalObligation we want to update
     *   }
     * })
     */
    upsert<T extends FiscalObligationUpsertArgs>(args: SelectSubset<T, FiscalObligationUpsertArgs<ExtArgs>>): Prisma__FiscalObligationClient<$Result.GetResult<Prisma.$FiscalObligationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FiscalObligations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationCountArgs} args - Arguments to filter FiscalObligations to count.
     * @example
     * // Count the number of FiscalObligations
     * const count = await prisma.fiscalObligation.count({
     *   where: {
     *     // ... the filter for the FiscalObligations we want to count
     *   }
     * })
    **/
    count<T extends FiscalObligationCountArgs>(
      args?: Subset<T, FiscalObligationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalObligationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalObligation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalObligationAggregateArgs>(args: Subset<T, FiscalObligationAggregateArgs>): Prisma.PrismaPromise<GetFiscalObligationAggregateType<T>>

    /**
     * Group by FiscalObligation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalObligationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiscalObligationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiscalObligationGroupByArgs['orderBy'] }
        : { orderBy?: FiscalObligationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiscalObligationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalObligationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiscalObligation model
   */
  readonly fields: FiscalObligationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiscalObligation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiscalObligationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FiscalObligation model
   */
  interface FiscalObligationFieldRefs {
    readonly id: FieldRef<"FiscalObligation", 'String'>
    readonly userId: FieldRef<"FiscalObligation", 'String'>
    readonly title: FieldRef<"FiscalObligation", 'String'>
    readonly description: FieldRef<"FiscalObligation", 'String'>
    readonly type: FieldRef<"FiscalObligation", 'String'>
    readonly status: FieldRef<"FiscalObligation", 'String'>
    readonly amount: FieldRef<"FiscalObligation", 'Float'>
    readonly currency: FieldRef<"FiscalObligation", 'String'>
    readonly dueDate: FieldRef<"FiscalObligation", 'DateTime'>
    readonly taxCode: FieldRef<"FiscalObligation", 'String'>
    readonly taxName: FieldRef<"FiscalObligation", 'String'>
    readonly taxType: FieldRef<"FiscalObligation", 'String'>
    readonly taxPeriod: FieldRef<"FiscalObligation", 'String'>
    readonly taxBase: FieldRef<"FiscalObligation", 'Float'>
    readonly taxRate: FieldRef<"FiscalObligation", 'Float'>
    readonly taxValue: FieldRef<"FiscalObligation", 'Float'>
    readonly taxInterest: FieldRef<"FiscalObligation", 'Float'>
    readonly taxFine: FieldRef<"FiscalObligation", 'Float'>
    readonly taxTotal: FieldRef<"FiscalObligation", 'Float'>
    readonly createdAt: FieldRef<"FiscalObligation", 'DateTime'>
    readonly updatedAt: FieldRef<"FiscalObligation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FiscalObligation findUnique
   */
  export type FiscalObligationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * Filter, which FiscalObligation to fetch.
     */
    where: FiscalObligationWhereUniqueInput
  }

  /**
   * FiscalObligation findUniqueOrThrow
   */
  export type FiscalObligationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * Filter, which FiscalObligation to fetch.
     */
    where: FiscalObligationWhereUniqueInput
  }

  /**
   * FiscalObligation findFirst
   */
  export type FiscalObligationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * Filter, which FiscalObligation to fetch.
     */
    where?: FiscalObligationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalObligations to fetch.
     */
    orderBy?: FiscalObligationOrderByWithRelationInput | FiscalObligationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalObligations.
     */
    cursor?: FiscalObligationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalObligations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalObligations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalObligations.
     */
    distinct?: FiscalObligationScalarFieldEnum | FiscalObligationScalarFieldEnum[]
  }

  /**
   * FiscalObligation findFirstOrThrow
   */
  export type FiscalObligationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * Filter, which FiscalObligation to fetch.
     */
    where?: FiscalObligationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalObligations to fetch.
     */
    orderBy?: FiscalObligationOrderByWithRelationInput | FiscalObligationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalObligations.
     */
    cursor?: FiscalObligationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalObligations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalObligations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalObligations.
     */
    distinct?: FiscalObligationScalarFieldEnum | FiscalObligationScalarFieldEnum[]
  }

  /**
   * FiscalObligation findMany
   */
  export type FiscalObligationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * Filter, which FiscalObligations to fetch.
     */
    where?: FiscalObligationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalObligations to fetch.
     */
    orderBy?: FiscalObligationOrderByWithRelationInput | FiscalObligationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiscalObligations.
     */
    cursor?: FiscalObligationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalObligations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalObligations.
     */
    skip?: number
    distinct?: FiscalObligationScalarFieldEnum | FiscalObligationScalarFieldEnum[]
  }

  /**
   * FiscalObligation create
   */
  export type FiscalObligationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * The data needed to create a FiscalObligation.
     */
    data: XOR<FiscalObligationCreateInput, FiscalObligationUncheckedCreateInput>
  }

  /**
   * FiscalObligation createMany
   */
  export type FiscalObligationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiscalObligations.
     */
    data: FiscalObligationCreateManyInput | FiscalObligationCreateManyInput[]
  }

  /**
   * FiscalObligation createManyAndReturn
   */
  export type FiscalObligationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * The data used to create many FiscalObligations.
     */
    data: FiscalObligationCreateManyInput | FiscalObligationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FiscalObligation update
   */
  export type FiscalObligationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * The data needed to update a FiscalObligation.
     */
    data: XOR<FiscalObligationUpdateInput, FiscalObligationUncheckedUpdateInput>
    /**
     * Choose, which FiscalObligation to update.
     */
    where: FiscalObligationWhereUniqueInput
  }

  /**
   * FiscalObligation updateMany
   */
  export type FiscalObligationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiscalObligations.
     */
    data: XOR<FiscalObligationUpdateManyMutationInput, FiscalObligationUncheckedUpdateManyInput>
    /**
     * Filter which FiscalObligations to update
     */
    where?: FiscalObligationWhereInput
    /**
     * Limit how many FiscalObligations to update.
     */
    limit?: number
  }

  /**
   * FiscalObligation updateManyAndReturn
   */
  export type FiscalObligationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * The data used to update FiscalObligations.
     */
    data: XOR<FiscalObligationUpdateManyMutationInput, FiscalObligationUncheckedUpdateManyInput>
    /**
     * Filter which FiscalObligations to update
     */
    where?: FiscalObligationWhereInput
    /**
     * Limit how many FiscalObligations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FiscalObligation upsert
   */
  export type FiscalObligationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * The filter to search for the FiscalObligation to update in case it exists.
     */
    where: FiscalObligationWhereUniqueInput
    /**
     * In case the FiscalObligation found by the `where` argument doesn't exist, create a new FiscalObligation with this data.
     */
    create: XOR<FiscalObligationCreateInput, FiscalObligationUncheckedCreateInput>
    /**
     * In case the FiscalObligation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiscalObligationUpdateInput, FiscalObligationUncheckedUpdateInput>
  }

  /**
   * FiscalObligation delete
   */
  export type FiscalObligationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
    /**
     * Filter which FiscalObligation to delete.
     */
    where: FiscalObligationWhereUniqueInput
  }

  /**
   * FiscalObligation deleteMany
   */
  export type FiscalObligationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalObligations to delete
     */
    where?: FiscalObligationWhereInput
    /**
     * Limit how many FiscalObligations to delete.
     */
    limit?: number
  }

  /**
   * FiscalObligation without action
   */
  export type FiscalObligationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalObligation
     */
    select?: FiscalObligationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalObligation
     */
    omit?: FiscalObligationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalObligationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    id: 'id',
    razaoSocial: 'razaoSocial',
    nomeFantasia: 'nomeFantasia',
    cnpj: 'cnpj',
    inscEstadual: 'inscEstadual',
    inscMunicipal: 'inscMunicipal',
    endereco: 'endereco',
    telefone: 'telefone',
    email: 'email',
    website: 'website',
    status: 'status',
    representantePrincipalId: 'representantePrincipalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const CreditTitleScalarFieldEnum: {
    id: 'id',
    category: 'category',
    valueNominal: 'valueNominal',
    valueCurrent: 'valueCurrent',
    issueDate: 'issueDate',
    expiryDate: 'expiryDate',
    issuerId: 'issuerId',
    ownerId: 'ownerId',
    status: 'status',
    tokenId: 'tokenId',
    tokenStandard: 'tokenStandard',
    blockchainTxHash: 'blockchainTxHash',
    isListed: 'isListed',
    listingPrice: 'listingPrice',
    listingDate: 'listingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreditTitleScalarFieldEnum = (typeof CreditTitleScalarFieldEnum)[keyof typeof CreditTitleScalarFieldEnum]


  export const CreditTitleTributarioScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subTypeFederal: 'subTypeFederal',
    subTypeEstadual: 'subTypeEstadual',
    subTypeMunicipal: 'subTypeMunicipal',
    esfera: 'esfera',
    nomeTributo: 'nomeTributo',
    periodoApuracaoInicio: 'periodoApuracaoInicio',
    periodoApuracaoFim: 'periodoApuracaoFim',
    numeroProcessoAdministrativo: 'numeroProcessoAdministrativo',
    numeroProcessoJudicial: 'numeroProcessoJudicial'
  };

  export type CreditTitleTributarioScalarFieldEnum = (typeof CreditTitleTributarioScalarFieldEnum)[keyof typeof CreditTitleTributarioScalarFieldEnum]


  export const CreditTitleComercialScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    sacadoNome: 'sacadoNome',
    sacadoDocumento: 'sacadoDocumento'
  };

  export type CreditTitleComercialScalarFieldEnum = (typeof CreditTitleComercialScalarFieldEnum)[keyof typeof CreditTitleComercialScalarFieldEnum]


  export const CreditTitleFinanceiroScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    indexador: 'indexador',
    taxaJurosAnual: 'taxaJurosAnual',
    rating: 'rating'
  };

  export type CreditTitleFinanceiroScalarFieldEnum = (typeof CreditTitleFinanceiroScalarFieldEnum)[keyof typeof CreditTitleFinanceiroScalarFieldEnum]


  export const CreditTitleJudicialScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    numeroProcesso: 'numeroProcesso',
    tribunalOrigem: 'tribunalOrigem',
    varaOrigem: 'varaOrigem',
    natureza: 'natureza',
    enteDevedor: 'enteDevedor'
  };

  export type CreditTitleJudicialScalarFieldEnum = (typeof CreditTitleJudicialScalarFieldEnum)[keyof typeof CreditTitleJudicialScalarFieldEnum]


  export const CreditTitleRuralScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    safra: 'safra',
    produtoAgricola: 'produtoAgricola',
    areaFinanciadaHectares: 'areaFinanciadaHectares',
    registroImovelRural: 'registroImovelRural'
  };

  export type CreditTitleRuralScalarFieldEnum = (typeof CreditTitleRuralScalarFieldEnum)[keyof typeof CreditTitleRuralScalarFieldEnum]


  export const CreditTitleImobiliarioScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    matriculaImovel: 'matriculaImovel',
    enderecoLogradouro: 'enderecoLogradouro',
    enderecoNumero: 'enderecoNumero',
    enderecoComplemento: 'enderecoComplemento',
    enderecoBairro: 'enderecoBairro',
    enderecoCidade: 'enderecoCidade',
    enderecoEstado: 'enderecoEstado',
    enderecoCep: 'enderecoCep',
    tipoGarantia: 'tipoGarantia'
  };

  export type CreditTitleImobiliarioScalarFieldEnum = (typeof CreditTitleImobiliarioScalarFieldEnum)[keyof typeof CreditTitleImobiliarioScalarFieldEnum]


  export const CreditTitleAmbientalScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    projetoVinculado: 'projetoVinculado',
    metodologiaCertificacao: 'metodologiaCertificacao',
    toneladasCO2Equivalente: 'toneladasCO2Equivalente',
    hectaresConservados: 'hectaresConservados',
    volumeAguaEconomizadoM3: 'volumeAguaEconomizadoM3'
  };

  export type CreditTitleAmbientalScalarFieldEnum = (typeof CreditTitleAmbientalScalarFieldEnum)[keyof typeof CreditTitleAmbientalScalarFieldEnum]


  export const CreditTitleEspecialScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    subType: 'subType',
    processoRecuperacaoJudicial: 'processoRecuperacaoJudicial',
    credorOriginal: 'credorOriginal',
    classeCreditoRJ: 'classeCreditoRJ',
    administradoraConsorcio: 'administradoraConsorcio',
    grupoConsorcio: 'grupoConsorcio',
    cotaConsorcio: 'cotaConsorcio'
  };

  export type CreditTitleEspecialScalarFieldEnum = (typeof CreditTitleEspecialScalarFieldEnum)[keyof typeof CreditTitleEspecialScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    isPublic: 'isPublic',
    mimeType: 'mimeType',
    size: 'size',
    storageLocation: 'storageLocation',
    hash: 'hash',
    creditTitleId: 'creditTitleId',
    uploadedById: 'uploadedById',
    uploadedAt: 'uploadedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    sellerId: 'sellerId',
    price: 'price',
    expiryDate: 'expiryDate',
    terms: 'terms',
    quantityAvailable: 'quantityAvailable',
    offerType: 'offerType',
    minBidIncrement: 'minBidIncrement',
    reservePrice: 'reservePrice',
    allowPartialPurchase: 'allowPartialPurchase',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const BidScalarFieldEnum: {
    id: 'id',
    offerId: 'offerId',
    bidderId: 'bidderId',
    amount: 'amount',
    quantity: 'quantity',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BidScalarFieldEnum = (typeof BidScalarFieldEnum)[keyof typeof BidScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    creditTitleId: 'creditTitleId',
    sellerId: 'sellerId',
    buyerId: 'buyerId',
    price: 'price',
    quantity: 'quantity',
    offerId: 'offerId',
    bidId: 'bidId',
    type: 'type',
    status: 'status',
    notes: 'notes',
    blockchainData: 'blockchainData',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const AuctionScalarFieldEnum: {
    id: 'id',
    creditId: 'creditId',
    sellerId: 'sellerId',
    type: 'type',
    startPrice: 'startPrice',
    minPrice: 'minPrice',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    winnerId: 'winnerId',
    finalPrice: 'finalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuctionScalarFieldEnum = (typeof AuctionScalarFieldEnum)[keyof typeof AuctionScalarFieldEnum]


  export const SettlementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    totalValue: 'totalValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettlementScalarFieldEnum = (typeof SettlementScalarFieldEnum)[keyof typeof SettlementScalarFieldEnum]


  export const SettlementParticipantScalarFieldEnum: {
    id: 'id',
    settlementId: 'settlementId',
    userId: 'userId',
    role: 'role',
    value: 'value',
    status: 'status'
  };

  export type SettlementParticipantScalarFieldEnum = (typeof SettlementParticipantScalarFieldEnum)[keyof typeof SettlementParticipantScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const FiscalObligationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    amount: 'amount',
    currency: 'currency',
    dueDate: 'dueDate',
    taxCode: 'taxCode',
    taxName: 'taxName',
    taxType: 'taxType',
    taxPeriod: 'taxPeriod',
    taxBase: 'taxBase',
    taxRate: 'taxRate',
    taxValue: 'taxValue',
    taxInterest: 'taxInterest',
    taxFine: 'taxFine',
    taxTotal: 'taxTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FiscalObligationScalarFieldEnum = (typeof FiscalObligationScalarFieldEnum)[keyof typeof FiscalObligationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'CreditCategory'
   */
  export type EnumCreditCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditCategory'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'CreditStatus'
   */
  export type EnumCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditStatus'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TCTributarioFederal'
   */
  export type EnumTCTributarioFederalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCTributarioFederal'>
    


  /**
   * Reference to a field of type 'TCTributarioEstadual'
   */
  export type EnumTCTributarioEstadualFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCTributarioEstadual'>
    


  /**
   * Reference to a field of type 'TCTributarioMunicipal'
   */
  export type EnumTCTributarioMunicipalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCTributarioMunicipal'>
    


  /**
   * Reference to a field of type 'TCComercial'
   */
  export type EnumTCComercialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCComercial'>
    


  /**
   * Reference to a field of type 'TCFinanceiro'
   */
  export type EnumTCFinanceiroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCFinanceiro'>
    


  /**
   * Reference to a field of type 'TCJudicial'
   */
  export type EnumTCJudicialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCJudicial'>
    


  /**
   * Reference to a field of type 'TCRural'
   */
  export type EnumTCRuralFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCRural'>
    


  /**
   * Reference to a field of type 'TCImobiliario'
   */
  export type EnumTCImobiliarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCImobiliario'>
    


  /**
   * Reference to a field of type 'TCAmbiental'
   */
  export type EnumTCAmbientalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCAmbiental'>
    


  /**
   * Reference to a field of type 'TCEspecial'
   */
  export type EnumTCEspecialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TCEspecial'>
    


  /**
   * Reference to a field of type 'OfferType'
   */
  export type EnumOfferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferType'>
    


  /**
   * Reference to a field of type 'OfferStatus'
   */
  export type EnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus'>
    


  /**
   * Reference to a field of type 'BidStatus'
   */
  export type EnumBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidStatus'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    issuedCredits?: CreditTitleListRelationFilter
    ownedCredits?: CreditTitleListRelationFilter
    documents?: DocumentListRelationFilter
    offers?: OfferListRelationFilter
    bids?: BidListRelationFilter
    transactionsAsSeller?: TransactionListRelationFilter
    transactionsAsBuyer?: TransactionListRelationFilter
    createdTransactions?: TransactionListRelationFilter
    auctionsAsSeller?: AuctionListRelationFilter
    auctionsAsWinner?: AuctionListRelationFilter
    settlementParticipants?: SettlementParticipantListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    fiscalObligations?: FiscalObligationListRelationFilter
    empresasRepresentadas?: EmpresaListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    issuedCredits?: CreditTitleOrderByRelationAggregateInput
    ownedCredits?: CreditTitleOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    bids?: BidOrderByRelationAggregateInput
    transactionsAsSeller?: TransactionOrderByRelationAggregateInput
    transactionsAsBuyer?: TransactionOrderByRelationAggregateInput
    createdTransactions?: TransactionOrderByRelationAggregateInput
    auctionsAsSeller?: AuctionOrderByRelationAggregateInput
    auctionsAsWinner?: AuctionOrderByRelationAggregateInput
    settlementParticipants?: SettlementParticipantOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    fiscalObligations?: FiscalObligationOrderByRelationAggregateInput
    empresasRepresentadas?: EmpresaOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    issuedCredits?: CreditTitleListRelationFilter
    ownedCredits?: CreditTitleListRelationFilter
    documents?: DocumentListRelationFilter
    offers?: OfferListRelationFilter
    bids?: BidListRelationFilter
    transactionsAsSeller?: TransactionListRelationFilter
    transactionsAsBuyer?: TransactionListRelationFilter
    createdTransactions?: TransactionListRelationFilter
    auctionsAsSeller?: AuctionListRelationFilter
    auctionsAsWinner?: AuctionListRelationFilter
    settlementParticipants?: SettlementParticipantListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    fiscalObligations?: FiscalObligationListRelationFilter
    empresasRepresentadas?: EmpresaListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id?: StringFilter<"Empresa"> | string
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    cnpj?: StringFilter<"Empresa"> | string
    inscEstadual?: StringNullableFilter<"Empresa"> | string | null
    inscMunicipal?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    website?: StringNullableFilter<"Empresa"> | string | null
    status?: StringFilter<"Empresa"> | string
    representantePrincipalId?: StringFilter<"Empresa"> | string
    createdAt?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
    representantePrincipal?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmpresaOrderByWithRelationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    cnpj?: SortOrder
    inscEstadual?: SortOrderInput | SortOrder
    inscMunicipal?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    status?: SortOrder
    representantePrincipalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    representantePrincipal?: UserOrderByWithRelationInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    email?: string
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    inscEstadual?: StringNullableFilter<"Empresa"> | string | null
    inscMunicipal?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    website?: StringNullableFilter<"Empresa"> | string | null
    status?: StringFilter<"Empresa"> | string
    representantePrincipalId?: StringFilter<"Empresa"> | string
    createdAt?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
    representantePrincipal?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "cnpj" | "email">

  export type EmpresaOrderByWithAggregationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    cnpj?: SortOrder
    inscEstadual?: SortOrderInput | SortOrder
    inscMunicipal?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    status?: SortOrder
    representantePrincipalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Empresa"> | string
    razaoSocial?: StringWithAggregatesFilter<"Empresa"> | string
    nomeFantasia?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cnpj?: StringWithAggregatesFilter<"Empresa"> | string
    inscEstadual?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    inscMunicipal?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    endereco?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    email?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    website?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    status?: StringWithAggregatesFilter<"Empresa"> | string
    representantePrincipalId?: StringWithAggregatesFilter<"Empresa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type CreditTitleWhereInput = {
    AND?: CreditTitleWhereInput | CreditTitleWhereInput[]
    OR?: CreditTitleWhereInput[]
    NOT?: CreditTitleWhereInput | CreditTitleWhereInput[]
    id?: StringFilter<"CreditTitle"> | string
    category?: EnumCreditCategoryFilter<"CreditTitle"> | $Enums.CreditCategory
    valueNominal?: FloatFilter<"CreditTitle"> | number
    valueCurrent?: FloatFilter<"CreditTitle"> | number
    issueDate?: DateTimeFilter<"CreditTitle"> | Date | string
    expiryDate?: DateTimeNullableFilter<"CreditTitle"> | Date | string | null
    issuerId?: StringFilter<"CreditTitle"> | string
    ownerId?: StringFilter<"CreditTitle"> | string
    status?: EnumCreditStatusFilter<"CreditTitle"> | $Enums.CreditStatus
    tokenId?: StringNullableFilter<"CreditTitle"> | string | null
    tokenStandard?: StringNullableFilter<"CreditTitle"> | string | null
    blockchainTxHash?: StringNullableFilter<"CreditTitle"> | string | null
    isListed?: BoolFilter<"CreditTitle"> | boolean
    listingPrice?: FloatNullableFilter<"CreditTitle"> | number | null
    listingDate?: DateTimeNullableFilter<"CreditTitle"> | Date | string | null
    createdAt?: DateTimeFilter<"CreditTitle"> | Date | string
    updatedAt?: DateTimeFilter<"CreditTitle"> | Date | string
    issuer?: XOR<UserScalarRelationFilter, UserWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    detailsTributario?: XOR<CreditTitleTributarioNullableScalarRelationFilter, CreditTitleTributarioWhereInput> | null
    detailsComercial?: XOR<CreditTitleComercialNullableScalarRelationFilter, CreditTitleComercialWhereInput> | null
    detailsFinanceiro?: XOR<CreditTitleFinanceiroNullableScalarRelationFilter, CreditTitleFinanceiroWhereInput> | null
    detailsJudicial?: XOR<CreditTitleJudicialNullableScalarRelationFilter, CreditTitleJudicialWhereInput> | null
    detailsRural?: XOR<CreditTitleRuralNullableScalarRelationFilter, CreditTitleRuralWhereInput> | null
    detailsImobiliario?: XOR<CreditTitleImobiliarioNullableScalarRelationFilter, CreditTitleImobiliarioWhereInput> | null
    detailsAmbiental?: XOR<CreditTitleAmbientalNullableScalarRelationFilter, CreditTitleAmbientalWhereInput> | null
    detailsEspecial?: XOR<CreditTitleEspecialNullableScalarRelationFilter, CreditTitleEspecialWhereInput> | null
    documents?: DocumentListRelationFilter
    offers?: OfferListRelationFilter
    transactions?: TransactionListRelationFilter
    auctions?: AuctionListRelationFilter
  }

  export type CreditTitleOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    issuerId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    tokenStandard?: SortOrderInput | SortOrder
    blockchainTxHash?: SortOrderInput | SortOrder
    isListed?: SortOrder
    listingPrice?: SortOrderInput | SortOrder
    listingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    issuer?: UserOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    detailsTributario?: CreditTitleTributarioOrderByWithRelationInput
    detailsComercial?: CreditTitleComercialOrderByWithRelationInput
    detailsFinanceiro?: CreditTitleFinanceiroOrderByWithRelationInput
    detailsJudicial?: CreditTitleJudicialOrderByWithRelationInput
    detailsRural?: CreditTitleRuralOrderByWithRelationInput
    detailsImobiliario?: CreditTitleImobiliarioOrderByWithRelationInput
    detailsAmbiental?: CreditTitleAmbientalOrderByWithRelationInput
    detailsEspecial?: CreditTitleEspecialOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    auctions?: AuctionOrderByRelationAggregateInput
  }

  export type CreditTitleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenId?: string
    AND?: CreditTitleWhereInput | CreditTitleWhereInput[]
    OR?: CreditTitleWhereInput[]
    NOT?: CreditTitleWhereInput | CreditTitleWhereInput[]
    category?: EnumCreditCategoryFilter<"CreditTitle"> | $Enums.CreditCategory
    valueNominal?: FloatFilter<"CreditTitle"> | number
    valueCurrent?: FloatFilter<"CreditTitle"> | number
    issueDate?: DateTimeFilter<"CreditTitle"> | Date | string
    expiryDate?: DateTimeNullableFilter<"CreditTitle"> | Date | string | null
    issuerId?: StringFilter<"CreditTitle"> | string
    ownerId?: StringFilter<"CreditTitle"> | string
    status?: EnumCreditStatusFilter<"CreditTitle"> | $Enums.CreditStatus
    tokenStandard?: StringNullableFilter<"CreditTitle"> | string | null
    blockchainTxHash?: StringNullableFilter<"CreditTitle"> | string | null
    isListed?: BoolFilter<"CreditTitle"> | boolean
    listingPrice?: FloatNullableFilter<"CreditTitle"> | number | null
    listingDate?: DateTimeNullableFilter<"CreditTitle"> | Date | string | null
    createdAt?: DateTimeFilter<"CreditTitle"> | Date | string
    updatedAt?: DateTimeFilter<"CreditTitle"> | Date | string
    issuer?: XOR<UserScalarRelationFilter, UserWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    detailsTributario?: XOR<CreditTitleTributarioNullableScalarRelationFilter, CreditTitleTributarioWhereInput> | null
    detailsComercial?: XOR<CreditTitleComercialNullableScalarRelationFilter, CreditTitleComercialWhereInput> | null
    detailsFinanceiro?: XOR<CreditTitleFinanceiroNullableScalarRelationFilter, CreditTitleFinanceiroWhereInput> | null
    detailsJudicial?: XOR<CreditTitleJudicialNullableScalarRelationFilter, CreditTitleJudicialWhereInput> | null
    detailsRural?: XOR<CreditTitleRuralNullableScalarRelationFilter, CreditTitleRuralWhereInput> | null
    detailsImobiliario?: XOR<CreditTitleImobiliarioNullableScalarRelationFilter, CreditTitleImobiliarioWhereInput> | null
    detailsAmbiental?: XOR<CreditTitleAmbientalNullableScalarRelationFilter, CreditTitleAmbientalWhereInput> | null
    detailsEspecial?: XOR<CreditTitleEspecialNullableScalarRelationFilter, CreditTitleEspecialWhereInput> | null
    documents?: DocumentListRelationFilter
    offers?: OfferListRelationFilter
    transactions?: TransactionListRelationFilter
    auctions?: AuctionListRelationFilter
  }, "id" | "tokenId">

  export type CreditTitleOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    issuerId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    tokenStandard?: SortOrderInput | SortOrder
    blockchainTxHash?: SortOrderInput | SortOrder
    isListed?: SortOrder
    listingPrice?: SortOrderInput | SortOrder
    listingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreditTitleCountOrderByAggregateInput
    _avg?: CreditTitleAvgOrderByAggregateInput
    _max?: CreditTitleMaxOrderByAggregateInput
    _min?: CreditTitleMinOrderByAggregateInput
    _sum?: CreditTitleSumOrderByAggregateInput
  }

  export type CreditTitleScalarWhereWithAggregatesInput = {
    AND?: CreditTitleScalarWhereWithAggregatesInput | CreditTitleScalarWhereWithAggregatesInput[]
    OR?: CreditTitleScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleScalarWhereWithAggregatesInput | CreditTitleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitle"> | string
    category?: EnumCreditCategoryWithAggregatesFilter<"CreditTitle"> | $Enums.CreditCategory
    valueNominal?: FloatWithAggregatesFilter<"CreditTitle"> | number
    valueCurrent?: FloatWithAggregatesFilter<"CreditTitle"> | number
    issueDate?: DateTimeWithAggregatesFilter<"CreditTitle"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"CreditTitle"> | Date | string | null
    issuerId?: StringWithAggregatesFilter<"CreditTitle"> | string
    ownerId?: StringWithAggregatesFilter<"CreditTitle"> | string
    status?: EnumCreditStatusWithAggregatesFilter<"CreditTitle"> | $Enums.CreditStatus
    tokenId?: StringNullableWithAggregatesFilter<"CreditTitle"> | string | null
    tokenStandard?: StringNullableWithAggregatesFilter<"CreditTitle"> | string | null
    blockchainTxHash?: StringNullableWithAggregatesFilter<"CreditTitle"> | string | null
    isListed?: BoolWithAggregatesFilter<"CreditTitle"> | boolean
    listingPrice?: FloatNullableWithAggregatesFilter<"CreditTitle"> | number | null
    listingDate?: DateTimeNullableWithAggregatesFilter<"CreditTitle"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CreditTitle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreditTitle"> | Date | string
  }

  export type CreditTitleTributarioWhereInput = {
    AND?: CreditTitleTributarioWhereInput | CreditTitleTributarioWhereInput[]
    OR?: CreditTitleTributarioWhereInput[]
    NOT?: CreditTitleTributarioWhereInput | CreditTitleTributarioWhereInput[]
    id?: StringFilter<"CreditTitleTributario"> | string
    creditTitleId?: StringFilter<"CreditTitleTributario"> | string
    subTypeFederal?: EnumTCTributarioFederalNullableFilter<"CreditTitleTributario"> | $Enums.TCTributarioFederal | null
    subTypeEstadual?: EnumTCTributarioEstadualNullableFilter<"CreditTitleTributario"> | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: EnumTCTributarioMunicipalNullableFilter<"CreditTitleTributario"> | $Enums.TCTributarioMunicipal | null
    esfera?: StringFilter<"CreditTitleTributario"> | string
    nomeTributo?: StringFilter<"CreditTitleTributario"> | string
    periodoApuracaoInicio?: DateTimeFilter<"CreditTitleTributario"> | Date | string
    periodoApuracaoFim?: DateTimeFilter<"CreditTitleTributario"> | Date | string
    numeroProcessoAdministrativo?: StringNullableFilter<"CreditTitleTributario"> | string | null
    numeroProcessoJudicial?: StringNullableFilter<"CreditTitleTributario"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleTributarioOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subTypeFederal?: SortOrderInput | SortOrder
    subTypeEstadual?: SortOrderInput | SortOrder
    subTypeMunicipal?: SortOrderInput | SortOrder
    esfera?: SortOrder
    nomeTributo?: SortOrder
    periodoApuracaoInicio?: SortOrder
    periodoApuracaoFim?: SortOrder
    numeroProcessoAdministrativo?: SortOrderInput | SortOrder
    numeroProcessoJudicial?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleTributarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleTributarioWhereInput | CreditTitleTributarioWhereInput[]
    OR?: CreditTitleTributarioWhereInput[]
    NOT?: CreditTitleTributarioWhereInput | CreditTitleTributarioWhereInput[]
    subTypeFederal?: EnumTCTributarioFederalNullableFilter<"CreditTitleTributario"> | $Enums.TCTributarioFederal | null
    subTypeEstadual?: EnumTCTributarioEstadualNullableFilter<"CreditTitleTributario"> | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: EnumTCTributarioMunicipalNullableFilter<"CreditTitleTributario"> | $Enums.TCTributarioMunicipal | null
    esfera?: StringFilter<"CreditTitleTributario"> | string
    nomeTributo?: StringFilter<"CreditTitleTributario"> | string
    periodoApuracaoInicio?: DateTimeFilter<"CreditTitleTributario"> | Date | string
    periodoApuracaoFim?: DateTimeFilter<"CreditTitleTributario"> | Date | string
    numeroProcessoAdministrativo?: StringNullableFilter<"CreditTitleTributario"> | string | null
    numeroProcessoJudicial?: StringNullableFilter<"CreditTitleTributario"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleTributarioOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subTypeFederal?: SortOrderInput | SortOrder
    subTypeEstadual?: SortOrderInput | SortOrder
    subTypeMunicipal?: SortOrderInput | SortOrder
    esfera?: SortOrder
    nomeTributo?: SortOrder
    periodoApuracaoInicio?: SortOrder
    periodoApuracaoFim?: SortOrder
    numeroProcessoAdministrativo?: SortOrderInput | SortOrder
    numeroProcessoJudicial?: SortOrderInput | SortOrder
    _count?: CreditTitleTributarioCountOrderByAggregateInput
    _max?: CreditTitleTributarioMaxOrderByAggregateInput
    _min?: CreditTitleTributarioMinOrderByAggregateInput
  }

  export type CreditTitleTributarioScalarWhereWithAggregatesInput = {
    AND?: CreditTitleTributarioScalarWhereWithAggregatesInput | CreditTitleTributarioScalarWhereWithAggregatesInput[]
    OR?: CreditTitleTributarioScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleTributarioScalarWhereWithAggregatesInput | CreditTitleTributarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleTributario"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleTributario"> | string
    subTypeFederal?: EnumTCTributarioFederalNullableWithAggregatesFilter<"CreditTitleTributario"> | $Enums.TCTributarioFederal | null
    subTypeEstadual?: EnumTCTributarioEstadualNullableWithAggregatesFilter<"CreditTitleTributario"> | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: EnumTCTributarioMunicipalNullableWithAggregatesFilter<"CreditTitleTributario"> | $Enums.TCTributarioMunicipal | null
    esfera?: StringWithAggregatesFilter<"CreditTitleTributario"> | string
    nomeTributo?: StringWithAggregatesFilter<"CreditTitleTributario"> | string
    periodoApuracaoInicio?: DateTimeWithAggregatesFilter<"CreditTitleTributario"> | Date | string
    periodoApuracaoFim?: DateTimeWithAggregatesFilter<"CreditTitleTributario"> | Date | string
    numeroProcessoAdministrativo?: StringNullableWithAggregatesFilter<"CreditTitleTributario"> | string | null
    numeroProcessoJudicial?: StringNullableWithAggregatesFilter<"CreditTitleTributario"> | string | null
  }

  export type CreditTitleComercialWhereInput = {
    AND?: CreditTitleComercialWhereInput | CreditTitleComercialWhereInput[]
    OR?: CreditTitleComercialWhereInput[]
    NOT?: CreditTitleComercialWhereInput | CreditTitleComercialWhereInput[]
    id?: StringFilter<"CreditTitleComercial"> | string
    creditTitleId?: StringFilter<"CreditTitleComercial"> | string
    subType?: EnumTCComercialFilter<"CreditTitleComercial"> | $Enums.TCComercial
    sacadoNome?: StringFilter<"CreditTitleComercial"> | string
    sacadoDocumento?: StringFilter<"CreditTitleComercial"> | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleComercialOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    sacadoNome?: SortOrder
    sacadoDocumento?: SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleComercialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleComercialWhereInput | CreditTitleComercialWhereInput[]
    OR?: CreditTitleComercialWhereInput[]
    NOT?: CreditTitleComercialWhereInput | CreditTitleComercialWhereInput[]
    subType?: EnumTCComercialFilter<"CreditTitleComercial"> | $Enums.TCComercial
    sacadoNome?: StringFilter<"CreditTitleComercial"> | string
    sacadoDocumento?: StringFilter<"CreditTitleComercial"> | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleComercialOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    sacadoNome?: SortOrder
    sacadoDocumento?: SortOrder
    _count?: CreditTitleComercialCountOrderByAggregateInput
    _max?: CreditTitleComercialMaxOrderByAggregateInput
    _min?: CreditTitleComercialMinOrderByAggregateInput
  }

  export type CreditTitleComercialScalarWhereWithAggregatesInput = {
    AND?: CreditTitleComercialScalarWhereWithAggregatesInput | CreditTitleComercialScalarWhereWithAggregatesInput[]
    OR?: CreditTitleComercialScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleComercialScalarWhereWithAggregatesInput | CreditTitleComercialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleComercial"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleComercial"> | string
    subType?: EnumTCComercialWithAggregatesFilter<"CreditTitleComercial"> | $Enums.TCComercial
    sacadoNome?: StringWithAggregatesFilter<"CreditTitleComercial"> | string
    sacadoDocumento?: StringWithAggregatesFilter<"CreditTitleComercial"> | string
  }

  export type CreditTitleFinanceiroWhereInput = {
    AND?: CreditTitleFinanceiroWhereInput | CreditTitleFinanceiroWhereInput[]
    OR?: CreditTitleFinanceiroWhereInput[]
    NOT?: CreditTitleFinanceiroWhereInput | CreditTitleFinanceiroWhereInput[]
    id?: StringFilter<"CreditTitleFinanceiro"> | string
    creditTitleId?: StringFilter<"CreditTitleFinanceiro"> | string
    subType?: EnumTCFinanceiroFilter<"CreditTitleFinanceiro"> | $Enums.TCFinanceiro
    indexador?: StringNullableFilter<"CreditTitleFinanceiro"> | string | null
    taxaJurosAnual?: FloatNullableFilter<"CreditTitleFinanceiro"> | number | null
    rating?: StringNullableFilter<"CreditTitleFinanceiro"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleFinanceiroOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    indexador?: SortOrderInput | SortOrder
    taxaJurosAnual?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleFinanceiroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleFinanceiroWhereInput | CreditTitleFinanceiroWhereInput[]
    OR?: CreditTitleFinanceiroWhereInput[]
    NOT?: CreditTitleFinanceiroWhereInput | CreditTitleFinanceiroWhereInput[]
    subType?: EnumTCFinanceiroFilter<"CreditTitleFinanceiro"> | $Enums.TCFinanceiro
    indexador?: StringNullableFilter<"CreditTitleFinanceiro"> | string | null
    taxaJurosAnual?: FloatNullableFilter<"CreditTitleFinanceiro"> | number | null
    rating?: StringNullableFilter<"CreditTitleFinanceiro"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleFinanceiroOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    indexador?: SortOrderInput | SortOrder
    taxaJurosAnual?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: CreditTitleFinanceiroCountOrderByAggregateInput
    _avg?: CreditTitleFinanceiroAvgOrderByAggregateInput
    _max?: CreditTitleFinanceiroMaxOrderByAggregateInput
    _min?: CreditTitleFinanceiroMinOrderByAggregateInput
    _sum?: CreditTitleFinanceiroSumOrderByAggregateInput
  }

  export type CreditTitleFinanceiroScalarWhereWithAggregatesInput = {
    AND?: CreditTitleFinanceiroScalarWhereWithAggregatesInput | CreditTitleFinanceiroScalarWhereWithAggregatesInput[]
    OR?: CreditTitleFinanceiroScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleFinanceiroScalarWhereWithAggregatesInput | CreditTitleFinanceiroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleFinanceiro"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleFinanceiro"> | string
    subType?: EnumTCFinanceiroWithAggregatesFilter<"CreditTitleFinanceiro"> | $Enums.TCFinanceiro
    indexador?: StringNullableWithAggregatesFilter<"CreditTitleFinanceiro"> | string | null
    taxaJurosAnual?: FloatNullableWithAggregatesFilter<"CreditTitleFinanceiro"> | number | null
    rating?: StringNullableWithAggregatesFilter<"CreditTitleFinanceiro"> | string | null
  }

  export type CreditTitleJudicialWhereInput = {
    AND?: CreditTitleJudicialWhereInput | CreditTitleJudicialWhereInput[]
    OR?: CreditTitleJudicialWhereInput[]
    NOT?: CreditTitleJudicialWhereInput | CreditTitleJudicialWhereInput[]
    id?: StringFilter<"CreditTitleJudicial"> | string
    creditTitleId?: StringFilter<"CreditTitleJudicial"> | string
    subType?: EnumTCJudicialFilter<"CreditTitleJudicial"> | $Enums.TCJudicial
    numeroProcesso?: StringFilter<"CreditTitleJudicial"> | string
    tribunalOrigem?: StringFilter<"CreditTitleJudicial"> | string
    varaOrigem?: StringNullableFilter<"CreditTitleJudicial"> | string | null
    natureza?: StringFilter<"CreditTitleJudicial"> | string
    enteDevedor?: StringNullableFilter<"CreditTitleJudicial"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleJudicialOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    numeroProcesso?: SortOrder
    tribunalOrigem?: SortOrder
    varaOrigem?: SortOrderInput | SortOrder
    natureza?: SortOrder
    enteDevedor?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleJudicialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleJudicialWhereInput | CreditTitleJudicialWhereInput[]
    OR?: CreditTitleJudicialWhereInput[]
    NOT?: CreditTitleJudicialWhereInput | CreditTitleJudicialWhereInput[]
    subType?: EnumTCJudicialFilter<"CreditTitleJudicial"> | $Enums.TCJudicial
    numeroProcesso?: StringFilter<"CreditTitleJudicial"> | string
    tribunalOrigem?: StringFilter<"CreditTitleJudicial"> | string
    varaOrigem?: StringNullableFilter<"CreditTitleJudicial"> | string | null
    natureza?: StringFilter<"CreditTitleJudicial"> | string
    enteDevedor?: StringNullableFilter<"CreditTitleJudicial"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleJudicialOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    numeroProcesso?: SortOrder
    tribunalOrigem?: SortOrder
    varaOrigem?: SortOrderInput | SortOrder
    natureza?: SortOrder
    enteDevedor?: SortOrderInput | SortOrder
    _count?: CreditTitleJudicialCountOrderByAggregateInput
    _max?: CreditTitleJudicialMaxOrderByAggregateInput
    _min?: CreditTitleJudicialMinOrderByAggregateInput
  }

  export type CreditTitleJudicialScalarWhereWithAggregatesInput = {
    AND?: CreditTitleJudicialScalarWhereWithAggregatesInput | CreditTitleJudicialScalarWhereWithAggregatesInput[]
    OR?: CreditTitleJudicialScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleJudicialScalarWhereWithAggregatesInput | CreditTitleJudicialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleJudicial"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleJudicial"> | string
    subType?: EnumTCJudicialWithAggregatesFilter<"CreditTitleJudicial"> | $Enums.TCJudicial
    numeroProcesso?: StringWithAggregatesFilter<"CreditTitleJudicial"> | string
    tribunalOrigem?: StringWithAggregatesFilter<"CreditTitleJudicial"> | string
    varaOrigem?: StringNullableWithAggregatesFilter<"CreditTitleJudicial"> | string | null
    natureza?: StringWithAggregatesFilter<"CreditTitleJudicial"> | string
    enteDevedor?: StringNullableWithAggregatesFilter<"CreditTitleJudicial"> | string | null
  }

  export type CreditTitleRuralWhereInput = {
    AND?: CreditTitleRuralWhereInput | CreditTitleRuralWhereInput[]
    OR?: CreditTitleRuralWhereInput[]
    NOT?: CreditTitleRuralWhereInput | CreditTitleRuralWhereInput[]
    id?: StringFilter<"CreditTitleRural"> | string
    creditTitleId?: StringFilter<"CreditTitleRural"> | string
    subType?: EnumTCRuralFilter<"CreditTitleRural"> | $Enums.TCRural
    safra?: StringNullableFilter<"CreditTitleRural"> | string | null
    produtoAgricola?: StringNullableFilter<"CreditTitleRural"> | string | null
    areaFinanciadaHectares?: FloatNullableFilter<"CreditTitleRural"> | number | null
    registroImovelRural?: StringNullableFilter<"CreditTitleRural"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleRuralOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    safra?: SortOrderInput | SortOrder
    produtoAgricola?: SortOrderInput | SortOrder
    areaFinanciadaHectares?: SortOrderInput | SortOrder
    registroImovelRural?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleRuralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleRuralWhereInput | CreditTitleRuralWhereInput[]
    OR?: CreditTitleRuralWhereInput[]
    NOT?: CreditTitleRuralWhereInput | CreditTitleRuralWhereInput[]
    subType?: EnumTCRuralFilter<"CreditTitleRural"> | $Enums.TCRural
    safra?: StringNullableFilter<"CreditTitleRural"> | string | null
    produtoAgricola?: StringNullableFilter<"CreditTitleRural"> | string | null
    areaFinanciadaHectares?: FloatNullableFilter<"CreditTitleRural"> | number | null
    registroImovelRural?: StringNullableFilter<"CreditTitleRural"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleRuralOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    safra?: SortOrderInput | SortOrder
    produtoAgricola?: SortOrderInput | SortOrder
    areaFinanciadaHectares?: SortOrderInput | SortOrder
    registroImovelRural?: SortOrderInput | SortOrder
    _count?: CreditTitleRuralCountOrderByAggregateInput
    _avg?: CreditTitleRuralAvgOrderByAggregateInput
    _max?: CreditTitleRuralMaxOrderByAggregateInput
    _min?: CreditTitleRuralMinOrderByAggregateInput
    _sum?: CreditTitleRuralSumOrderByAggregateInput
  }

  export type CreditTitleRuralScalarWhereWithAggregatesInput = {
    AND?: CreditTitleRuralScalarWhereWithAggregatesInput | CreditTitleRuralScalarWhereWithAggregatesInput[]
    OR?: CreditTitleRuralScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleRuralScalarWhereWithAggregatesInput | CreditTitleRuralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleRural"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleRural"> | string
    subType?: EnumTCRuralWithAggregatesFilter<"CreditTitleRural"> | $Enums.TCRural
    safra?: StringNullableWithAggregatesFilter<"CreditTitleRural"> | string | null
    produtoAgricola?: StringNullableWithAggregatesFilter<"CreditTitleRural"> | string | null
    areaFinanciadaHectares?: FloatNullableWithAggregatesFilter<"CreditTitleRural"> | number | null
    registroImovelRural?: StringNullableWithAggregatesFilter<"CreditTitleRural"> | string | null
  }

  export type CreditTitleImobiliarioWhereInput = {
    AND?: CreditTitleImobiliarioWhereInput | CreditTitleImobiliarioWhereInput[]
    OR?: CreditTitleImobiliarioWhereInput[]
    NOT?: CreditTitleImobiliarioWhereInput | CreditTitleImobiliarioWhereInput[]
    id?: StringFilter<"CreditTitleImobiliario"> | string
    creditTitleId?: StringFilter<"CreditTitleImobiliario"> | string
    subType?: EnumTCImobiliarioFilter<"CreditTitleImobiliario"> | $Enums.TCImobiliario
    matriculaImovel?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoLogradouro?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoNumero?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoComplemento?: StringNullableFilter<"CreditTitleImobiliario"> | string | null
    enderecoBairro?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoCidade?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoEstado?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoCep?: StringFilter<"CreditTitleImobiliario"> | string
    tipoGarantia?: StringNullableFilter<"CreditTitleImobiliario"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleImobiliarioOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    matriculaImovel?: SortOrder
    enderecoLogradouro?: SortOrder
    enderecoNumero?: SortOrder
    enderecoComplemento?: SortOrderInput | SortOrder
    enderecoBairro?: SortOrder
    enderecoCidade?: SortOrder
    enderecoEstado?: SortOrder
    enderecoCep?: SortOrder
    tipoGarantia?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleImobiliarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleImobiliarioWhereInput | CreditTitleImobiliarioWhereInput[]
    OR?: CreditTitleImobiliarioWhereInput[]
    NOT?: CreditTitleImobiliarioWhereInput | CreditTitleImobiliarioWhereInput[]
    subType?: EnumTCImobiliarioFilter<"CreditTitleImobiliario"> | $Enums.TCImobiliario
    matriculaImovel?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoLogradouro?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoNumero?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoComplemento?: StringNullableFilter<"CreditTitleImobiliario"> | string | null
    enderecoBairro?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoCidade?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoEstado?: StringFilter<"CreditTitleImobiliario"> | string
    enderecoCep?: StringFilter<"CreditTitleImobiliario"> | string
    tipoGarantia?: StringNullableFilter<"CreditTitleImobiliario"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleImobiliarioOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    matriculaImovel?: SortOrder
    enderecoLogradouro?: SortOrder
    enderecoNumero?: SortOrder
    enderecoComplemento?: SortOrderInput | SortOrder
    enderecoBairro?: SortOrder
    enderecoCidade?: SortOrder
    enderecoEstado?: SortOrder
    enderecoCep?: SortOrder
    tipoGarantia?: SortOrderInput | SortOrder
    _count?: CreditTitleImobiliarioCountOrderByAggregateInput
    _max?: CreditTitleImobiliarioMaxOrderByAggregateInput
    _min?: CreditTitleImobiliarioMinOrderByAggregateInput
  }

  export type CreditTitleImobiliarioScalarWhereWithAggregatesInput = {
    AND?: CreditTitleImobiliarioScalarWhereWithAggregatesInput | CreditTitleImobiliarioScalarWhereWithAggregatesInput[]
    OR?: CreditTitleImobiliarioScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleImobiliarioScalarWhereWithAggregatesInput | CreditTitleImobiliarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    subType?: EnumTCImobiliarioWithAggregatesFilter<"CreditTitleImobiliario"> | $Enums.TCImobiliario
    matriculaImovel?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    enderecoLogradouro?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    enderecoNumero?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    enderecoComplemento?: StringNullableWithAggregatesFilter<"CreditTitleImobiliario"> | string | null
    enderecoBairro?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    enderecoCidade?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    enderecoEstado?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    enderecoCep?: StringWithAggregatesFilter<"CreditTitleImobiliario"> | string
    tipoGarantia?: StringNullableWithAggregatesFilter<"CreditTitleImobiliario"> | string | null
  }

  export type CreditTitleAmbientalWhereInput = {
    AND?: CreditTitleAmbientalWhereInput | CreditTitleAmbientalWhereInput[]
    OR?: CreditTitleAmbientalWhereInput[]
    NOT?: CreditTitleAmbientalWhereInput | CreditTitleAmbientalWhereInput[]
    id?: StringFilter<"CreditTitleAmbiental"> | string
    creditTitleId?: StringFilter<"CreditTitleAmbiental"> | string
    subType?: EnumTCAmbientalFilter<"CreditTitleAmbiental"> | $Enums.TCAmbiental
    projetoVinculado?: StringNullableFilter<"CreditTitleAmbiental"> | string | null
    metodologiaCertificacao?: StringNullableFilter<"CreditTitleAmbiental"> | string | null
    toneladasCO2Equivalente?: FloatNullableFilter<"CreditTitleAmbiental"> | number | null
    hectaresConservados?: FloatNullableFilter<"CreditTitleAmbiental"> | number | null
    volumeAguaEconomizadoM3?: FloatNullableFilter<"CreditTitleAmbiental"> | number | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleAmbientalOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    projetoVinculado?: SortOrderInput | SortOrder
    metodologiaCertificacao?: SortOrderInput | SortOrder
    toneladasCO2Equivalente?: SortOrderInput | SortOrder
    hectaresConservados?: SortOrderInput | SortOrder
    volumeAguaEconomizadoM3?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleAmbientalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleAmbientalWhereInput | CreditTitleAmbientalWhereInput[]
    OR?: CreditTitleAmbientalWhereInput[]
    NOT?: CreditTitleAmbientalWhereInput | CreditTitleAmbientalWhereInput[]
    subType?: EnumTCAmbientalFilter<"CreditTitleAmbiental"> | $Enums.TCAmbiental
    projetoVinculado?: StringNullableFilter<"CreditTitleAmbiental"> | string | null
    metodologiaCertificacao?: StringNullableFilter<"CreditTitleAmbiental"> | string | null
    toneladasCO2Equivalente?: FloatNullableFilter<"CreditTitleAmbiental"> | number | null
    hectaresConservados?: FloatNullableFilter<"CreditTitleAmbiental"> | number | null
    volumeAguaEconomizadoM3?: FloatNullableFilter<"CreditTitleAmbiental"> | number | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleAmbientalOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    projetoVinculado?: SortOrderInput | SortOrder
    metodologiaCertificacao?: SortOrderInput | SortOrder
    toneladasCO2Equivalente?: SortOrderInput | SortOrder
    hectaresConservados?: SortOrderInput | SortOrder
    volumeAguaEconomizadoM3?: SortOrderInput | SortOrder
    _count?: CreditTitleAmbientalCountOrderByAggregateInput
    _avg?: CreditTitleAmbientalAvgOrderByAggregateInput
    _max?: CreditTitleAmbientalMaxOrderByAggregateInput
    _min?: CreditTitleAmbientalMinOrderByAggregateInput
    _sum?: CreditTitleAmbientalSumOrderByAggregateInput
  }

  export type CreditTitleAmbientalScalarWhereWithAggregatesInput = {
    AND?: CreditTitleAmbientalScalarWhereWithAggregatesInput | CreditTitleAmbientalScalarWhereWithAggregatesInput[]
    OR?: CreditTitleAmbientalScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleAmbientalScalarWhereWithAggregatesInput | CreditTitleAmbientalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleAmbiental"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleAmbiental"> | string
    subType?: EnumTCAmbientalWithAggregatesFilter<"CreditTitleAmbiental"> | $Enums.TCAmbiental
    projetoVinculado?: StringNullableWithAggregatesFilter<"CreditTitleAmbiental"> | string | null
    metodologiaCertificacao?: StringNullableWithAggregatesFilter<"CreditTitleAmbiental"> | string | null
    toneladasCO2Equivalente?: FloatNullableWithAggregatesFilter<"CreditTitleAmbiental"> | number | null
    hectaresConservados?: FloatNullableWithAggregatesFilter<"CreditTitleAmbiental"> | number | null
    volumeAguaEconomizadoM3?: FloatNullableWithAggregatesFilter<"CreditTitleAmbiental"> | number | null
  }

  export type CreditTitleEspecialWhereInput = {
    AND?: CreditTitleEspecialWhereInput | CreditTitleEspecialWhereInput[]
    OR?: CreditTitleEspecialWhereInput[]
    NOT?: CreditTitleEspecialWhereInput | CreditTitleEspecialWhereInput[]
    id?: StringFilter<"CreditTitleEspecial"> | string
    creditTitleId?: StringFilter<"CreditTitleEspecial"> | string
    subType?: EnumTCEspecialFilter<"CreditTitleEspecial"> | $Enums.TCEspecial
    processoRecuperacaoJudicial?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    credorOriginal?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    classeCreditoRJ?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    administradoraConsorcio?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    grupoConsorcio?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    cotaConsorcio?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }

  export type CreditTitleEspecialOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    processoRecuperacaoJudicial?: SortOrderInput | SortOrder
    credorOriginal?: SortOrderInput | SortOrder
    classeCreditoRJ?: SortOrderInput | SortOrder
    administradoraConsorcio?: SortOrderInput | SortOrder
    grupoConsorcio?: SortOrderInput | SortOrder
    cotaConsorcio?: SortOrderInput | SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
  }

  export type CreditTitleEspecialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditTitleId?: string
    AND?: CreditTitleEspecialWhereInput | CreditTitleEspecialWhereInput[]
    OR?: CreditTitleEspecialWhereInput[]
    NOT?: CreditTitleEspecialWhereInput | CreditTitleEspecialWhereInput[]
    subType?: EnumTCEspecialFilter<"CreditTitleEspecial"> | $Enums.TCEspecial
    processoRecuperacaoJudicial?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    credorOriginal?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    classeCreditoRJ?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    administradoraConsorcio?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    grupoConsorcio?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    cotaConsorcio?: StringNullableFilter<"CreditTitleEspecial"> | string | null
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
  }, "id" | "creditTitleId">

  export type CreditTitleEspecialOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    processoRecuperacaoJudicial?: SortOrderInput | SortOrder
    credorOriginal?: SortOrderInput | SortOrder
    classeCreditoRJ?: SortOrderInput | SortOrder
    administradoraConsorcio?: SortOrderInput | SortOrder
    grupoConsorcio?: SortOrderInput | SortOrder
    cotaConsorcio?: SortOrderInput | SortOrder
    _count?: CreditTitleEspecialCountOrderByAggregateInput
    _max?: CreditTitleEspecialMaxOrderByAggregateInput
    _min?: CreditTitleEspecialMinOrderByAggregateInput
  }

  export type CreditTitleEspecialScalarWhereWithAggregatesInput = {
    AND?: CreditTitleEspecialScalarWhereWithAggregatesInput | CreditTitleEspecialScalarWhereWithAggregatesInput[]
    OR?: CreditTitleEspecialScalarWhereWithAggregatesInput[]
    NOT?: CreditTitleEspecialScalarWhereWithAggregatesInput | CreditTitleEspecialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTitleEspecial"> | string
    creditTitleId?: StringWithAggregatesFilter<"CreditTitleEspecial"> | string
    subType?: EnumTCEspecialWithAggregatesFilter<"CreditTitleEspecial"> | $Enums.TCEspecial
    processoRecuperacaoJudicial?: StringNullableWithAggregatesFilter<"CreditTitleEspecial"> | string | null
    credorOriginal?: StringNullableWithAggregatesFilter<"CreditTitleEspecial"> | string | null
    classeCreditoRJ?: StringNullableWithAggregatesFilter<"CreditTitleEspecial"> | string | null
    administradoraConsorcio?: StringNullableWithAggregatesFilter<"CreditTitleEspecial"> | string | null
    grupoConsorcio?: StringNullableWithAggregatesFilter<"CreditTitleEspecial"> | string | null
    cotaConsorcio?: StringNullableWithAggregatesFilter<"CreditTitleEspecial"> | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    isPublic?: BoolFilter<"Document"> | boolean
    mimeType?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    storageLocation?: StringFilter<"Document"> | string
    hash?: StringNullableFilter<"Document"> | string | null
    creditTitleId?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageLocation?: SortOrder
    hash?: SortOrderInput | SortOrder
    creditTitleId?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    isPublic?: BoolFilter<"Document"> | boolean
    mimeType?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    storageLocation?: StringFilter<"Document"> | string
    hash?: StringNullableFilter<"Document"> | string | null
    creditTitleId?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageLocation?: SortOrder
    hash?: SortOrderInput | SortOrder
    creditTitleId?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Document"> | boolean
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    storageLocation?: StringWithAggregatesFilter<"Document"> | string
    hash?: StringNullableWithAggregatesFilter<"Document"> | string | null
    creditTitleId?: StringWithAggregatesFilter<"Document"> | string
    uploadedById?: StringWithAggregatesFilter<"Document"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    creditTitleId?: StringFilter<"Offer"> | string
    sellerId?: StringFilter<"Offer"> | string
    price?: FloatFilter<"Offer"> | number
    expiryDate?: DateTimeNullableFilter<"Offer"> | Date | string | null
    terms?: StringNullableFilter<"Offer"> | string | null
    quantityAvailable?: IntFilter<"Offer"> | number
    offerType?: EnumOfferTypeFilter<"Offer"> | $Enums.OfferType
    minBidIncrement?: FloatNullableFilter<"Offer"> | number | null
    reservePrice?: FloatNullableFilter<"Offer"> | number | null
    allowPartialPurchase?: BoolFilter<"Offer"> | boolean
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    bids?: BidListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    quantityAvailable?: SortOrder
    offerType?: SortOrder
    minBidIncrement?: SortOrderInput | SortOrder
    reservePrice?: SortOrderInput | SortOrder
    allowPartialPurchase?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
    bids?: BidOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    creditTitleId?: StringFilter<"Offer"> | string
    sellerId?: StringFilter<"Offer"> | string
    price?: FloatFilter<"Offer"> | number
    expiryDate?: DateTimeNullableFilter<"Offer"> | Date | string | null
    terms?: StringNullableFilter<"Offer"> | string | null
    quantityAvailable?: IntFilter<"Offer"> | number
    offerType?: EnumOfferTypeFilter<"Offer"> | $Enums.OfferType
    minBidIncrement?: FloatNullableFilter<"Offer"> | number | null
    reservePrice?: FloatNullableFilter<"Offer"> | number | null
    allowPartialPurchase?: BoolFilter<"Offer"> | boolean
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    bids?: BidListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    quantityAvailable?: SortOrder
    offerType?: SortOrder
    minBidIncrement?: SortOrderInput | SortOrder
    reservePrice?: SortOrderInput | SortOrder
    allowPartialPurchase?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    creditTitleId?: StringWithAggregatesFilter<"Offer"> | string
    sellerId?: StringWithAggregatesFilter<"Offer"> | string
    price?: FloatWithAggregatesFilter<"Offer"> | number
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    terms?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    quantityAvailable?: IntWithAggregatesFilter<"Offer"> | number
    offerType?: EnumOfferTypeWithAggregatesFilter<"Offer"> | $Enums.OfferType
    minBidIncrement?: FloatNullableWithAggregatesFilter<"Offer"> | number | null
    reservePrice?: FloatNullableWithAggregatesFilter<"Offer"> | number | null
    allowPartialPurchase?: BoolWithAggregatesFilter<"Offer"> | boolean
    status?: EnumOfferStatusWithAggregatesFilter<"Offer"> | $Enums.OfferStatus
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
  }

  export type BidWhereInput = {
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    id?: StringFilter<"Bid"> | string
    offerId?: StringFilter<"Bid"> | string
    bidderId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    quantity?: IntFilter<"Bid"> | number
    notes?: StringNullableFilter<"Bid"> | string | null
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
    offer?: XOR<OfferScalarRelationFilter, OfferWhereInput>
    bidder?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type BidOrderByWithRelationInput = {
    id?: SortOrder
    offerId?: SortOrder
    bidderId?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offer?: OfferOrderByWithRelationInput
    bidder?: UserOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type BidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    offerId?: StringFilter<"Bid"> | string
    bidderId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    quantity?: IntFilter<"Bid"> | number
    notes?: StringNullableFilter<"Bid"> | string | null
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
    offer?: XOR<OfferScalarRelationFilter, OfferWhereInput>
    bidder?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id">

  export type BidOrderByWithAggregationInput = {
    id?: SortOrder
    offerId?: SortOrder
    bidderId?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BidCountOrderByAggregateInput
    _avg?: BidAvgOrderByAggregateInput
    _max?: BidMaxOrderByAggregateInput
    _min?: BidMinOrderByAggregateInput
    _sum?: BidSumOrderByAggregateInput
  }

  export type BidScalarWhereWithAggregatesInput = {
    AND?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    OR?: BidScalarWhereWithAggregatesInput[]
    NOT?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bid"> | string
    offerId?: StringWithAggregatesFilter<"Bid"> | string
    bidderId?: StringWithAggregatesFilter<"Bid"> | string
    amount?: FloatWithAggregatesFilter<"Bid"> | number
    quantity?: IntWithAggregatesFilter<"Bid"> | number
    notes?: StringNullableWithAggregatesFilter<"Bid"> | string | null
    status?: EnumBidStatusWithAggregatesFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    creditTitleId?: StringFilter<"Transaction"> | string
    sellerId?: StringFilter<"Transaction"> | string
    buyerId?: StringFilter<"Transaction"> | string
    price?: FloatFilter<"Transaction"> | number
    quantity?: IntFilter<"Transaction"> | number
    offerId?: StringNullableFilter<"Transaction"> | string | null
    bidId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    notes?: StringNullableFilter<"Transaction"> | string | null
    blockchainData?: StringNullableFilter<"Transaction"> | string | null
    createdById?: StringNullableFilter<"Transaction"> | string | null
    updatedById?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
    bid?: XOR<BidNullableScalarRelationFilter, BidWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    offerId?: SortOrderInput | SortOrder
    bidId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    blockchainData?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creditTitle?: CreditTitleOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
    bid?: BidOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    creditTitleId?: StringFilter<"Transaction"> | string
    sellerId?: StringFilter<"Transaction"> | string
    buyerId?: StringFilter<"Transaction"> | string
    price?: FloatFilter<"Transaction"> | number
    quantity?: IntFilter<"Transaction"> | number
    offerId?: StringNullableFilter<"Transaction"> | string | null
    bidId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    notes?: StringNullableFilter<"Transaction"> | string | null
    blockchainData?: StringNullableFilter<"Transaction"> | string | null
    createdById?: StringNullableFilter<"Transaction"> | string | null
    updatedById?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    creditTitle?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
    bid?: XOR<BidNullableScalarRelationFilter, BidWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    offerId?: SortOrderInput | SortOrder
    bidId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    blockchainData?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    creditTitleId?: StringWithAggregatesFilter<"Transaction"> | string
    sellerId?: StringWithAggregatesFilter<"Transaction"> | string
    buyerId?: StringWithAggregatesFilter<"Transaction"> | string
    price?: FloatWithAggregatesFilter<"Transaction"> | number
    quantity?: IntWithAggregatesFilter<"Transaction"> | number
    offerId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    bidId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    blockchainData?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type AuctionWhereInput = {
    AND?: AuctionWhereInput | AuctionWhereInput[]
    OR?: AuctionWhereInput[]
    NOT?: AuctionWhereInput | AuctionWhereInput[]
    id?: StringFilter<"Auction"> | string
    creditId?: StringFilter<"Auction"> | string
    sellerId?: StringFilter<"Auction"> | string
    type?: StringFilter<"Auction"> | string
    startPrice?: FloatFilter<"Auction"> | number
    minPrice?: FloatNullableFilter<"Auction"> | number | null
    startDate?: DateTimeFilter<"Auction"> | Date | string
    endDate?: DateTimeFilter<"Auction"> | Date | string
    status?: StringFilter<"Auction"> | string
    winnerId?: StringNullableFilter<"Auction"> | string | null
    finalPrice?: FloatNullableFilter<"Auction"> | number | null
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    credit?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    winner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuctionOrderByWithRelationInput = {
    id?: SortOrder
    creditId?: SortOrder
    sellerId?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    minPrice?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    credit?: CreditTitleOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
    winner?: UserOrderByWithRelationInput
  }

  export type AuctionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuctionWhereInput | AuctionWhereInput[]
    OR?: AuctionWhereInput[]
    NOT?: AuctionWhereInput | AuctionWhereInput[]
    creditId?: StringFilter<"Auction"> | string
    sellerId?: StringFilter<"Auction"> | string
    type?: StringFilter<"Auction"> | string
    startPrice?: FloatFilter<"Auction"> | number
    minPrice?: FloatNullableFilter<"Auction"> | number | null
    startDate?: DateTimeFilter<"Auction"> | Date | string
    endDate?: DateTimeFilter<"Auction"> | Date | string
    status?: StringFilter<"Auction"> | string
    winnerId?: StringNullableFilter<"Auction"> | string | null
    finalPrice?: FloatNullableFilter<"Auction"> | number | null
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    credit?: XOR<CreditTitleScalarRelationFilter, CreditTitleWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    winner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuctionOrderByWithAggregationInput = {
    id?: SortOrder
    creditId?: SortOrder
    sellerId?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    minPrice?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuctionCountOrderByAggregateInput
    _avg?: AuctionAvgOrderByAggregateInput
    _max?: AuctionMaxOrderByAggregateInput
    _min?: AuctionMinOrderByAggregateInput
    _sum?: AuctionSumOrderByAggregateInput
  }

  export type AuctionScalarWhereWithAggregatesInput = {
    AND?: AuctionScalarWhereWithAggregatesInput | AuctionScalarWhereWithAggregatesInput[]
    OR?: AuctionScalarWhereWithAggregatesInput[]
    NOT?: AuctionScalarWhereWithAggregatesInput | AuctionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Auction"> | string
    creditId?: StringWithAggregatesFilter<"Auction"> | string
    sellerId?: StringWithAggregatesFilter<"Auction"> | string
    type?: StringWithAggregatesFilter<"Auction"> | string
    startPrice?: FloatWithAggregatesFilter<"Auction"> | number
    minPrice?: FloatNullableWithAggregatesFilter<"Auction"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    status?: StringWithAggregatesFilter<"Auction"> | string
    winnerId?: StringNullableWithAggregatesFilter<"Auction"> | string | null
    finalPrice?: FloatNullableWithAggregatesFilter<"Auction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
  }

  export type SettlementWhereInput = {
    AND?: SettlementWhereInput | SettlementWhereInput[]
    OR?: SettlementWhereInput[]
    NOT?: SettlementWhereInput | SettlementWhereInput[]
    id?: StringFilter<"Settlement"> | string
    type?: StringFilter<"Settlement"> | string
    status?: StringFilter<"Settlement"> | string
    totalValue?: FloatFilter<"Settlement"> | number
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
    participants?: SettlementParticipantListRelationFilter
  }

  export type SettlementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: SettlementParticipantOrderByRelationAggregateInput
  }

  export type SettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettlementWhereInput | SettlementWhereInput[]
    OR?: SettlementWhereInput[]
    NOT?: SettlementWhereInput | SettlementWhereInput[]
    type?: StringFilter<"Settlement"> | string
    status?: StringFilter<"Settlement"> | string
    totalValue?: FloatFilter<"Settlement"> | number
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
    participants?: SettlementParticipantListRelationFilter
  }, "id">

  export type SettlementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettlementCountOrderByAggregateInput
    _avg?: SettlementAvgOrderByAggregateInput
    _max?: SettlementMaxOrderByAggregateInput
    _min?: SettlementMinOrderByAggregateInput
    _sum?: SettlementSumOrderByAggregateInput
  }

  export type SettlementScalarWhereWithAggregatesInput = {
    AND?: SettlementScalarWhereWithAggregatesInput | SettlementScalarWhereWithAggregatesInput[]
    OR?: SettlementScalarWhereWithAggregatesInput[]
    NOT?: SettlementScalarWhereWithAggregatesInput | SettlementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settlement"> | string
    type?: StringWithAggregatesFilter<"Settlement"> | string
    status?: StringWithAggregatesFilter<"Settlement"> | string
    totalValue?: FloatWithAggregatesFilter<"Settlement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settlement"> | Date | string
  }

  export type SettlementParticipantWhereInput = {
    AND?: SettlementParticipantWhereInput | SettlementParticipantWhereInput[]
    OR?: SettlementParticipantWhereInput[]
    NOT?: SettlementParticipantWhereInput | SettlementParticipantWhereInput[]
    id?: StringFilter<"SettlementParticipant"> | string
    settlementId?: StringFilter<"SettlementParticipant"> | string
    userId?: StringFilter<"SettlementParticipant"> | string
    role?: StringFilter<"SettlementParticipant"> | string
    value?: FloatFilter<"SettlementParticipant"> | number
    status?: StringFilter<"SettlementParticipant"> | string
    settlement?: XOR<SettlementScalarRelationFilter, SettlementWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SettlementParticipantOrderByWithRelationInput = {
    id?: SortOrder
    settlementId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    value?: SortOrder
    status?: SortOrder
    settlement?: SettlementOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SettlementParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettlementParticipantWhereInput | SettlementParticipantWhereInput[]
    OR?: SettlementParticipantWhereInput[]
    NOT?: SettlementParticipantWhereInput | SettlementParticipantWhereInput[]
    settlementId?: StringFilter<"SettlementParticipant"> | string
    userId?: StringFilter<"SettlementParticipant"> | string
    role?: StringFilter<"SettlementParticipant"> | string
    value?: FloatFilter<"SettlementParticipant"> | number
    status?: StringFilter<"SettlementParticipant"> | string
    settlement?: XOR<SettlementScalarRelationFilter, SettlementWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SettlementParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    settlementId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    value?: SortOrder
    status?: SortOrder
    _count?: SettlementParticipantCountOrderByAggregateInput
    _avg?: SettlementParticipantAvgOrderByAggregateInput
    _max?: SettlementParticipantMaxOrderByAggregateInput
    _min?: SettlementParticipantMinOrderByAggregateInput
    _sum?: SettlementParticipantSumOrderByAggregateInput
  }

  export type SettlementParticipantScalarWhereWithAggregatesInput = {
    AND?: SettlementParticipantScalarWhereWithAggregatesInput | SettlementParticipantScalarWhereWithAggregatesInput[]
    OR?: SettlementParticipantScalarWhereWithAggregatesInput[]
    NOT?: SettlementParticipantScalarWhereWithAggregatesInput | SettlementParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SettlementParticipant"> | string
    settlementId?: StringWithAggregatesFilter<"SettlementParticipant"> | string
    userId?: StringWithAggregatesFilter<"SettlementParticipant"> | string
    role?: StringWithAggregatesFilter<"SettlementParticipant"> | string
    value?: FloatWithAggregatesFilter<"SettlementParticipant"> | number
    status?: StringWithAggregatesFilter<"SettlementParticipant"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type FiscalObligationWhereInput = {
    AND?: FiscalObligationWhereInput | FiscalObligationWhereInput[]
    OR?: FiscalObligationWhereInput[]
    NOT?: FiscalObligationWhereInput | FiscalObligationWhereInput[]
    id?: StringFilter<"FiscalObligation"> | string
    userId?: StringFilter<"FiscalObligation"> | string
    title?: StringFilter<"FiscalObligation"> | string
    description?: StringNullableFilter<"FiscalObligation"> | string | null
    type?: StringFilter<"FiscalObligation"> | string
    status?: StringFilter<"FiscalObligation"> | string
    amount?: FloatFilter<"FiscalObligation"> | number
    currency?: StringFilter<"FiscalObligation"> | string
    dueDate?: DateTimeFilter<"FiscalObligation"> | Date | string
    taxCode?: StringNullableFilter<"FiscalObligation"> | string | null
    taxName?: StringNullableFilter<"FiscalObligation"> | string | null
    taxType?: StringNullableFilter<"FiscalObligation"> | string | null
    taxPeriod?: StringNullableFilter<"FiscalObligation"> | string | null
    taxBase?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxRate?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxValue?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxInterest?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxFine?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxTotal?: FloatNullableFilter<"FiscalObligation"> | number | null
    createdAt?: DateTimeFilter<"FiscalObligation"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalObligation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FiscalObligationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    taxCode?: SortOrderInput | SortOrder
    taxName?: SortOrderInput | SortOrder
    taxType?: SortOrderInput | SortOrder
    taxPeriod?: SortOrderInput | SortOrder
    taxBase?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    taxValue?: SortOrderInput | SortOrder
    taxInterest?: SortOrderInput | SortOrder
    taxFine?: SortOrderInput | SortOrder
    taxTotal?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FiscalObligationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FiscalObligationWhereInput | FiscalObligationWhereInput[]
    OR?: FiscalObligationWhereInput[]
    NOT?: FiscalObligationWhereInput | FiscalObligationWhereInput[]
    userId?: StringFilter<"FiscalObligation"> | string
    title?: StringFilter<"FiscalObligation"> | string
    description?: StringNullableFilter<"FiscalObligation"> | string | null
    type?: StringFilter<"FiscalObligation"> | string
    status?: StringFilter<"FiscalObligation"> | string
    amount?: FloatFilter<"FiscalObligation"> | number
    currency?: StringFilter<"FiscalObligation"> | string
    dueDate?: DateTimeFilter<"FiscalObligation"> | Date | string
    taxCode?: StringNullableFilter<"FiscalObligation"> | string | null
    taxName?: StringNullableFilter<"FiscalObligation"> | string | null
    taxType?: StringNullableFilter<"FiscalObligation"> | string | null
    taxPeriod?: StringNullableFilter<"FiscalObligation"> | string | null
    taxBase?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxRate?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxValue?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxInterest?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxFine?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxTotal?: FloatNullableFilter<"FiscalObligation"> | number | null
    createdAt?: DateTimeFilter<"FiscalObligation"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalObligation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FiscalObligationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    taxCode?: SortOrderInput | SortOrder
    taxName?: SortOrderInput | SortOrder
    taxType?: SortOrderInput | SortOrder
    taxPeriod?: SortOrderInput | SortOrder
    taxBase?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    taxValue?: SortOrderInput | SortOrder
    taxInterest?: SortOrderInput | SortOrder
    taxFine?: SortOrderInput | SortOrder
    taxTotal?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FiscalObligationCountOrderByAggregateInput
    _avg?: FiscalObligationAvgOrderByAggregateInput
    _max?: FiscalObligationMaxOrderByAggregateInput
    _min?: FiscalObligationMinOrderByAggregateInput
    _sum?: FiscalObligationSumOrderByAggregateInput
  }

  export type FiscalObligationScalarWhereWithAggregatesInput = {
    AND?: FiscalObligationScalarWhereWithAggregatesInput | FiscalObligationScalarWhereWithAggregatesInput[]
    OR?: FiscalObligationScalarWhereWithAggregatesInput[]
    NOT?: FiscalObligationScalarWhereWithAggregatesInput | FiscalObligationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FiscalObligation"> | string
    userId?: StringWithAggregatesFilter<"FiscalObligation"> | string
    title?: StringWithAggregatesFilter<"FiscalObligation"> | string
    description?: StringNullableWithAggregatesFilter<"FiscalObligation"> | string | null
    type?: StringWithAggregatesFilter<"FiscalObligation"> | string
    status?: StringWithAggregatesFilter<"FiscalObligation"> | string
    amount?: FloatWithAggregatesFilter<"FiscalObligation"> | number
    currency?: StringWithAggregatesFilter<"FiscalObligation"> | string
    dueDate?: DateTimeWithAggregatesFilter<"FiscalObligation"> | Date | string
    taxCode?: StringNullableWithAggregatesFilter<"FiscalObligation"> | string | null
    taxName?: StringNullableWithAggregatesFilter<"FiscalObligation"> | string | null
    taxType?: StringNullableWithAggregatesFilter<"FiscalObligation"> | string | null
    taxPeriod?: StringNullableWithAggregatesFilter<"FiscalObligation"> | string | null
    taxBase?: FloatNullableWithAggregatesFilter<"FiscalObligation"> | number | null
    taxRate?: FloatNullableWithAggregatesFilter<"FiscalObligation"> | number | null
    taxValue?: FloatNullableWithAggregatesFilter<"FiscalObligation"> | number | null
    taxInterest?: FloatNullableWithAggregatesFilter<"FiscalObligation"> | number | null
    taxFine?: FloatNullableWithAggregatesFilter<"FiscalObligation"> | number | null
    taxTotal?: FloatNullableWithAggregatesFilter<"FiscalObligation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"FiscalObligation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FiscalObligation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaCreateInput = {
    id?: string
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj: string
    inscEstadual?: string | null
    inscMunicipal?: string | null
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    website?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    representantePrincipal: UserCreateNestedOneWithoutEmpresasRepresentadasInput
  }

  export type EmpresaUncheckedCreateInput = {
    id?: string
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj: string
    inscEstadual?: string | null
    inscMunicipal?: string | null
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    website?: string | null
    status: string
    representantePrincipalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    representantePrincipal?: UserUpdateOneRequiredWithoutEmpresasRepresentadasNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    representantePrincipalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaCreateManyInput = {
    id?: string
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj: string
    inscEstadual?: string | null
    inscMunicipal?: string | null
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    website?: string | null
    status: string
    representantePrincipalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    representantePrincipalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTitleCreateInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateManyInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditTitleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTitleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTitleTributarioCreateInput = {
    id?: string
    subTypeFederal?: $Enums.TCTributarioFederal | null
    subTypeEstadual?: $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: $Enums.TCTributarioMunicipal | null
    esfera: string
    nomeTributo: string
    periodoApuracaoInicio: Date | string
    periodoApuracaoFim: Date | string
    numeroProcessoAdministrativo?: string | null
    numeroProcessoJudicial?: string | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsTributarioInput
  }

  export type CreditTitleTributarioUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subTypeFederal?: $Enums.TCTributarioFederal | null
    subTypeEstadual?: $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: $Enums.TCTributarioMunicipal | null
    esfera: string
    nomeTributo: string
    periodoApuracaoInicio: Date | string
    periodoApuracaoFim: Date | string
    numeroProcessoAdministrativo?: string | null
    numeroProcessoJudicial?: string | null
  }

  export type CreditTitleTributarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTypeFederal?: NullableEnumTCTributarioFederalFieldUpdateOperationsInput | $Enums.TCTributarioFederal | null
    subTypeEstadual?: NullableEnumTCTributarioEstadualFieldUpdateOperationsInput | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput | $Enums.TCTributarioMunicipal | null
    esfera?: StringFieldUpdateOperationsInput | string
    nomeTributo?: StringFieldUpdateOperationsInput | string
    periodoApuracaoInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    periodoApuracaoFim?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroProcessoAdministrativo?: NullableStringFieldUpdateOperationsInput | string | null
    numeroProcessoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsTributarioNestedInput
  }

  export type CreditTitleTributarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subTypeFederal?: NullableEnumTCTributarioFederalFieldUpdateOperationsInput | $Enums.TCTributarioFederal | null
    subTypeEstadual?: NullableEnumTCTributarioEstadualFieldUpdateOperationsInput | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput | $Enums.TCTributarioMunicipal | null
    esfera?: StringFieldUpdateOperationsInput | string
    nomeTributo?: StringFieldUpdateOperationsInput | string
    periodoApuracaoInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    periodoApuracaoFim?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroProcessoAdministrativo?: NullableStringFieldUpdateOperationsInput | string | null
    numeroProcessoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleTributarioCreateManyInput = {
    id?: string
    creditTitleId: string
    subTypeFederal?: $Enums.TCTributarioFederal | null
    subTypeEstadual?: $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: $Enums.TCTributarioMunicipal | null
    esfera: string
    nomeTributo: string
    periodoApuracaoInicio: Date | string
    periodoApuracaoFim: Date | string
    numeroProcessoAdministrativo?: string | null
    numeroProcessoJudicial?: string | null
  }

  export type CreditTitleTributarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTypeFederal?: NullableEnumTCTributarioFederalFieldUpdateOperationsInput | $Enums.TCTributarioFederal | null
    subTypeEstadual?: NullableEnumTCTributarioEstadualFieldUpdateOperationsInput | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput | $Enums.TCTributarioMunicipal | null
    esfera?: StringFieldUpdateOperationsInput | string
    nomeTributo?: StringFieldUpdateOperationsInput | string
    periodoApuracaoInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    periodoApuracaoFim?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroProcessoAdministrativo?: NullableStringFieldUpdateOperationsInput | string | null
    numeroProcessoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleTributarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subTypeFederal?: NullableEnumTCTributarioFederalFieldUpdateOperationsInput | $Enums.TCTributarioFederal | null
    subTypeEstadual?: NullableEnumTCTributarioEstadualFieldUpdateOperationsInput | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput | $Enums.TCTributarioMunicipal | null
    esfera?: StringFieldUpdateOperationsInput | string
    nomeTributo?: StringFieldUpdateOperationsInput | string
    periodoApuracaoInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    periodoApuracaoFim?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroProcessoAdministrativo?: NullableStringFieldUpdateOperationsInput | string | null
    numeroProcessoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleComercialCreateInput = {
    id?: string
    subType: $Enums.TCComercial
    sacadoNome: string
    sacadoDocumento: string
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsComercialInput
  }

  export type CreditTitleComercialUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCComercial
    sacadoNome: string
    sacadoDocumento: string
  }

  export type CreditTitleComercialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCComercialFieldUpdateOperationsInput | $Enums.TCComercial
    sacadoNome?: StringFieldUpdateOperationsInput | string
    sacadoDocumento?: StringFieldUpdateOperationsInput | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsComercialNestedInput
  }

  export type CreditTitleComercialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCComercialFieldUpdateOperationsInput | $Enums.TCComercial
    sacadoNome?: StringFieldUpdateOperationsInput | string
    sacadoDocumento?: StringFieldUpdateOperationsInput | string
  }

  export type CreditTitleComercialCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCComercial
    sacadoNome: string
    sacadoDocumento: string
  }

  export type CreditTitleComercialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCComercialFieldUpdateOperationsInput | $Enums.TCComercial
    sacadoNome?: StringFieldUpdateOperationsInput | string
    sacadoDocumento?: StringFieldUpdateOperationsInput | string
  }

  export type CreditTitleComercialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCComercialFieldUpdateOperationsInput | $Enums.TCComercial
    sacadoNome?: StringFieldUpdateOperationsInput | string
    sacadoDocumento?: StringFieldUpdateOperationsInput | string
  }

  export type CreditTitleFinanceiroCreateInput = {
    id?: string
    subType: $Enums.TCFinanceiro
    indexador?: string | null
    taxaJurosAnual?: number | null
    rating?: string | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsFinanceiroInput
  }

  export type CreditTitleFinanceiroUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCFinanceiro
    indexador?: string | null
    taxaJurosAnual?: number | null
    rating?: string | null
  }

  export type CreditTitleFinanceiroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCFinanceiroFieldUpdateOperationsInput | $Enums.TCFinanceiro
    indexador?: NullableStringFieldUpdateOperationsInput | string | null
    taxaJurosAnual?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsFinanceiroNestedInput
  }

  export type CreditTitleFinanceiroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCFinanceiroFieldUpdateOperationsInput | $Enums.TCFinanceiro
    indexador?: NullableStringFieldUpdateOperationsInput | string | null
    taxaJurosAnual?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleFinanceiroCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCFinanceiro
    indexador?: string | null
    taxaJurosAnual?: number | null
    rating?: string | null
  }

  export type CreditTitleFinanceiroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCFinanceiroFieldUpdateOperationsInput | $Enums.TCFinanceiro
    indexador?: NullableStringFieldUpdateOperationsInput | string | null
    taxaJurosAnual?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleFinanceiroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCFinanceiroFieldUpdateOperationsInput | $Enums.TCFinanceiro
    indexador?: NullableStringFieldUpdateOperationsInput | string | null
    taxaJurosAnual?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleJudicialCreateInput = {
    id?: string
    subType: $Enums.TCJudicial
    numeroProcesso: string
    tribunalOrigem: string
    varaOrigem?: string | null
    natureza: string
    enteDevedor?: string | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsJudicialInput
  }

  export type CreditTitleJudicialUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCJudicial
    numeroProcesso: string
    tribunalOrigem: string
    varaOrigem?: string | null
    natureza: string
    enteDevedor?: string | null
  }

  export type CreditTitleJudicialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCJudicialFieldUpdateOperationsInput | $Enums.TCJudicial
    numeroProcesso?: StringFieldUpdateOperationsInput | string
    tribunalOrigem?: StringFieldUpdateOperationsInput | string
    varaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    natureza?: StringFieldUpdateOperationsInput | string
    enteDevedor?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsJudicialNestedInput
  }

  export type CreditTitleJudicialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCJudicialFieldUpdateOperationsInput | $Enums.TCJudicial
    numeroProcesso?: StringFieldUpdateOperationsInput | string
    tribunalOrigem?: StringFieldUpdateOperationsInput | string
    varaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    natureza?: StringFieldUpdateOperationsInput | string
    enteDevedor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleJudicialCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCJudicial
    numeroProcesso: string
    tribunalOrigem: string
    varaOrigem?: string | null
    natureza: string
    enteDevedor?: string | null
  }

  export type CreditTitleJudicialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCJudicialFieldUpdateOperationsInput | $Enums.TCJudicial
    numeroProcesso?: StringFieldUpdateOperationsInput | string
    tribunalOrigem?: StringFieldUpdateOperationsInput | string
    varaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    natureza?: StringFieldUpdateOperationsInput | string
    enteDevedor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleJudicialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCJudicialFieldUpdateOperationsInput | $Enums.TCJudicial
    numeroProcesso?: StringFieldUpdateOperationsInput | string
    tribunalOrigem?: StringFieldUpdateOperationsInput | string
    varaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    natureza?: StringFieldUpdateOperationsInput | string
    enteDevedor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleRuralCreateInput = {
    id?: string
    subType: $Enums.TCRural
    safra?: string | null
    produtoAgricola?: string | null
    areaFinanciadaHectares?: number | null
    registroImovelRural?: string | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsRuralInput
  }

  export type CreditTitleRuralUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCRural
    safra?: string | null
    produtoAgricola?: string | null
    areaFinanciadaHectares?: number | null
    registroImovelRural?: string | null
  }

  export type CreditTitleRuralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCRuralFieldUpdateOperationsInput | $Enums.TCRural
    safra?: NullableStringFieldUpdateOperationsInput | string | null
    produtoAgricola?: NullableStringFieldUpdateOperationsInput | string | null
    areaFinanciadaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    registroImovelRural?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsRuralNestedInput
  }

  export type CreditTitleRuralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCRuralFieldUpdateOperationsInput | $Enums.TCRural
    safra?: NullableStringFieldUpdateOperationsInput | string | null
    produtoAgricola?: NullableStringFieldUpdateOperationsInput | string | null
    areaFinanciadaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    registroImovelRural?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleRuralCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCRural
    safra?: string | null
    produtoAgricola?: string | null
    areaFinanciadaHectares?: number | null
    registroImovelRural?: string | null
  }

  export type CreditTitleRuralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCRuralFieldUpdateOperationsInput | $Enums.TCRural
    safra?: NullableStringFieldUpdateOperationsInput | string | null
    produtoAgricola?: NullableStringFieldUpdateOperationsInput | string | null
    areaFinanciadaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    registroImovelRural?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleRuralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCRuralFieldUpdateOperationsInput | $Enums.TCRural
    safra?: NullableStringFieldUpdateOperationsInput | string | null
    produtoAgricola?: NullableStringFieldUpdateOperationsInput | string | null
    areaFinanciadaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    registroImovelRural?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleImobiliarioCreateInput = {
    id?: string
    subType: $Enums.TCImobiliario
    matriculaImovel: string
    enderecoLogradouro: string
    enderecoNumero: string
    enderecoComplemento?: string | null
    enderecoBairro: string
    enderecoCidade: string
    enderecoEstado: string
    enderecoCep: string
    tipoGarantia?: string | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsImobiliarioInput
  }

  export type CreditTitleImobiliarioUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCImobiliario
    matriculaImovel: string
    enderecoLogradouro: string
    enderecoNumero: string
    enderecoComplemento?: string | null
    enderecoBairro: string
    enderecoCidade: string
    enderecoEstado: string
    enderecoCep: string
    tipoGarantia?: string | null
  }

  export type CreditTitleImobiliarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCImobiliarioFieldUpdateOperationsInput | $Enums.TCImobiliario
    matriculaImovel?: StringFieldUpdateOperationsInput | string
    enderecoLogradouro?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: StringFieldUpdateOperationsInput | string
    enderecoComplemento?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoBairro?: StringFieldUpdateOperationsInput | string
    enderecoCidade?: StringFieldUpdateOperationsInput | string
    enderecoEstado?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    tipoGarantia?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsImobiliarioNestedInput
  }

  export type CreditTitleImobiliarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCImobiliarioFieldUpdateOperationsInput | $Enums.TCImobiliario
    matriculaImovel?: StringFieldUpdateOperationsInput | string
    enderecoLogradouro?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: StringFieldUpdateOperationsInput | string
    enderecoComplemento?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoBairro?: StringFieldUpdateOperationsInput | string
    enderecoCidade?: StringFieldUpdateOperationsInput | string
    enderecoEstado?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    tipoGarantia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleImobiliarioCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCImobiliario
    matriculaImovel: string
    enderecoLogradouro: string
    enderecoNumero: string
    enderecoComplemento?: string | null
    enderecoBairro: string
    enderecoCidade: string
    enderecoEstado: string
    enderecoCep: string
    tipoGarantia?: string | null
  }

  export type CreditTitleImobiliarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCImobiliarioFieldUpdateOperationsInput | $Enums.TCImobiliario
    matriculaImovel?: StringFieldUpdateOperationsInput | string
    enderecoLogradouro?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: StringFieldUpdateOperationsInput | string
    enderecoComplemento?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoBairro?: StringFieldUpdateOperationsInput | string
    enderecoCidade?: StringFieldUpdateOperationsInput | string
    enderecoEstado?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    tipoGarantia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleImobiliarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCImobiliarioFieldUpdateOperationsInput | $Enums.TCImobiliario
    matriculaImovel?: StringFieldUpdateOperationsInput | string
    enderecoLogradouro?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: StringFieldUpdateOperationsInput | string
    enderecoComplemento?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoBairro?: StringFieldUpdateOperationsInput | string
    enderecoCidade?: StringFieldUpdateOperationsInput | string
    enderecoEstado?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    tipoGarantia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleAmbientalCreateInput = {
    id?: string
    subType: $Enums.TCAmbiental
    projetoVinculado?: string | null
    metodologiaCertificacao?: string | null
    toneladasCO2Equivalente?: number | null
    hectaresConservados?: number | null
    volumeAguaEconomizadoM3?: number | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsAmbientalInput
  }

  export type CreditTitleAmbientalUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCAmbiental
    projetoVinculado?: string | null
    metodologiaCertificacao?: string | null
    toneladasCO2Equivalente?: number | null
    hectaresConservados?: number | null
    volumeAguaEconomizadoM3?: number | null
  }

  export type CreditTitleAmbientalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCAmbientalFieldUpdateOperationsInput | $Enums.TCAmbiental
    projetoVinculado?: NullableStringFieldUpdateOperationsInput | string | null
    metodologiaCertificacao?: NullableStringFieldUpdateOperationsInput | string | null
    toneladasCO2Equivalente?: NullableFloatFieldUpdateOperationsInput | number | null
    hectaresConservados?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeAguaEconomizadoM3?: NullableFloatFieldUpdateOperationsInput | number | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsAmbientalNestedInput
  }

  export type CreditTitleAmbientalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCAmbientalFieldUpdateOperationsInput | $Enums.TCAmbiental
    projetoVinculado?: NullableStringFieldUpdateOperationsInput | string | null
    metodologiaCertificacao?: NullableStringFieldUpdateOperationsInput | string | null
    toneladasCO2Equivalente?: NullableFloatFieldUpdateOperationsInput | number | null
    hectaresConservados?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeAguaEconomizadoM3?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditTitleAmbientalCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCAmbiental
    projetoVinculado?: string | null
    metodologiaCertificacao?: string | null
    toneladasCO2Equivalente?: number | null
    hectaresConservados?: number | null
    volumeAguaEconomizadoM3?: number | null
  }

  export type CreditTitleAmbientalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCAmbientalFieldUpdateOperationsInput | $Enums.TCAmbiental
    projetoVinculado?: NullableStringFieldUpdateOperationsInput | string | null
    metodologiaCertificacao?: NullableStringFieldUpdateOperationsInput | string | null
    toneladasCO2Equivalente?: NullableFloatFieldUpdateOperationsInput | number | null
    hectaresConservados?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeAguaEconomizadoM3?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditTitleAmbientalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCAmbientalFieldUpdateOperationsInput | $Enums.TCAmbiental
    projetoVinculado?: NullableStringFieldUpdateOperationsInput | string | null
    metodologiaCertificacao?: NullableStringFieldUpdateOperationsInput | string | null
    toneladasCO2Equivalente?: NullableFloatFieldUpdateOperationsInput | number | null
    hectaresConservados?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeAguaEconomizadoM3?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditTitleEspecialCreateInput = {
    id?: string
    subType: $Enums.TCEspecial
    processoRecuperacaoJudicial?: string | null
    credorOriginal?: string | null
    classeCreditoRJ?: string | null
    administradoraConsorcio?: string | null
    grupoConsorcio?: string | null
    cotaConsorcio?: string | null
    creditTitle: CreditTitleCreateNestedOneWithoutDetailsEspecialInput
  }

  export type CreditTitleEspecialUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCEspecial
    processoRecuperacaoJudicial?: string | null
    credorOriginal?: string | null
    classeCreditoRJ?: string | null
    administradoraConsorcio?: string | null
    grupoConsorcio?: string | null
    cotaConsorcio?: string | null
  }

  export type CreditTitleEspecialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCEspecialFieldUpdateOperationsInput | $Enums.TCEspecial
    processoRecuperacaoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    credorOriginal?: NullableStringFieldUpdateOperationsInput | string | null
    classeCreditoRJ?: NullableStringFieldUpdateOperationsInput | string | null
    administradoraConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    grupoConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    cotaConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDetailsEspecialNestedInput
  }

  export type CreditTitleEspecialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCEspecialFieldUpdateOperationsInput | $Enums.TCEspecial
    processoRecuperacaoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    credorOriginal?: NullableStringFieldUpdateOperationsInput | string | null
    classeCreditoRJ?: NullableStringFieldUpdateOperationsInput | string | null
    administradoraConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    grupoConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    cotaConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleEspecialCreateManyInput = {
    id?: string
    creditTitleId: string
    subType: $Enums.TCEspecial
    processoRecuperacaoJudicial?: string | null
    credorOriginal?: string | null
    classeCreditoRJ?: string | null
    administradoraConsorcio?: string | null
    grupoConsorcio?: string | null
    cotaConsorcio?: string | null
  }

  export type CreditTitleEspecialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCEspecialFieldUpdateOperationsInput | $Enums.TCEspecial
    processoRecuperacaoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    credorOriginal?: NullableStringFieldUpdateOperationsInput | string | null
    classeCreditoRJ?: NullableStringFieldUpdateOperationsInput | string | null
    administradoraConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    grupoConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    cotaConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleEspecialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCEspecialFieldUpdateOperationsInput | $Enums.TCEspecial
    processoRecuperacaoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    credorOriginal?: NullableStringFieldUpdateOperationsInput | string | null
    classeCreditoRJ?: NullableStringFieldUpdateOperationsInput | string | null
    administradoraConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    grupoConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    cotaConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    uploadedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    creditTitleId: string
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitleId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    creditTitleId: string
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitleId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateInput = {
    id?: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutOffersInput
    seller: UserCreateNestedOneWithoutOffersInput
    bids?: BidCreateNestedManyWithoutOfferInput
    transactions?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutOfferInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutOffersNestedInput
    seller?: UserUpdateOneRequiredWithoutOffersNestedInput
    bids?: BidUpdateManyWithoutOfferNestedInput
    transactions?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutOfferNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateInput = {
    id?: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    offer: OfferCreateNestedOneWithoutBidsInput
    bidder: UserCreateNestedOneWithoutBidsInput
    transactions?: TransactionCreateNestedManyWithoutBidInput
  }

  export type BidUncheckedCreateInput = {
    id?: string
    offerId: string
    bidderId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutBidInput
  }

  export type BidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneRequiredWithoutBidsNestedInput
    bidder?: UserUpdateOneRequiredWithoutBidsNestedInput
    transactions?: TransactionUpdateManyWithoutBidNestedInput
  }

  export type BidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutBidNestedInput
  }

  export type BidCreateManyInput = {
    id?: string
    offerId: string
    bidderId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutTransactionsInput
    seller: UserCreateNestedOneWithoutTransactionsAsSellerInput
    buyer: UserCreateNestedOneWithoutTransactionsAsBuyerInput
    offer?: OfferCreateNestedOneWithoutTransactionsInput
    bid?: BidCreateNestedOneWithoutTransactionsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput
    seller?: UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput
    offer?: OfferUpdateOneWithoutTransactionsNestedInput
    bid?: BidUpdateOneWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateInput = {
    id?: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credit: CreditTitleCreateNestedOneWithoutAuctionsInput
    seller: UserCreateNestedOneWithoutAuctionsAsSellerInput
    winner?: UserCreateNestedOneWithoutAuctionsAsWinnerInput
  }

  export type AuctionUncheckedCreateInput = {
    id?: string
    creditId: string
    sellerId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    winnerId?: string | null
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: CreditTitleUpdateOneRequiredWithoutAuctionsNestedInput
    seller?: UserUpdateOneRequiredWithoutAuctionsAsSellerNestedInput
    winner?: UserUpdateOneWithoutAuctionsAsWinnerNestedInput
  }

  export type AuctionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateManyInput = {
    id?: string
    creditId: string
    sellerId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    winnerId?: string | null
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementCreateInput = {
    id?: string
    type: string
    status: string
    totalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: SettlementParticipantCreateNestedManyWithoutSettlementInput
  }

  export type SettlementUncheckedCreateInput = {
    id?: string
    type: string
    status: string
    totalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: SettlementParticipantUncheckedCreateNestedManyWithoutSettlementInput
  }

  export type SettlementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: SettlementParticipantUpdateManyWithoutSettlementNestedInput
  }

  export type SettlementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: SettlementParticipantUncheckedUpdateManyWithoutSettlementNestedInput
  }

  export type SettlementCreateManyInput = {
    id?: string
    type: string
    status: string
    totalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementParticipantCreateInput = {
    id?: string
    role: string
    value: number
    status: string
    settlement: SettlementCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutSettlementParticipantsInput
  }

  export type SettlementParticipantUncheckedCreateInput = {
    id?: string
    settlementId: string
    userId: string
    role: string
    value: number
    status: string
  }

  export type SettlementParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    settlement?: SettlementUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutSettlementParticipantsNestedInput
  }

  export type SettlementParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settlementId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SettlementParticipantCreateManyInput = {
    id?: string
    settlementId: string
    userId: string
    role: string
    value: number
    status: string
  }

  export type SettlementParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SettlementParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    settlementId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalObligationCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date | string
    taxCode?: string | null
    taxName?: string | null
    taxType?: string | null
    taxPeriod?: string | null
    taxBase?: number | null
    taxRate?: number | null
    taxValue?: number | null
    taxInterest?: number | null
    taxFine?: number | null
    taxTotal?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFiscalObligationsInput
  }

  export type FiscalObligationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date | string
    taxCode?: string | null
    taxName?: string | null
    taxType?: string | null
    taxPeriod?: string | null
    taxBase?: number | null
    taxRate?: number | null
    taxValue?: number | null
    taxInterest?: number | null
    taxFine?: number | null
    taxTotal?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalObligationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFiscalObligationsNestedInput
  }

  export type FiscalObligationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalObligationCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date | string
    taxCode?: string | null
    taxName?: string | null
    taxType?: string | null
    taxPeriod?: string | null
    taxBase?: number | null
    taxRate?: number | null
    taxValue?: number | null
    taxInterest?: number | null
    taxFine?: number | null
    taxTotal?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalObligationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalObligationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type CreditTitleListRelationFilter = {
    every?: CreditTitleWhereInput
    some?: CreditTitleWhereInput
    none?: CreditTitleWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type BidListRelationFilter = {
    every?: BidWhereInput
    some?: BidWhereInput
    none?: BidWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type AuctionListRelationFilter = {
    every?: AuctionWhereInput
    some?: AuctionWhereInput
    none?: AuctionWhereInput
  }

  export type SettlementParticipantListRelationFilter = {
    every?: SettlementParticipantWhereInput
    some?: SettlementParticipantWhereInput
    none?: SettlementParticipantWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type FiscalObligationListRelationFilter = {
    every?: FiscalObligationWhereInput
    some?: FiscalObligationWhereInput
    none?: FiscalObligationWhereInput
  }

  export type EmpresaListRelationFilter = {
    every?: EmpresaWhereInput
    some?: EmpresaWhereInput
    none?: EmpresaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditTitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettlementParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FiscalObligationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmpresaCountOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpj?: SortOrder
    inscEstadual?: SortOrder
    inscMunicipal?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    status?: SortOrder
    representantePrincipalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpj?: SortOrder
    inscEstadual?: SortOrder
    inscMunicipal?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    status?: SortOrder
    representantePrincipalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpj?: SortOrder
    inscEstadual?: SortOrder
    inscMunicipal?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    status?: SortOrder
    representantePrincipalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumCreditCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditCategory | EnumCreditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CreditCategory[]
    notIn?: $Enums.CreditCategory[]
    not?: NestedEnumCreditCategoryFilter<$PrismaModel> | $Enums.CreditCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusFilter<$PrismaModel> | $Enums.CreditStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CreditTitleTributarioNullableScalarRelationFilter = {
    is?: CreditTitleTributarioWhereInput | null
    isNot?: CreditTitleTributarioWhereInput | null
  }

  export type CreditTitleComercialNullableScalarRelationFilter = {
    is?: CreditTitleComercialWhereInput | null
    isNot?: CreditTitleComercialWhereInput | null
  }

  export type CreditTitleFinanceiroNullableScalarRelationFilter = {
    is?: CreditTitleFinanceiroWhereInput | null
    isNot?: CreditTitleFinanceiroWhereInput | null
  }

  export type CreditTitleJudicialNullableScalarRelationFilter = {
    is?: CreditTitleJudicialWhereInput | null
    isNot?: CreditTitleJudicialWhereInput | null
  }

  export type CreditTitleRuralNullableScalarRelationFilter = {
    is?: CreditTitleRuralWhereInput | null
    isNot?: CreditTitleRuralWhereInput | null
  }

  export type CreditTitleImobiliarioNullableScalarRelationFilter = {
    is?: CreditTitleImobiliarioWhereInput | null
    isNot?: CreditTitleImobiliarioWhereInput | null
  }

  export type CreditTitleAmbientalNullableScalarRelationFilter = {
    is?: CreditTitleAmbientalWhereInput | null
    isNot?: CreditTitleAmbientalWhereInput | null
  }

  export type CreditTitleEspecialNullableScalarRelationFilter = {
    is?: CreditTitleEspecialWhereInput | null
    isNot?: CreditTitleEspecialWhereInput | null
  }

  export type CreditTitleCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    issuerId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    tokenId?: SortOrder
    tokenStandard?: SortOrder
    blockchainTxHash?: SortOrder
    isListed?: SortOrder
    listingPrice?: SortOrder
    listingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditTitleAvgOrderByAggregateInput = {
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    listingPrice?: SortOrder
  }

  export type CreditTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    issuerId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    tokenId?: SortOrder
    tokenStandard?: SortOrder
    blockchainTxHash?: SortOrder
    isListed?: SortOrder
    listingPrice?: SortOrder
    listingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditTitleMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    issuerId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    tokenId?: SortOrder
    tokenStandard?: SortOrder
    blockchainTxHash?: SortOrder
    isListed?: SortOrder
    listingPrice?: SortOrder
    listingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditTitleSumOrderByAggregateInput = {
    valueNominal?: SortOrder
    valueCurrent?: SortOrder
    listingPrice?: SortOrder
  }

  export type EnumCreditCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditCategory | EnumCreditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CreditCategory[]
    notIn?: $Enums.CreditCategory[]
    not?: NestedEnumCreditCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CreditCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditCategoryFilter<$PrismaModel>
    _max?: NestedEnumCreditCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTCTributarioFederalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioFederal | EnumTCTributarioFederalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioFederal[] | null
    notIn?: $Enums.TCTributarioFederal[] | null
    not?: NestedEnumTCTributarioFederalNullableFilter<$PrismaModel> | $Enums.TCTributarioFederal | null
  }

  export type EnumTCTributarioEstadualNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioEstadual | EnumTCTributarioEstadualFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioEstadual[] | null
    notIn?: $Enums.TCTributarioEstadual[] | null
    not?: NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel> | $Enums.TCTributarioEstadual | null
  }

  export type EnumTCTributarioMunicipalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioMunicipal | EnumTCTributarioMunicipalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioMunicipal[] | null
    notIn?: $Enums.TCTributarioMunicipal[] | null
    not?: NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel> | $Enums.TCTributarioMunicipal | null
  }

  export type CreditTitleScalarRelationFilter = {
    is?: CreditTitleWhereInput
    isNot?: CreditTitleWhereInput
  }

  export type CreditTitleTributarioCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subTypeFederal?: SortOrder
    subTypeEstadual?: SortOrder
    subTypeMunicipal?: SortOrder
    esfera?: SortOrder
    nomeTributo?: SortOrder
    periodoApuracaoInicio?: SortOrder
    periodoApuracaoFim?: SortOrder
    numeroProcessoAdministrativo?: SortOrder
    numeroProcessoJudicial?: SortOrder
  }

  export type CreditTitleTributarioMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subTypeFederal?: SortOrder
    subTypeEstadual?: SortOrder
    subTypeMunicipal?: SortOrder
    esfera?: SortOrder
    nomeTributo?: SortOrder
    periodoApuracaoInicio?: SortOrder
    periodoApuracaoFim?: SortOrder
    numeroProcessoAdministrativo?: SortOrder
    numeroProcessoJudicial?: SortOrder
  }

  export type CreditTitleTributarioMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subTypeFederal?: SortOrder
    subTypeEstadual?: SortOrder
    subTypeMunicipal?: SortOrder
    esfera?: SortOrder
    nomeTributo?: SortOrder
    periodoApuracaoInicio?: SortOrder
    periodoApuracaoFim?: SortOrder
    numeroProcessoAdministrativo?: SortOrder
    numeroProcessoJudicial?: SortOrder
  }

  export type EnumTCTributarioFederalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioFederal | EnumTCTributarioFederalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioFederal[] | null
    notIn?: $Enums.TCTributarioFederal[] | null
    not?: NestedEnumTCTributarioFederalNullableWithAggregatesFilter<$PrismaModel> | $Enums.TCTributarioFederal | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTCTributarioFederalNullableFilter<$PrismaModel>
    _max?: NestedEnumTCTributarioFederalNullableFilter<$PrismaModel>
  }

  export type EnumTCTributarioEstadualNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioEstadual | EnumTCTributarioEstadualFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioEstadual[] | null
    notIn?: $Enums.TCTributarioEstadual[] | null
    not?: NestedEnumTCTributarioEstadualNullableWithAggregatesFilter<$PrismaModel> | $Enums.TCTributarioEstadual | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel>
    _max?: NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel>
  }

  export type EnumTCTributarioMunicipalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioMunicipal | EnumTCTributarioMunicipalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioMunicipal[] | null
    notIn?: $Enums.TCTributarioMunicipal[] | null
    not?: NestedEnumTCTributarioMunicipalNullableWithAggregatesFilter<$PrismaModel> | $Enums.TCTributarioMunicipal | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel>
    _max?: NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel>
  }

  export type EnumTCComercialFilter<$PrismaModel = never> = {
    equals?: $Enums.TCComercial | EnumTCComercialFieldRefInput<$PrismaModel>
    in?: $Enums.TCComercial[]
    notIn?: $Enums.TCComercial[]
    not?: NestedEnumTCComercialFilter<$PrismaModel> | $Enums.TCComercial
  }

  export type CreditTitleComercialCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    sacadoNome?: SortOrder
    sacadoDocumento?: SortOrder
  }

  export type CreditTitleComercialMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    sacadoNome?: SortOrder
    sacadoDocumento?: SortOrder
  }

  export type CreditTitleComercialMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    sacadoNome?: SortOrder
    sacadoDocumento?: SortOrder
  }

  export type EnumTCComercialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCComercial | EnumTCComercialFieldRefInput<$PrismaModel>
    in?: $Enums.TCComercial[]
    notIn?: $Enums.TCComercial[]
    not?: NestedEnumTCComercialWithAggregatesFilter<$PrismaModel> | $Enums.TCComercial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCComercialFilter<$PrismaModel>
    _max?: NestedEnumTCComercialFilter<$PrismaModel>
  }

  export type EnumTCFinanceiroFilter<$PrismaModel = never> = {
    equals?: $Enums.TCFinanceiro | EnumTCFinanceiroFieldRefInput<$PrismaModel>
    in?: $Enums.TCFinanceiro[]
    notIn?: $Enums.TCFinanceiro[]
    not?: NestedEnumTCFinanceiroFilter<$PrismaModel> | $Enums.TCFinanceiro
  }

  export type CreditTitleFinanceiroCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    indexador?: SortOrder
    taxaJurosAnual?: SortOrder
    rating?: SortOrder
  }

  export type CreditTitleFinanceiroAvgOrderByAggregateInput = {
    taxaJurosAnual?: SortOrder
  }

  export type CreditTitleFinanceiroMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    indexador?: SortOrder
    taxaJurosAnual?: SortOrder
    rating?: SortOrder
  }

  export type CreditTitleFinanceiroMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    indexador?: SortOrder
    taxaJurosAnual?: SortOrder
    rating?: SortOrder
  }

  export type CreditTitleFinanceiroSumOrderByAggregateInput = {
    taxaJurosAnual?: SortOrder
  }

  export type EnumTCFinanceiroWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCFinanceiro | EnumTCFinanceiroFieldRefInput<$PrismaModel>
    in?: $Enums.TCFinanceiro[]
    notIn?: $Enums.TCFinanceiro[]
    not?: NestedEnumTCFinanceiroWithAggregatesFilter<$PrismaModel> | $Enums.TCFinanceiro
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCFinanceiroFilter<$PrismaModel>
    _max?: NestedEnumTCFinanceiroFilter<$PrismaModel>
  }

  export type EnumTCJudicialFilter<$PrismaModel = never> = {
    equals?: $Enums.TCJudicial | EnumTCJudicialFieldRefInput<$PrismaModel>
    in?: $Enums.TCJudicial[]
    notIn?: $Enums.TCJudicial[]
    not?: NestedEnumTCJudicialFilter<$PrismaModel> | $Enums.TCJudicial
  }

  export type CreditTitleJudicialCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    numeroProcesso?: SortOrder
    tribunalOrigem?: SortOrder
    varaOrigem?: SortOrder
    natureza?: SortOrder
    enteDevedor?: SortOrder
  }

  export type CreditTitleJudicialMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    numeroProcesso?: SortOrder
    tribunalOrigem?: SortOrder
    varaOrigem?: SortOrder
    natureza?: SortOrder
    enteDevedor?: SortOrder
  }

  export type CreditTitleJudicialMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    numeroProcesso?: SortOrder
    tribunalOrigem?: SortOrder
    varaOrigem?: SortOrder
    natureza?: SortOrder
    enteDevedor?: SortOrder
  }

  export type EnumTCJudicialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCJudicial | EnumTCJudicialFieldRefInput<$PrismaModel>
    in?: $Enums.TCJudicial[]
    notIn?: $Enums.TCJudicial[]
    not?: NestedEnumTCJudicialWithAggregatesFilter<$PrismaModel> | $Enums.TCJudicial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCJudicialFilter<$PrismaModel>
    _max?: NestedEnumTCJudicialFilter<$PrismaModel>
  }

  export type EnumTCRuralFilter<$PrismaModel = never> = {
    equals?: $Enums.TCRural | EnumTCRuralFieldRefInput<$PrismaModel>
    in?: $Enums.TCRural[]
    notIn?: $Enums.TCRural[]
    not?: NestedEnumTCRuralFilter<$PrismaModel> | $Enums.TCRural
  }

  export type CreditTitleRuralCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    safra?: SortOrder
    produtoAgricola?: SortOrder
    areaFinanciadaHectares?: SortOrder
    registroImovelRural?: SortOrder
  }

  export type CreditTitleRuralAvgOrderByAggregateInput = {
    areaFinanciadaHectares?: SortOrder
  }

  export type CreditTitleRuralMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    safra?: SortOrder
    produtoAgricola?: SortOrder
    areaFinanciadaHectares?: SortOrder
    registroImovelRural?: SortOrder
  }

  export type CreditTitleRuralMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    safra?: SortOrder
    produtoAgricola?: SortOrder
    areaFinanciadaHectares?: SortOrder
    registroImovelRural?: SortOrder
  }

  export type CreditTitleRuralSumOrderByAggregateInput = {
    areaFinanciadaHectares?: SortOrder
  }

  export type EnumTCRuralWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCRural | EnumTCRuralFieldRefInput<$PrismaModel>
    in?: $Enums.TCRural[]
    notIn?: $Enums.TCRural[]
    not?: NestedEnumTCRuralWithAggregatesFilter<$PrismaModel> | $Enums.TCRural
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCRuralFilter<$PrismaModel>
    _max?: NestedEnumTCRuralFilter<$PrismaModel>
  }

  export type EnumTCImobiliarioFilter<$PrismaModel = never> = {
    equals?: $Enums.TCImobiliario | EnumTCImobiliarioFieldRefInput<$PrismaModel>
    in?: $Enums.TCImobiliario[]
    notIn?: $Enums.TCImobiliario[]
    not?: NestedEnumTCImobiliarioFilter<$PrismaModel> | $Enums.TCImobiliario
  }

  export type CreditTitleImobiliarioCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    matriculaImovel?: SortOrder
    enderecoLogradouro?: SortOrder
    enderecoNumero?: SortOrder
    enderecoComplemento?: SortOrder
    enderecoBairro?: SortOrder
    enderecoCidade?: SortOrder
    enderecoEstado?: SortOrder
    enderecoCep?: SortOrder
    tipoGarantia?: SortOrder
  }

  export type CreditTitleImobiliarioMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    matriculaImovel?: SortOrder
    enderecoLogradouro?: SortOrder
    enderecoNumero?: SortOrder
    enderecoComplemento?: SortOrder
    enderecoBairro?: SortOrder
    enderecoCidade?: SortOrder
    enderecoEstado?: SortOrder
    enderecoCep?: SortOrder
    tipoGarantia?: SortOrder
  }

  export type CreditTitleImobiliarioMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    matriculaImovel?: SortOrder
    enderecoLogradouro?: SortOrder
    enderecoNumero?: SortOrder
    enderecoComplemento?: SortOrder
    enderecoBairro?: SortOrder
    enderecoCidade?: SortOrder
    enderecoEstado?: SortOrder
    enderecoCep?: SortOrder
    tipoGarantia?: SortOrder
  }

  export type EnumTCImobiliarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCImobiliario | EnumTCImobiliarioFieldRefInput<$PrismaModel>
    in?: $Enums.TCImobiliario[]
    notIn?: $Enums.TCImobiliario[]
    not?: NestedEnumTCImobiliarioWithAggregatesFilter<$PrismaModel> | $Enums.TCImobiliario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCImobiliarioFilter<$PrismaModel>
    _max?: NestedEnumTCImobiliarioFilter<$PrismaModel>
  }

  export type EnumTCAmbientalFilter<$PrismaModel = never> = {
    equals?: $Enums.TCAmbiental | EnumTCAmbientalFieldRefInput<$PrismaModel>
    in?: $Enums.TCAmbiental[]
    notIn?: $Enums.TCAmbiental[]
    not?: NestedEnumTCAmbientalFilter<$PrismaModel> | $Enums.TCAmbiental
  }

  export type CreditTitleAmbientalCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    projetoVinculado?: SortOrder
    metodologiaCertificacao?: SortOrder
    toneladasCO2Equivalente?: SortOrder
    hectaresConservados?: SortOrder
    volumeAguaEconomizadoM3?: SortOrder
  }

  export type CreditTitleAmbientalAvgOrderByAggregateInput = {
    toneladasCO2Equivalente?: SortOrder
    hectaresConservados?: SortOrder
    volumeAguaEconomizadoM3?: SortOrder
  }

  export type CreditTitleAmbientalMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    projetoVinculado?: SortOrder
    metodologiaCertificacao?: SortOrder
    toneladasCO2Equivalente?: SortOrder
    hectaresConservados?: SortOrder
    volumeAguaEconomizadoM3?: SortOrder
  }

  export type CreditTitleAmbientalMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    projetoVinculado?: SortOrder
    metodologiaCertificacao?: SortOrder
    toneladasCO2Equivalente?: SortOrder
    hectaresConservados?: SortOrder
    volumeAguaEconomizadoM3?: SortOrder
  }

  export type CreditTitleAmbientalSumOrderByAggregateInput = {
    toneladasCO2Equivalente?: SortOrder
    hectaresConservados?: SortOrder
    volumeAguaEconomizadoM3?: SortOrder
  }

  export type EnumTCAmbientalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCAmbiental | EnumTCAmbientalFieldRefInput<$PrismaModel>
    in?: $Enums.TCAmbiental[]
    notIn?: $Enums.TCAmbiental[]
    not?: NestedEnumTCAmbientalWithAggregatesFilter<$PrismaModel> | $Enums.TCAmbiental
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCAmbientalFilter<$PrismaModel>
    _max?: NestedEnumTCAmbientalFilter<$PrismaModel>
  }

  export type EnumTCEspecialFilter<$PrismaModel = never> = {
    equals?: $Enums.TCEspecial | EnumTCEspecialFieldRefInput<$PrismaModel>
    in?: $Enums.TCEspecial[]
    notIn?: $Enums.TCEspecial[]
    not?: NestedEnumTCEspecialFilter<$PrismaModel> | $Enums.TCEspecial
  }

  export type CreditTitleEspecialCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    processoRecuperacaoJudicial?: SortOrder
    credorOriginal?: SortOrder
    classeCreditoRJ?: SortOrder
    administradoraConsorcio?: SortOrder
    grupoConsorcio?: SortOrder
    cotaConsorcio?: SortOrder
  }

  export type CreditTitleEspecialMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    processoRecuperacaoJudicial?: SortOrder
    credorOriginal?: SortOrder
    classeCreditoRJ?: SortOrder
    administradoraConsorcio?: SortOrder
    grupoConsorcio?: SortOrder
    cotaConsorcio?: SortOrder
  }

  export type CreditTitleEspecialMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    subType?: SortOrder
    processoRecuperacaoJudicial?: SortOrder
    credorOriginal?: SortOrder
    classeCreditoRJ?: SortOrder
    administradoraConsorcio?: SortOrder
    grupoConsorcio?: SortOrder
    cotaConsorcio?: SortOrder
  }

  export type EnumTCEspecialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCEspecial | EnumTCEspecialFieldRefInput<$PrismaModel>
    in?: $Enums.TCEspecial[]
    notIn?: $Enums.TCEspecial[]
    not?: NestedEnumTCEspecialWithAggregatesFilter<$PrismaModel> | $Enums.TCEspecial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCEspecialFilter<$PrismaModel>
    _max?: NestedEnumTCEspecialFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageLocation?: SortOrder
    hash?: SortOrder
    creditTitleId?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageLocation?: SortOrder
    hash?: SortOrder
    creditTitleId?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageLocation?: SortOrder
    hash?: SortOrder
    creditTitleId?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumOfferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[]
    notIn?: $Enums.OfferType[]
    not?: NestedEnumOfferTypeFilter<$PrismaModel> | $Enums.OfferType
  }

  export type EnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[]
    notIn?: $Enums.OfferStatus[]
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    expiryDate?: SortOrder
    terms?: SortOrder
    quantityAvailable?: SortOrder
    offerType?: SortOrder
    minBidIncrement?: SortOrder
    reservePrice?: SortOrder
    allowPartialPurchase?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    price?: SortOrder
    quantityAvailable?: SortOrder
    minBidIncrement?: SortOrder
    reservePrice?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    expiryDate?: SortOrder
    terms?: SortOrder
    quantityAvailable?: SortOrder
    offerType?: SortOrder
    minBidIncrement?: SortOrder
    reservePrice?: SortOrder
    allowPartialPurchase?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    expiryDate?: SortOrder
    terms?: SortOrder
    quantityAvailable?: SortOrder
    offerType?: SortOrder
    minBidIncrement?: SortOrder
    reservePrice?: SortOrder
    allowPartialPurchase?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    price?: SortOrder
    quantityAvailable?: SortOrder
    minBidIncrement?: SortOrder
    reservePrice?: SortOrder
  }

  export type EnumOfferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[]
    notIn?: $Enums.OfferType[]
    not?: NestedEnumOfferTypeWithAggregatesFilter<$PrismaModel> | $Enums.OfferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferTypeFilter<$PrismaModel>
    _max?: NestedEnumOfferTypeFilter<$PrismaModel>
  }

  export type EnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[]
    notIn?: $Enums.OfferStatus[]
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type EnumBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[]
    notIn?: $Enums.BidStatus[]
    not?: NestedEnumBidStatusFilter<$PrismaModel> | $Enums.BidStatus
  }

  export type OfferScalarRelationFilter = {
    is?: OfferWhereInput
    isNot?: OfferWhereInput
  }

  export type BidCountOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    bidderId?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidAvgOrderByAggregateInput = {
    amount?: SortOrder
    quantity?: SortOrder
  }

  export type BidMaxOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    bidderId?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidMinOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    bidderId?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidSumOrderByAggregateInput = {
    amount?: SortOrder
    quantity?: SortOrder
  }

  export type EnumBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[]
    notIn?: $Enums.BidStatus[]
    not?: NestedEnumBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.BidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidStatusFilter<$PrismaModel>
    _max?: NestedEnumBidStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type OfferNullableScalarRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type BidNullableScalarRelationFilter = {
    is?: BidWhereInput | null
    isNot?: BidWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    offerId?: SortOrder
    bidId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    blockchainData?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    offerId?: SortOrder
    bidId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    blockchainData?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    creditTitleId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    offerId?: SortOrder
    bidId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    blockchainData?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type AuctionCountOrderByAggregateInput = {
    id?: SortOrder
    creditId?: SortOrder
    sellerId?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    minPrice?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    winnerId?: SortOrder
    finalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionAvgOrderByAggregateInput = {
    startPrice?: SortOrder
    minPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type AuctionMaxOrderByAggregateInput = {
    id?: SortOrder
    creditId?: SortOrder
    sellerId?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    minPrice?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    winnerId?: SortOrder
    finalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionMinOrderByAggregateInput = {
    id?: SortOrder
    creditId?: SortOrder
    sellerId?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    minPrice?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    winnerId?: SortOrder
    finalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionSumOrderByAggregateInput = {
    startPrice?: SortOrder
    minPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type SettlementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementAvgOrderByAggregateInput = {
    totalValue?: SortOrder
  }

  export type SettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementSumOrderByAggregateInput = {
    totalValue?: SortOrder
  }

  export type SettlementScalarRelationFilter = {
    is?: SettlementWhereInput
    isNot?: SettlementWhereInput
  }

  export type SettlementParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    settlementId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    value?: SortOrder
    status?: SortOrder
  }

  export type SettlementParticipantAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SettlementParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    settlementId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    value?: SortOrder
    status?: SortOrder
  }

  export type SettlementParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    settlementId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    value?: SortOrder
    status?: SortOrder
  }

  export type SettlementParticipantSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type FiscalObligationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    taxCode?: SortOrder
    taxName?: SortOrder
    taxType?: SortOrder
    taxPeriod?: SortOrder
    taxBase?: SortOrder
    taxRate?: SortOrder
    taxValue?: SortOrder
    taxInterest?: SortOrder
    taxFine?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalObligationAvgOrderByAggregateInput = {
    amount?: SortOrder
    taxBase?: SortOrder
    taxRate?: SortOrder
    taxValue?: SortOrder
    taxInterest?: SortOrder
    taxFine?: SortOrder
    taxTotal?: SortOrder
  }

  export type FiscalObligationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    taxCode?: SortOrder
    taxName?: SortOrder
    taxType?: SortOrder
    taxPeriod?: SortOrder
    taxBase?: SortOrder
    taxRate?: SortOrder
    taxValue?: SortOrder
    taxInterest?: SortOrder
    taxFine?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalObligationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    taxCode?: SortOrder
    taxName?: SortOrder
    taxType?: SortOrder
    taxPeriod?: SortOrder
    taxBase?: SortOrder
    taxRate?: SortOrder
    taxValue?: SortOrder
    taxInterest?: SortOrder
    taxFine?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalObligationSumOrderByAggregateInput = {
    amount?: SortOrder
    taxBase?: SortOrder
    taxRate?: SortOrder
    taxValue?: SortOrder
    taxInterest?: SortOrder
    taxFine?: SortOrder
    taxTotal?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CreditTitleCreateNestedManyWithoutIssuerInput = {
    create?: XOR<CreditTitleCreateWithoutIssuerInput, CreditTitleUncheckedCreateWithoutIssuerInput> | CreditTitleCreateWithoutIssuerInput[] | CreditTitleUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutIssuerInput | CreditTitleCreateOrConnectWithoutIssuerInput[]
    createMany?: CreditTitleCreateManyIssuerInputEnvelope
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
  }

  export type CreditTitleCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CreditTitleCreateWithoutOwnerInput, CreditTitleUncheckedCreateWithoutOwnerInput> | CreditTitleCreateWithoutOwnerInput[] | CreditTitleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutOwnerInput | CreditTitleCreateOrConnectWithoutOwnerInput[]
    createMany?: CreditTitleCreateManyOwnerInputEnvelope
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutSellerInput = {
    create?: XOR<OfferCreateWithoutSellerInput, OfferUncheckedCreateWithoutSellerInput> | OfferCreateWithoutSellerInput[] | OfferUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutSellerInput | OfferCreateOrConnectWithoutSellerInput[]
    createMany?: OfferCreateManySellerInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type BidCreateNestedManyWithoutBidderInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutSellerInput = {
    create?: XOR<TransactionCreateWithoutSellerInput, TransactionUncheckedCreateWithoutSellerInput> | TransactionCreateWithoutSellerInput[] | TransactionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSellerInput | TransactionCreateOrConnectWithoutSellerInput[]
    createMany?: TransactionCreateManySellerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutBuyerInput = {
    create?: XOR<TransactionCreateWithoutBuyerInput, TransactionUncheckedCreateWithoutBuyerInput> | TransactionCreateWithoutBuyerInput[] | TransactionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBuyerInput | TransactionCreateOrConnectWithoutBuyerInput[]
    createMany?: TransactionCreateManyBuyerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TransactionCreateWithoutCreatedByInput, TransactionUncheckedCreateWithoutCreatedByInput> | TransactionCreateWithoutCreatedByInput[] | TransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatedByInput | TransactionCreateOrConnectWithoutCreatedByInput[]
    createMany?: TransactionCreateManyCreatedByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuctionCreateNestedManyWithoutSellerInput = {
    create?: XOR<AuctionCreateWithoutSellerInput, AuctionUncheckedCreateWithoutSellerInput> | AuctionCreateWithoutSellerInput[] | AuctionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutSellerInput | AuctionCreateOrConnectWithoutSellerInput[]
    createMany?: AuctionCreateManySellerInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type AuctionCreateNestedManyWithoutWinnerInput = {
    create?: XOR<AuctionCreateWithoutWinnerInput, AuctionUncheckedCreateWithoutWinnerInput> | AuctionCreateWithoutWinnerInput[] | AuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutWinnerInput | AuctionCreateOrConnectWithoutWinnerInput[]
    createMany?: AuctionCreateManyWinnerInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type SettlementParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<SettlementParticipantCreateWithoutUserInput, SettlementParticipantUncheckedCreateWithoutUserInput> | SettlementParticipantCreateWithoutUserInput[] | SettlementParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutUserInput | SettlementParticipantCreateOrConnectWithoutUserInput[]
    createMany?: SettlementParticipantCreateManyUserInputEnvelope
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type FiscalObligationCreateNestedManyWithoutUserInput = {
    create?: XOR<FiscalObligationCreateWithoutUserInput, FiscalObligationUncheckedCreateWithoutUserInput> | FiscalObligationCreateWithoutUserInput[] | FiscalObligationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiscalObligationCreateOrConnectWithoutUserInput | FiscalObligationCreateOrConnectWithoutUserInput[]
    createMany?: FiscalObligationCreateManyUserInputEnvelope
    connect?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
  }

  export type EmpresaCreateNestedManyWithoutRepresentantePrincipalInput = {
    create?: XOR<EmpresaCreateWithoutRepresentantePrincipalInput, EmpresaUncheckedCreateWithoutRepresentantePrincipalInput> | EmpresaCreateWithoutRepresentantePrincipalInput[] | EmpresaUncheckedCreateWithoutRepresentantePrincipalInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutRepresentantePrincipalInput | EmpresaCreateOrConnectWithoutRepresentantePrincipalInput[]
    createMany?: EmpresaCreateManyRepresentantePrincipalInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CreditTitleUncheckedCreateNestedManyWithoutIssuerInput = {
    create?: XOR<CreditTitleCreateWithoutIssuerInput, CreditTitleUncheckedCreateWithoutIssuerInput> | CreditTitleCreateWithoutIssuerInput[] | CreditTitleUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutIssuerInput | CreditTitleCreateOrConnectWithoutIssuerInput[]
    createMany?: CreditTitleCreateManyIssuerInputEnvelope
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
  }

  export type CreditTitleUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CreditTitleCreateWithoutOwnerInput, CreditTitleUncheckedCreateWithoutOwnerInput> | CreditTitleCreateWithoutOwnerInput[] | CreditTitleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutOwnerInput | CreditTitleCreateOrConnectWithoutOwnerInput[]
    createMany?: CreditTitleCreateManyOwnerInputEnvelope
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<OfferCreateWithoutSellerInput, OfferUncheckedCreateWithoutSellerInput> | OfferCreateWithoutSellerInput[] | OfferUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutSellerInput | OfferCreateOrConnectWithoutSellerInput[]
    createMany?: OfferCreateManySellerInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<TransactionCreateWithoutSellerInput, TransactionUncheckedCreateWithoutSellerInput> | TransactionCreateWithoutSellerInput[] | TransactionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSellerInput | TransactionCreateOrConnectWithoutSellerInput[]
    createMany?: TransactionCreateManySellerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<TransactionCreateWithoutBuyerInput, TransactionUncheckedCreateWithoutBuyerInput> | TransactionCreateWithoutBuyerInput[] | TransactionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBuyerInput | TransactionCreateOrConnectWithoutBuyerInput[]
    createMany?: TransactionCreateManyBuyerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TransactionCreateWithoutCreatedByInput, TransactionUncheckedCreateWithoutCreatedByInput> | TransactionCreateWithoutCreatedByInput[] | TransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatedByInput | TransactionCreateOrConnectWithoutCreatedByInput[]
    createMany?: TransactionCreateManyCreatedByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<AuctionCreateWithoutSellerInput, AuctionUncheckedCreateWithoutSellerInput> | AuctionCreateWithoutSellerInput[] | AuctionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutSellerInput | AuctionCreateOrConnectWithoutSellerInput[]
    createMany?: AuctionCreateManySellerInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<AuctionCreateWithoutWinnerInput, AuctionUncheckedCreateWithoutWinnerInput> | AuctionCreateWithoutWinnerInput[] | AuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutWinnerInput | AuctionCreateOrConnectWithoutWinnerInput[]
    createMany?: AuctionCreateManyWinnerInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type SettlementParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SettlementParticipantCreateWithoutUserInput, SettlementParticipantUncheckedCreateWithoutUserInput> | SettlementParticipantCreateWithoutUserInput[] | SettlementParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutUserInput | SettlementParticipantCreateOrConnectWithoutUserInput[]
    createMany?: SettlementParticipantCreateManyUserInputEnvelope
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type FiscalObligationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FiscalObligationCreateWithoutUserInput, FiscalObligationUncheckedCreateWithoutUserInput> | FiscalObligationCreateWithoutUserInput[] | FiscalObligationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiscalObligationCreateOrConnectWithoutUserInput | FiscalObligationCreateOrConnectWithoutUserInput[]
    createMany?: FiscalObligationCreateManyUserInputEnvelope
    connect?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
  }

  export type EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput = {
    create?: XOR<EmpresaCreateWithoutRepresentantePrincipalInput, EmpresaUncheckedCreateWithoutRepresentantePrincipalInput> | EmpresaCreateWithoutRepresentantePrincipalInput[] | EmpresaUncheckedCreateWithoutRepresentantePrincipalInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutRepresentantePrincipalInput | EmpresaCreateOrConnectWithoutRepresentantePrincipalInput[]
    createMany?: EmpresaCreateManyRepresentantePrincipalInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CreditTitleUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<CreditTitleCreateWithoutIssuerInput, CreditTitleUncheckedCreateWithoutIssuerInput> | CreditTitleCreateWithoutIssuerInput[] | CreditTitleUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutIssuerInput | CreditTitleCreateOrConnectWithoutIssuerInput[]
    upsert?: CreditTitleUpsertWithWhereUniqueWithoutIssuerInput | CreditTitleUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: CreditTitleCreateManyIssuerInputEnvelope
    set?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    disconnect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    delete?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    update?: CreditTitleUpdateWithWhereUniqueWithoutIssuerInput | CreditTitleUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: CreditTitleUpdateManyWithWhereWithoutIssuerInput | CreditTitleUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: CreditTitleScalarWhereInput | CreditTitleScalarWhereInput[]
  }

  export type CreditTitleUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CreditTitleCreateWithoutOwnerInput, CreditTitleUncheckedCreateWithoutOwnerInput> | CreditTitleCreateWithoutOwnerInput[] | CreditTitleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutOwnerInput | CreditTitleCreateOrConnectWithoutOwnerInput[]
    upsert?: CreditTitleUpsertWithWhereUniqueWithoutOwnerInput | CreditTitleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CreditTitleCreateManyOwnerInputEnvelope
    set?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    disconnect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    delete?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    update?: CreditTitleUpdateWithWhereUniqueWithoutOwnerInput | CreditTitleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CreditTitleUpdateManyWithWhereWithoutOwnerInput | CreditTitleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CreditTitleScalarWhereInput | CreditTitleScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutSellerNestedInput = {
    create?: XOR<OfferCreateWithoutSellerInput, OfferUncheckedCreateWithoutSellerInput> | OfferCreateWithoutSellerInput[] | OfferUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutSellerInput | OfferCreateOrConnectWithoutSellerInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutSellerInput | OfferUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: OfferCreateManySellerInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutSellerInput | OfferUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutSellerInput | OfferUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type BidUpdateManyWithoutBidderNestedInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutBidderInput | BidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutBidderInput | BidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: BidUpdateManyWithWhereWithoutBidderInput | BidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutSellerNestedInput = {
    create?: XOR<TransactionCreateWithoutSellerInput, TransactionUncheckedCreateWithoutSellerInput> | TransactionCreateWithoutSellerInput[] | TransactionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSellerInput | TransactionCreateOrConnectWithoutSellerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSellerInput | TransactionUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: TransactionCreateManySellerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSellerInput | TransactionUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSellerInput | TransactionUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<TransactionCreateWithoutBuyerInput, TransactionUncheckedCreateWithoutBuyerInput> | TransactionCreateWithoutBuyerInput[] | TransactionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBuyerInput | TransactionCreateOrConnectWithoutBuyerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBuyerInput | TransactionUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: TransactionCreateManyBuyerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBuyerInput | TransactionUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBuyerInput | TransactionUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatedByInput, TransactionUncheckedCreateWithoutCreatedByInput> | TransactionCreateWithoutCreatedByInput[] | TransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatedByInput | TransactionCreateOrConnectWithoutCreatedByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatedByInput | TransactionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TransactionCreateManyCreatedByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatedByInput | TransactionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatedByInput | TransactionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuctionUpdateManyWithoutSellerNestedInput = {
    create?: XOR<AuctionCreateWithoutSellerInput, AuctionUncheckedCreateWithoutSellerInput> | AuctionCreateWithoutSellerInput[] | AuctionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutSellerInput | AuctionCreateOrConnectWithoutSellerInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutSellerInput | AuctionUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: AuctionCreateManySellerInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutSellerInput | AuctionUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutSellerInput | AuctionUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type AuctionUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<AuctionCreateWithoutWinnerInput, AuctionUncheckedCreateWithoutWinnerInput> | AuctionCreateWithoutWinnerInput[] | AuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutWinnerInput | AuctionCreateOrConnectWithoutWinnerInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutWinnerInput | AuctionUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: AuctionCreateManyWinnerInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutWinnerInput | AuctionUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutWinnerInput | AuctionUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type SettlementParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<SettlementParticipantCreateWithoutUserInput, SettlementParticipantUncheckedCreateWithoutUserInput> | SettlementParticipantCreateWithoutUserInput[] | SettlementParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutUserInput | SettlementParticipantCreateOrConnectWithoutUserInput[]
    upsert?: SettlementParticipantUpsertWithWhereUniqueWithoutUserInput | SettlementParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SettlementParticipantCreateManyUserInputEnvelope
    set?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    disconnect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    delete?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    update?: SettlementParticipantUpdateWithWhereUniqueWithoutUserInput | SettlementParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SettlementParticipantUpdateManyWithWhereWithoutUserInput | SettlementParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SettlementParticipantScalarWhereInput | SettlementParticipantScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type FiscalObligationUpdateManyWithoutUserNestedInput = {
    create?: XOR<FiscalObligationCreateWithoutUserInput, FiscalObligationUncheckedCreateWithoutUserInput> | FiscalObligationCreateWithoutUserInput[] | FiscalObligationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiscalObligationCreateOrConnectWithoutUserInput | FiscalObligationCreateOrConnectWithoutUserInput[]
    upsert?: FiscalObligationUpsertWithWhereUniqueWithoutUserInput | FiscalObligationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FiscalObligationCreateManyUserInputEnvelope
    set?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    disconnect?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    delete?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    connect?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    update?: FiscalObligationUpdateWithWhereUniqueWithoutUserInput | FiscalObligationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FiscalObligationUpdateManyWithWhereWithoutUserInput | FiscalObligationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FiscalObligationScalarWhereInput | FiscalObligationScalarWhereInput[]
  }

  export type EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput = {
    create?: XOR<EmpresaCreateWithoutRepresentantePrincipalInput, EmpresaUncheckedCreateWithoutRepresentantePrincipalInput> | EmpresaCreateWithoutRepresentantePrincipalInput[] | EmpresaUncheckedCreateWithoutRepresentantePrincipalInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutRepresentantePrincipalInput | EmpresaCreateOrConnectWithoutRepresentantePrincipalInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutRepresentantePrincipalInput | EmpresaUpsertWithWhereUniqueWithoutRepresentantePrincipalInput[]
    createMany?: EmpresaCreateManyRepresentantePrincipalInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutRepresentantePrincipalInput | EmpresaUpdateWithWhereUniqueWithoutRepresentantePrincipalInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutRepresentantePrincipalInput | EmpresaUpdateManyWithWhereWithoutRepresentantePrincipalInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<CreditTitleCreateWithoutIssuerInput, CreditTitleUncheckedCreateWithoutIssuerInput> | CreditTitleCreateWithoutIssuerInput[] | CreditTitleUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutIssuerInput | CreditTitleCreateOrConnectWithoutIssuerInput[]
    upsert?: CreditTitleUpsertWithWhereUniqueWithoutIssuerInput | CreditTitleUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: CreditTitleCreateManyIssuerInputEnvelope
    set?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    disconnect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    delete?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    update?: CreditTitleUpdateWithWhereUniqueWithoutIssuerInput | CreditTitleUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: CreditTitleUpdateManyWithWhereWithoutIssuerInput | CreditTitleUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: CreditTitleScalarWhereInput | CreditTitleScalarWhereInput[]
  }

  export type CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CreditTitleCreateWithoutOwnerInput, CreditTitleUncheckedCreateWithoutOwnerInput> | CreditTitleCreateWithoutOwnerInput[] | CreditTitleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CreditTitleCreateOrConnectWithoutOwnerInput | CreditTitleCreateOrConnectWithoutOwnerInput[]
    upsert?: CreditTitleUpsertWithWhereUniqueWithoutOwnerInput | CreditTitleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CreditTitleCreateManyOwnerInputEnvelope
    set?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    disconnect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    delete?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    connect?: CreditTitleWhereUniqueInput | CreditTitleWhereUniqueInput[]
    update?: CreditTitleUpdateWithWhereUniqueWithoutOwnerInput | CreditTitleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CreditTitleUpdateManyWithWhereWithoutOwnerInput | CreditTitleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CreditTitleScalarWhereInput | CreditTitleScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<OfferCreateWithoutSellerInput, OfferUncheckedCreateWithoutSellerInput> | OfferCreateWithoutSellerInput[] | OfferUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutSellerInput | OfferCreateOrConnectWithoutSellerInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutSellerInput | OfferUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: OfferCreateManySellerInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutSellerInput | OfferUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutSellerInput | OfferUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput> | BidCreateWithoutBidderInput[] | BidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderInput | BidCreateOrConnectWithoutBidderInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutBidderInput | BidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: BidCreateManyBidderInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutBidderInput | BidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: BidUpdateManyWithWhereWithoutBidderInput | BidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<TransactionCreateWithoutSellerInput, TransactionUncheckedCreateWithoutSellerInput> | TransactionCreateWithoutSellerInput[] | TransactionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSellerInput | TransactionCreateOrConnectWithoutSellerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSellerInput | TransactionUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: TransactionCreateManySellerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSellerInput | TransactionUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSellerInput | TransactionUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<TransactionCreateWithoutBuyerInput, TransactionUncheckedCreateWithoutBuyerInput> | TransactionCreateWithoutBuyerInput[] | TransactionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBuyerInput | TransactionCreateOrConnectWithoutBuyerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBuyerInput | TransactionUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: TransactionCreateManyBuyerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBuyerInput | TransactionUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBuyerInput | TransactionUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatedByInput, TransactionUncheckedCreateWithoutCreatedByInput> | TransactionCreateWithoutCreatedByInput[] | TransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatedByInput | TransactionCreateOrConnectWithoutCreatedByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatedByInput | TransactionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TransactionCreateManyCreatedByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatedByInput | TransactionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatedByInput | TransactionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<AuctionCreateWithoutSellerInput, AuctionUncheckedCreateWithoutSellerInput> | AuctionCreateWithoutSellerInput[] | AuctionUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutSellerInput | AuctionCreateOrConnectWithoutSellerInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutSellerInput | AuctionUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: AuctionCreateManySellerInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutSellerInput | AuctionUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutSellerInput | AuctionUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<AuctionCreateWithoutWinnerInput, AuctionUncheckedCreateWithoutWinnerInput> | AuctionCreateWithoutWinnerInput[] | AuctionUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutWinnerInput | AuctionCreateOrConnectWithoutWinnerInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutWinnerInput | AuctionUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: AuctionCreateManyWinnerInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutWinnerInput | AuctionUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutWinnerInput | AuctionUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SettlementParticipantCreateWithoutUserInput, SettlementParticipantUncheckedCreateWithoutUserInput> | SettlementParticipantCreateWithoutUserInput[] | SettlementParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutUserInput | SettlementParticipantCreateOrConnectWithoutUserInput[]
    upsert?: SettlementParticipantUpsertWithWhereUniqueWithoutUserInput | SettlementParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SettlementParticipantCreateManyUserInputEnvelope
    set?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    disconnect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    delete?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    update?: SettlementParticipantUpdateWithWhereUniqueWithoutUserInput | SettlementParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SettlementParticipantUpdateManyWithWhereWithoutUserInput | SettlementParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SettlementParticipantScalarWhereInput | SettlementParticipantScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type FiscalObligationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FiscalObligationCreateWithoutUserInput, FiscalObligationUncheckedCreateWithoutUserInput> | FiscalObligationCreateWithoutUserInput[] | FiscalObligationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiscalObligationCreateOrConnectWithoutUserInput | FiscalObligationCreateOrConnectWithoutUserInput[]
    upsert?: FiscalObligationUpsertWithWhereUniqueWithoutUserInput | FiscalObligationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FiscalObligationCreateManyUserInputEnvelope
    set?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    disconnect?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    delete?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    connect?: FiscalObligationWhereUniqueInput | FiscalObligationWhereUniqueInput[]
    update?: FiscalObligationUpdateWithWhereUniqueWithoutUserInput | FiscalObligationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FiscalObligationUpdateManyWithWhereWithoutUserInput | FiscalObligationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FiscalObligationScalarWhereInput | FiscalObligationScalarWhereInput[]
  }

  export type EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput = {
    create?: XOR<EmpresaCreateWithoutRepresentantePrincipalInput, EmpresaUncheckedCreateWithoutRepresentantePrincipalInput> | EmpresaCreateWithoutRepresentantePrincipalInput[] | EmpresaUncheckedCreateWithoutRepresentantePrincipalInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutRepresentantePrincipalInput | EmpresaCreateOrConnectWithoutRepresentantePrincipalInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutRepresentantePrincipalInput | EmpresaUpsertWithWhereUniqueWithoutRepresentantePrincipalInput[]
    createMany?: EmpresaCreateManyRepresentantePrincipalInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutRepresentantePrincipalInput | EmpresaUpdateWithWhereUniqueWithoutRepresentantePrincipalInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutRepresentantePrincipalInput | EmpresaUpdateManyWithWhereWithoutRepresentantePrincipalInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmpresasRepresentadasInput = {
    create?: XOR<UserCreateWithoutEmpresasRepresentadasInput, UserUncheckedCreateWithoutEmpresasRepresentadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmpresasRepresentadasInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmpresasRepresentadasNestedInput = {
    create?: XOR<UserCreateWithoutEmpresasRepresentadasInput, UserUncheckedCreateWithoutEmpresasRepresentadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmpresasRepresentadasInput
    upsert?: UserUpsertWithoutEmpresasRepresentadasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmpresasRepresentadasInput, UserUpdateWithoutEmpresasRepresentadasInput>, UserUncheckedUpdateWithoutEmpresasRepresentadasInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutIssuedCreditsInput = {
    create?: XOR<UserCreateWithoutIssuedCreditsInput, UserUncheckedCreateWithoutIssuedCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIssuedCreditsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedCreditsInput = {
    create?: XOR<UserCreateWithoutOwnedCreditsInput, UserUncheckedCreateWithoutOwnedCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCreditsInput
    connect?: UserWhereUniqueInput
  }

  export type CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleTributarioCreateWithoutCreditTitleInput, CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleTributarioCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleTributarioWhereUniqueInput
  }

  export type CreditTitleComercialCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleComercialCreateWithoutCreditTitleInput, CreditTitleComercialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleComercialCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleComercialWhereUniqueInput
  }

  export type CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleFinanceiroCreateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleFinanceiroCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleFinanceiroWhereUniqueInput
  }

  export type CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleJudicialCreateWithoutCreditTitleInput, CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleJudicialCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleJudicialWhereUniqueInput
  }

  export type CreditTitleRuralCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleRuralCreateWithoutCreditTitleInput, CreditTitleRuralUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleRuralCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleRuralWhereUniqueInput
  }

  export type CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleImobiliarioCreateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleImobiliarioCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleImobiliarioWhereUniqueInput
  }

  export type CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleAmbientalCreateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleAmbientalCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleAmbientalWhereUniqueInput
  }

  export type CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleEspecialCreateWithoutCreditTitleInput, CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleEspecialCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleEspecialWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutCreditTitleInput = {
    create?: XOR<DocumentCreateWithoutCreditTitleInput, DocumentUncheckedCreateWithoutCreditTitleInput> | DocumentCreateWithoutCreditTitleInput[] | DocumentUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreditTitleInput | DocumentCreateOrConnectWithoutCreditTitleInput[]
    createMany?: DocumentCreateManyCreditTitleInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutCreditTitleInput = {
    create?: XOR<OfferCreateWithoutCreditTitleInput, OfferUncheckedCreateWithoutCreditTitleInput> | OfferCreateWithoutCreditTitleInput[] | OfferUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCreditTitleInput | OfferCreateOrConnectWithoutCreditTitleInput[]
    createMany?: OfferCreateManyCreditTitleInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCreditTitleInput = {
    create?: XOR<TransactionCreateWithoutCreditTitleInput, TransactionUncheckedCreateWithoutCreditTitleInput> | TransactionCreateWithoutCreditTitleInput[] | TransactionUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditTitleInput | TransactionCreateOrConnectWithoutCreditTitleInput[]
    createMany?: TransactionCreateManyCreditTitleInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuctionCreateNestedManyWithoutCreditInput = {
    create?: XOR<AuctionCreateWithoutCreditInput, AuctionUncheckedCreateWithoutCreditInput> | AuctionCreateWithoutCreditInput[] | AuctionUncheckedCreateWithoutCreditInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCreditInput | AuctionCreateOrConnectWithoutCreditInput[]
    createMany?: AuctionCreateManyCreditInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleTributarioCreateWithoutCreditTitleInput, CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleTributarioCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleTributarioWhereUniqueInput
  }

  export type CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleComercialCreateWithoutCreditTitleInput, CreditTitleComercialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleComercialCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleComercialWhereUniqueInput
  }

  export type CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleFinanceiroCreateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleFinanceiroCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleFinanceiroWhereUniqueInput
  }

  export type CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleJudicialCreateWithoutCreditTitleInput, CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleJudicialCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleJudicialWhereUniqueInput
  }

  export type CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleRuralCreateWithoutCreditTitleInput, CreditTitleRuralUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleRuralCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleRuralWhereUniqueInput
  }

  export type CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleImobiliarioCreateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleImobiliarioCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleImobiliarioWhereUniqueInput
  }

  export type CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleAmbientalCreateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleAmbientalCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleAmbientalWhereUniqueInput
  }

  export type CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput = {
    create?: XOR<CreditTitleEspecialCreateWithoutCreditTitleInput, CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleEspecialCreateOrConnectWithoutCreditTitleInput
    connect?: CreditTitleEspecialWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutCreditTitleInput = {
    create?: XOR<DocumentCreateWithoutCreditTitleInput, DocumentUncheckedCreateWithoutCreditTitleInput> | DocumentCreateWithoutCreditTitleInput[] | DocumentUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreditTitleInput | DocumentCreateOrConnectWithoutCreditTitleInput[]
    createMany?: DocumentCreateManyCreditTitleInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutCreditTitleInput = {
    create?: XOR<OfferCreateWithoutCreditTitleInput, OfferUncheckedCreateWithoutCreditTitleInput> | OfferCreateWithoutCreditTitleInput[] | OfferUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCreditTitleInput | OfferCreateOrConnectWithoutCreditTitleInput[]
    createMany?: OfferCreateManyCreditTitleInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreditTitleInput = {
    create?: XOR<TransactionCreateWithoutCreditTitleInput, TransactionUncheckedCreateWithoutCreditTitleInput> | TransactionCreateWithoutCreditTitleInput[] | TransactionUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditTitleInput | TransactionCreateOrConnectWithoutCreditTitleInput[]
    createMany?: TransactionCreateManyCreditTitleInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutCreditInput = {
    create?: XOR<AuctionCreateWithoutCreditInput, AuctionUncheckedCreateWithoutCreditInput> | AuctionCreateWithoutCreditInput[] | AuctionUncheckedCreateWithoutCreditInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCreditInput | AuctionCreateOrConnectWithoutCreditInput[]
    createMany?: AuctionCreateManyCreditInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type EnumCreditCategoryFieldUpdateOperationsInput = {
    set?: $Enums.CreditCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCreditStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreditStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutIssuedCreditsNestedInput = {
    create?: XOR<UserCreateWithoutIssuedCreditsInput, UserUncheckedCreateWithoutIssuedCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIssuedCreditsInput
    upsert?: UserUpsertWithoutIssuedCreditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIssuedCreditsInput, UserUpdateWithoutIssuedCreditsInput>, UserUncheckedUpdateWithoutIssuedCreditsInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedCreditsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedCreditsInput, UserUncheckedCreateWithoutOwnedCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCreditsInput
    upsert?: UserUpsertWithoutOwnedCreditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedCreditsInput, UserUpdateWithoutOwnedCreditsInput>, UserUncheckedUpdateWithoutOwnedCreditsInput>
  }

  export type CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleTributarioCreateWithoutCreditTitleInput, CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleTributarioCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleTributarioUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleTributarioWhereInput | boolean
    delete?: CreditTitleTributarioWhereInput | boolean
    connect?: CreditTitleTributarioWhereUniqueInput
    update?: XOR<XOR<CreditTitleTributarioUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleTributarioUpdateWithoutCreditTitleInput>, CreditTitleTributarioUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleComercialCreateWithoutCreditTitleInput, CreditTitleComercialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleComercialCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleComercialUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleComercialWhereInput | boolean
    delete?: CreditTitleComercialWhereInput | boolean
    connect?: CreditTitleComercialWhereUniqueInput
    update?: XOR<XOR<CreditTitleComercialUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleComercialUpdateWithoutCreditTitleInput>, CreditTitleComercialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleFinanceiroCreateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleFinanceiroCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleFinanceiroUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleFinanceiroWhereInput | boolean
    delete?: CreditTitleFinanceiroWhereInput | boolean
    connect?: CreditTitleFinanceiroWhereUniqueInput
    update?: XOR<XOR<CreditTitleFinanceiroUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleFinanceiroUpdateWithoutCreditTitleInput>, CreditTitleFinanceiroUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleJudicialCreateWithoutCreditTitleInput, CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleJudicialCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleJudicialUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleJudicialWhereInput | boolean
    delete?: CreditTitleJudicialWhereInput | boolean
    connect?: CreditTitleJudicialWhereUniqueInput
    update?: XOR<XOR<CreditTitleJudicialUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleJudicialUpdateWithoutCreditTitleInput>, CreditTitleJudicialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleRuralCreateWithoutCreditTitleInput, CreditTitleRuralUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleRuralCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleRuralUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleRuralWhereInput | boolean
    delete?: CreditTitleRuralWhereInput | boolean
    connect?: CreditTitleRuralWhereUniqueInput
    update?: XOR<XOR<CreditTitleRuralUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleRuralUpdateWithoutCreditTitleInput>, CreditTitleRuralUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleImobiliarioCreateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleImobiliarioCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleImobiliarioUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleImobiliarioWhereInput | boolean
    delete?: CreditTitleImobiliarioWhereInput | boolean
    connect?: CreditTitleImobiliarioWhereUniqueInput
    update?: XOR<XOR<CreditTitleImobiliarioUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleImobiliarioUpdateWithoutCreditTitleInput>, CreditTitleImobiliarioUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleAmbientalCreateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleAmbientalCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleAmbientalUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleAmbientalWhereInput | boolean
    delete?: CreditTitleAmbientalWhereInput | boolean
    connect?: CreditTitleAmbientalWhereUniqueInput
    update?: XOR<XOR<CreditTitleAmbientalUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleAmbientalUpdateWithoutCreditTitleInput>, CreditTitleAmbientalUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleEspecialCreateWithoutCreditTitleInput, CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleEspecialCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleEspecialUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleEspecialWhereInput | boolean
    delete?: CreditTitleEspecialWhereInput | boolean
    connect?: CreditTitleEspecialWhereUniqueInput
    update?: XOR<XOR<CreditTitleEspecialUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleEspecialUpdateWithoutCreditTitleInput>, CreditTitleEspecialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type DocumentUpdateManyWithoutCreditTitleNestedInput = {
    create?: XOR<DocumentCreateWithoutCreditTitleInput, DocumentUncheckedCreateWithoutCreditTitleInput> | DocumentCreateWithoutCreditTitleInput[] | DocumentUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreditTitleInput | DocumentCreateOrConnectWithoutCreditTitleInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCreditTitleInput | DocumentUpsertWithWhereUniqueWithoutCreditTitleInput[]
    createMany?: DocumentCreateManyCreditTitleInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCreditTitleInput | DocumentUpdateWithWhereUniqueWithoutCreditTitleInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCreditTitleInput | DocumentUpdateManyWithWhereWithoutCreditTitleInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutCreditTitleNestedInput = {
    create?: XOR<OfferCreateWithoutCreditTitleInput, OfferUncheckedCreateWithoutCreditTitleInput> | OfferCreateWithoutCreditTitleInput[] | OfferUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCreditTitleInput | OfferCreateOrConnectWithoutCreditTitleInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutCreditTitleInput | OfferUpsertWithWhereUniqueWithoutCreditTitleInput[]
    createMany?: OfferCreateManyCreditTitleInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutCreditTitleInput | OfferUpdateWithWhereUniqueWithoutCreditTitleInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutCreditTitleInput | OfferUpdateManyWithWhereWithoutCreditTitleInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCreditTitleNestedInput = {
    create?: XOR<TransactionCreateWithoutCreditTitleInput, TransactionUncheckedCreateWithoutCreditTitleInput> | TransactionCreateWithoutCreditTitleInput[] | TransactionUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditTitleInput | TransactionCreateOrConnectWithoutCreditTitleInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreditTitleInput | TransactionUpsertWithWhereUniqueWithoutCreditTitleInput[]
    createMany?: TransactionCreateManyCreditTitleInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreditTitleInput | TransactionUpdateWithWhereUniqueWithoutCreditTitleInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreditTitleInput | TransactionUpdateManyWithWhereWithoutCreditTitleInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuctionUpdateManyWithoutCreditNestedInput = {
    create?: XOR<AuctionCreateWithoutCreditInput, AuctionUncheckedCreateWithoutCreditInput> | AuctionCreateWithoutCreditInput[] | AuctionUncheckedCreateWithoutCreditInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCreditInput | AuctionCreateOrConnectWithoutCreditInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutCreditInput | AuctionUpsertWithWhereUniqueWithoutCreditInput[]
    createMany?: AuctionCreateManyCreditInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutCreditInput | AuctionUpdateWithWhereUniqueWithoutCreditInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutCreditInput | AuctionUpdateManyWithWhereWithoutCreditInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleTributarioCreateWithoutCreditTitleInput, CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleTributarioCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleTributarioUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleTributarioWhereInput | boolean
    delete?: CreditTitleTributarioWhereInput | boolean
    connect?: CreditTitleTributarioWhereUniqueInput
    update?: XOR<XOR<CreditTitleTributarioUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleTributarioUpdateWithoutCreditTitleInput>, CreditTitleTributarioUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleComercialCreateWithoutCreditTitleInput, CreditTitleComercialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleComercialCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleComercialUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleComercialWhereInput | boolean
    delete?: CreditTitleComercialWhereInput | boolean
    connect?: CreditTitleComercialWhereUniqueInput
    update?: XOR<XOR<CreditTitleComercialUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleComercialUpdateWithoutCreditTitleInput>, CreditTitleComercialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleFinanceiroCreateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleFinanceiroCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleFinanceiroUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleFinanceiroWhereInput | boolean
    delete?: CreditTitleFinanceiroWhereInput | boolean
    connect?: CreditTitleFinanceiroWhereUniqueInput
    update?: XOR<XOR<CreditTitleFinanceiroUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleFinanceiroUpdateWithoutCreditTitleInput>, CreditTitleFinanceiroUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleJudicialCreateWithoutCreditTitleInput, CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleJudicialCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleJudicialUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleJudicialWhereInput | boolean
    delete?: CreditTitleJudicialWhereInput | boolean
    connect?: CreditTitleJudicialWhereUniqueInput
    update?: XOR<XOR<CreditTitleJudicialUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleJudicialUpdateWithoutCreditTitleInput>, CreditTitleJudicialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleRuralCreateWithoutCreditTitleInput, CreditTitleRuralUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleRuralCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleRuralUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleRuralWhereInput | boolean
    delete?: CreditTitleRuralWhereInput | boolean
    connect?: CreditTitleRuralWhereUniqueInput
    update?: XOR<XOR<CreditTitleRuralUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleRuralUpdateWithoutCreditTitleInput>, CreditTitleRuralUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleImobiliarioCreateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleImobiliarioCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleImobiliarioUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleImobiliarioWhereInput | boolean
    delete?: CreditTitleImobiliarioWhereInput | boolean
    connect?: CreditTitleImobiliarioWhereUniqueInput
    update?: XOR<XOR<CreditTitleImobiliarioUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleImobiliarioUpdateWithoutCreditTitleInput>, CreditTitleImobiliarioUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleAmbientalCreateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleAmbientalCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleAmbientalUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleAmbientalWhereInput | boolean
    delete?: CreditTitleAmbientalWhereInput | boolean
    connect?: CreditTitleAmbientalWhereUniqueInput
    update?: XOR<XOR<CreditTitleAmbientalUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleAmbientalUpdateWithoutCreditTitleInput>, CreditTitleAmbientalUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput = {
    create?: XOR<CreditTitleEspecialCreateWithoutCreditTitleInput, CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput>
    connectOrCreate?: CreditTitleEspecialCreateOrConnectWithoutCreditTitleInput
    upsert?: CreditTitleEspecialUpsertWithoutCreditTitleInput
    disconnect?: CreditTitleEspecialWhereInput | boolean
    delete?: CreditTitleEspecialWhereInput | boolean
    connect?: CreditTitleEspecialWhereUniqueInput
    update?: XOR<XOR<CreditTitleEspecialUpdateToOneWithWhereWithoutCreditTitleInput, CreditTitleEspecialUpdateWithoutCreditTitleInput>, CreditTitleEspecialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput = {
    create?: XOR<DocumentCreateWithoutCreditTitleInput, DocumentUncheckedCreateWithoutCreditTitleInput> | DocumentCreateWithoutCreditTitleInput[] | DocumentUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreditTitleInput | DocumentCreateOrConnectWithoutCreditTitleInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCreditTitleInput | DocumentUpsertWithWhereUniqueWithoutCreditTitleInput[]
    createMany?: DocumentCreateManyCreditTitleInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCreditTitleInput | DocumentUpdateWithWhereUniqueWithoutCreditTitleInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCreditTitleInput | DocumentUpdateManyWithWhereWithoutCreditTitleInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutCreditTitleNestedInput = {
    create?: XOR<OfferCreateWithoutCreditTitleInput, OfferUncheckedCreateWithoutCreditTitleInput> | OfferCreateWithoutCreditTitleInput[] | OfferUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutCreditTitleInput | OfferCreateOrConnectWithoutCreditTitleInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutCreditTitleInput | OfferUpsertWithWhereUniqueWithoutCreditTitleInput[]
    createMany?: OfferCreateManyCreditTitleInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutCreditTitleInput | OfferUpdateWithWhereUniqueWithoutCreditTitleInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutCreditTitleInput | OfferUpdateManyWithWhereWithoutCreditTitleInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput = {
    create?: XOR<TransactionCreateWithoutCreditTitleInput, TransactionUncheckedCreateWithoutCreditTitleInput> | TransactionCreateWithoutCreditTitleInput[] | TransactionUncheckedCreateWithoutCreditTitleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditTitleInput | TransactionCreateOrConnectWithoutCreditTitleInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreditTitleInput | TransactionUpsertWithWhereUniqueWithoutCreditTitleInput[]
    createMany?: TransactionCreateManyCreditTitleInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreditTitleInput | TransactionUpdateWithWhereUniqueWithoutCreditTitleInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreditTitleInput | TransactionUpdateManyWithWhereWithoutCreditTitleInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutCreditNestedInput = {
    create?: XOR<AuctionCreateWithoutCreditInput, AuctionUncheckedCreateWithoutCreditInput> | AuctionCreateWithoutCreditInput[] | AuctionUncheckedCreateWithoutCreditInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCreditInput | AuctionCreateOrConnectWithoutCreditInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutCreditInput | AuctionUpsertWithWhereUniqueWithoutCreditInput[]
    createMany?: AuctionCreateManyCreditInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutCreditInput | AuctionUpdateWithWhereUniqueWithoutCreditInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutCreditInput | AuctionUpdateManyWithWhereWithoutCreditInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type CreditTitleCreateNestedOneWithoutDetailsTributarioInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsTributarioInput, CreditTitleUncheckedCreateWithoutDetailsTributarioInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsTributarioInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type NullableEnumTCTributarioFederalFieldUpdateOperationsInput = {
    set?: $Enums.TCTributarioFederal | null
  }

  export type NullableEnumTCTributarioEstadualFieldUpdateOperationsInput = {
    set?: $Enums.TCTributarioEstadual | null
  }

  export type NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput = {
    set?: $Enums.TCTributarioMunicipal | null
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsTributarioNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsTributarioInput, CreditTitleUncheckedCreateWithoutDetailsTributarioInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsTributarioInput
    upsert?: CreditTitleUpsertWithoutDetailsTributarioInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsTributarioInput, CreditTitleUpdateWithoutDetailsTributarioInput>, CreditTitleUncheckedUpdateWithoutDetailsTributarioInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsComercialInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsComercialInput, CreditTitleUncheckedCreateWithoutDetailsComercialInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsComercialInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCComercialFieldUpdateOperationsInput = {
    set?: $Enums.TCComercial
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsComercialNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsComercialInput, CreditTitleUncheckedCreateWithoutDetailsComercialInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsComercialInput
    upsert?: CreditTitleUpsertWithoutDetailsComercialInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsComercialInput, CreditTitleUpdateWithoutDetailsComercialInput>, CreditTitleUncheckedUpdateWithoutDetailsComercialInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsFinanceiroInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsFinanceiroInput, CreditTitleUncheckedCreateWithoutDetailsFinanceiroInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsFinanceiroInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCFinanceiroFieldUpdateOperationsInput = {
    set?: $Enums.TCFinanceiro
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsFinanceiroNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsFinanceiroInput, CreditTitleUncheckedCreateWithoutDetailsFinanceiroInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsFinanceiroInput
    upsert?: CreditTitleUpsertWithoutDetailsFinanceiroInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsFinanceiroInput, CreditTitleUpdateWithoutDetailsFinanceiroInput>, CreditTitleUncheckedUpdateWithoutDetailsFinanceiroInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsJudicialInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsJudicialInput, CreditTitleUncheckedCreateWithoutDetailsJudicialInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsJudicialInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCJudicialFieldUpdateOperationsInput = {
    set?: $Enums.TCJudicial
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsJudicialNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsJudicialInput, CreditTitleUncheckedCreateWithoutDetailsJudicialInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsJudicialInput
    upsert?: CreditTitleUpsertWithoutDetailsJudicialInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsJudicialInput, CreditTitleUpdateWithoutDetailsJudicialInput>, CreditTitleUncheckedUpdateWithoutDetailsJudicialInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsRuralInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsRuralInput, CreditTitleUncheckedCreateWithoutDetailsRuralInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsRuralInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCRuralFieldUpdateOperationsInput = {
    set?: $Enums.TCRural
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsRuralNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsRuralInput, CreditTitleUncheckedCreateWithoutDetailsRuralInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsRuralInput
    upsert?: CreditTitleUpsertWithoutDetailsRuralInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsRuralInput, CreditTitleUpdateWithoutDetailsRuralInput>, CreditTitleUncheckedUpdateWithoutDetailsRuralInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsImobiliarioInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsImobiliarioInput, CreditTitleUncheckedCreateWithoutDetailsImobiliarioInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsImobiliarioInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCImobiliarioFieldUpdateOperationsInput = {
    set?: $Enums.TCImobiliario
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsImobiliarioNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsImobiliarioInput, CreditTitleUncheckedCreateWithoutDetailsImobiliarioInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsImobiliarioInput
    upsert?: CreditTitleUpsertWithoutDetailsImobiliarioInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsImobiliarioInput, CreditTitleUpdateWithoutDetailsImobiliarioInput>, CreditTitleUncheckedUpdateWithoutDetailsImobiliarioInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsAmbientalInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsAmbientalInput, CreditTitleUncheckedCreateWithoutDetailsAmbientalInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsAmbientalInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCAmbientalFieldUpdateOperationsInput = {
    set?: $Enums.TCAmbiental
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsAmbientalNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsAmbientalInput, CreditTitleUncheckedCreateWithoutDetailsAmbientalInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsAmbientalInput
    upsert?: CreditTitleUpsertWithoutDetailsAmbientalInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsAmbientalInput, CreditTitleUpdateWithoutDetailsAmbientalInput>, CreditTitleUncheckedUpdateWithoutDetailsAmbientalInput>
  }

  export type CreditTitleCreateNestedOneWithoutDetailsEspecialInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsEspecialInput, CreditTitleUncheckedCreateWithoutDetailsEspecialInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsEspecialInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type EnumTCEspecialFieldUpdateOperationsInput = {
    set?: $Enums.TCEspecial
  }

  export type CreditTitleUpdateOneRequiredWithoutDetailsEspecialNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDetailsEspecialInput, CreditTitleUncheckedCreateWithoutDetailsEspecialInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDetailsEspecialInput
    upsert?: CreditTitleUpsertWithoutDetailsEspecialInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDetailsEspecialInput, CreditTitleUpdateWithoutDetailsEspecialInput>, CreditTitleUncheckedUpdateWithoutDetailsEspecialInput>
  }

  export type CreditTitleCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CreditTitleCreateWithoutDocumentsInput, CreditTitleUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDocumentsInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreditTitleUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CreditTitleCreateWithoutDocumentsInput, CreditTitleUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutDocumentsInput
    upsert?: CreditTitleUpsertWithoutDocumentsInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutDocumentsInput, CreditTitleUpdateWithoutDocumentsInput>, CreditTitleUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type CreditTitleCreateNestedOneWithoutOffersInput = {
    create?: XOR<CreditTitleCreateWithoutOffersInput, CreditTitleUncheckedCreateWithoutOffersInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutOffersInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOffersInput = {
    create?: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersInput
    connect?: UserWhereUniqueInput
  }

  export type BidCreateNestedManyWithoutOfferInput = {
    create?: XOR<BidCreateWithoutOfferInput, BidUncheckedCreateWithoutOfferInput> | BidCreateWithoutOfferInput[] | BidUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: BidCreateOrConnectWithoutOfferInput | BidCreateOrConnectWithoutOfferInput[]
    createMany?: BidCreateManyOfferInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutOfferInput = {
    create?: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput> | TransactionCreateWithoutOfferInput[] | TransactionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOfferInput | TransactionCreateOrConnectWithoutOfferInput[]
    createMany?: TransactionCreateManyOfferInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<BidCreateWithoutOfferInput, BidUncheckedCreateWithoutOfferInput> | BidCreateWithoutOfferInput[] | BidUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: BidCreateOrConnectWithoutOfferInput | BidCreateOrConnectWithoutOfferInput[]
    createMany?: BidCreateManyOfferInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput> | TransactionCreateWithoutOfferInput[] | TransactionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOfferInput | TransactionCreateOrConnectWithoutOfferInput[]
    createMany?: TransactionCreateManyOfferInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumOfferTypeFieldUpdateOperationsInput = {
    set?: $Enums.OfferType
  }

  export type EnumOfferStatusFieldUpdateOperationsInput = {
    set?: $Enums.OfferStatus
  }

  export type CreditTitleUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<CreditTitleCreateWithoutOffersInput, CreditTitleUncheckedCreateWithoutOffersInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutOffersInput
    upsert?: CreditTitleUpsertWithoutOffersInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutOffersInput, CreditTitleUpdateWithoutOffersInput>, CreditTitleUncheckedUpdateWithoutOffersInput>
  }

  export type UserUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersInput
    upsert?: UserUpsertWithoutOffersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOffersInput, UserUpdateWithoutOffersInput>, UserUncheckedUpdateWithoutOffersInput>
  }

  export type BidUpdateManyWithoutOfferNestedInput = {
    create?: XOR<BidCreateWithoutOfferInput, BidUncheckedCreateWithoutOfferInput> | BidCreateWithoutOfferInput[] | BidUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: BidCreateOrConnectWithoutOfferInput | BidCreateOrConnectWithoutOfferInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutOfferInput | BidUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: BidCreateManyOfferInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutOfferInput | BidUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: BidUpdateManyWithWhereWithoutOfferInput | BidUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutOfferNestedInput = {
    create?: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput> | TransactionCreateWithoutOfferInput[] | TransactionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOfferInput | TransactionCreateOrConnectWithoutOfferInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutOfferInput | TransactionUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: TransactionCreateManyOfferInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutOfferInput | TransactionUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutOfferInput | TransactionUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<BidCreateWithoutOfferInput, BidUncheckedCreateWithoutOfferInput> | BidCreateWithoutOfferInput[] | BidUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: BidCreateOrConnectWithoutOfferInput | BidCreateOrConnectWithoutOfferInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutOfferInput | BidUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: BidCreateManyOfferInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutOfferInput | BidUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: BidUpdateManyWithWhereWithoutOfferInput | BidUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput> | TransactionCreateWithoutOfferInput[] | TransactionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOfferInput | TransactionCreateOrConnectWithoutOfferInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutOfferInput | TransactionUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: TransactionCreateManyOfferInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutOfferInput | TransactionUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutOfferInput | TransactionUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type OfferCreateNestedOneWithoutBidsInput = {
    create?: XOR<OfferCreateWithoutBidsInput, OfferUncheckedCreateWithoutBidsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutBidsInput
    connect?: OfferWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBidsInput = {
    create?: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBidsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutBidInput = {
    create?: XOR<TransactionCreateWithoutBidInput, TransactionUncheckedCreateWithoutBidInput> | TransactionCreateWithoutBidInput[] | TransactionUncheckedCreateWithoutBidInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBidInput | TransactionCreateOrConnectWithoutBidInput[]
    createMany?: TransactionCreateManyBidInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBidInput = {
    create?: XOR<TransactionCreateWithoutBidInput, TransactionUncheckedCreateWithoutBidInput> | TransactionCreateWithoutBidInput[] | TransactionUncheckedCreateWithoutBidInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBidInput | TransactionCreateOrConnectWithoutBidInput[]
    createMany?: TransactionCreateManyBidInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumBidStatusFieldUpdateOperationsInput = {
    set?: $Enums.BidStatus
  }

  export type OfferUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<OfferCreateWithoutBidsInput, OfferUncheckedCreateWithoutBidsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutBidsInput
    upsert?: OfferUpsertWithoutBidsInput
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutBidsInput, OfferUpdateWithoutBidsInput>, OfferUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBidsInput
    upsert?: UserUpsertWithoutBidsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBidsInput, UserUpdateWithoutBidsInput>, UserUncheckedUpdateWithoutBidsInput>
  }

  export type TransactionUpdateManyWithoutBidNestedInput = {
    create?: XOR<TransactionCreateWithoutBidInput, TransactionUncheckedCreateWithoutBidInput> | TransactionCreateWithoutBidInput[] | TransactionUncheckedCreateWithoutBidInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBidInput | TransactionCreateOrConnectWithoutBidInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBidInput | TransactionUpsertWithWhereUniqueWithoutBidInput[]
    createMany?: TransactionCreateManyBidInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBidInput | TransactionUpdateWithWhereUniqueWithoutBidInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBidInput | TransactionUpdateManyWithWhereWithoutBidInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBidNestedInput = {
    create?: XOR<TransactionCreateWithoutBidInput, TransactionUncheckedCreateWithoutBidInput> | TransactionCreateWithoutBidInput[] | TransactionUncheckedCreateWithoutBidInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBidInput | TransactionCreateOrConnectWithoutBidInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBidInput | TransactionUpsertWithWhereUniqueWithoutBidInput[]
    createMany?: TransactionCreateManyBidInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBidInput | TransactionUpdateWithWhereUniqueWithoutBidInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBidInput | TransactionUpdateManyWithWhereWithoutBidInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CreditTitleCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CreditTitleCreateWithoutTransactionsInput, CreditTitleUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutTransactionsInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsAsSellerInput = {
    create?: XOR<UserCreateWithoutTransactionsAsSellerInput, UserUncheckedCreateWithoutTransactionsAsSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsAsSellerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsAsBuyerInput = {
    create?: XOR<UserCreateWithoutTransactionsAsBuyerInput, UserUncheckedCreateWithoutTransactionsAsBuyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsAsBuyerInput
    connect?: UserWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<OfferCreateWithoutTransactionsInput, OfferUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutTransactionsInput
    connect?: OfferWhereUniqueInput
  }

  export type BidCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BidCreateWithoutTransactionsInput, BidUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BidCreateOrConnectWithoutTransactionsInput
    connect?: BidWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTransactionsInput = {
    create?: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CreditTitleCreateWithoutTransactionsInput, CreditTitleUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutTransactionsInput
    upsert?: CreditTitleUpsertWithoutTransactionsInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutTransactionsInput, CreditTitleUpdateWithoutTransactionsInput>, CreditTitleUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsAsSellerInput, UserUncheckedCreateWithoutTransactionsAsSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsAsSellerInput
    upsert?: UserUpsertWithoutTransactionsAsSellerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsAsSellerInput, UserUpdateWithoutTransactionsAsSellerInput>, UserUncheckedUpdateWithoutTransactionsAsSellerInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsAsBuyerInput, UserUncheckedCreateWithoutTransactionsAsBuyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsAsBuyerInput
    upsert?: UserUpsertWithoutTransactionsAsBuyerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsAsBuyerInput, UserUpdateWithoutTransactionsAsBuyerInput>, UserUncheckedUpdateWithoutTransactionsAsBuyerInput>
  }

  export type OfferUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<OfferCreateWithoutTransactionsInput, OfferUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutTransactionsInput
    upsert?: OfferUpsertWithoutTransactionsInput
    disconnect?: OfferWhereInput | boolean
    delete?: OfferWhereInput | boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutTransactionsInput, OfferUpdateWithoutTransactionsInput>, OfferUncheckedUpdateWithoutTransactionsInput>
  }

  export type BidUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<BidCreateWithoutTransactionsInput, BidUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BidCreateOrConnectWithoutTransactionsInput
    upsert?: BidUpsertWithoutTransactionsInput
    disconnect?: BidWhereInput | boolean
    delete?: BidWhereInput | boolean
    connect?: BidWhereUniqueInput
    update?: XOR<XOR<BidUpdateToOneWithWhereWithoutTransactionsInput, BidUpdateWithoutTransactionsInput>, BidUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneWithoutCreatedTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransactionsInput
    upsert?: UserUpsertWithoutCreatedTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTransactionsInput, UserUpdateWithoutCreatedTransactionsInput>, UserUncheckedUpdateWithoutCreatedTransactionsInput>
  }

  export type CreditTitleCreateNestedOneWithoutAuctionsInput = {
    create?: XOR<CreditTitleCreateWithoutAuctionsInput, CreditTitleUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutAuctionsInput
    connect?: CreditTitleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuctionsAsSellerInput = {
    create?: XOR<UserCreateWithoutAuctionsAsSellerInput, UserUncheckedCreateWithoutAuctionsAsSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuctionsAsSellerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuctionsAsWinnerInput = {
    create?: XOR<UserCreateWithoutAuctionsAsWinnerInput, UserUncheckedCreateWithoutAuctionsAsWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuctionsAsWinnerInput
    connect?: UserWhereUniqueInput
  }

  export type CreditTitleUpdateOneRequiredWithoutAuctionsNestedInput = {
    create?: XOR<CreditTitleCreateWithoutAuctionsInput, CreditTitleUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: CreditTitleCreateOrConnectWithoutAuctionsInput
    upsert?: CreditTitleUpsertWithoutAuctionsInput
    connect?: CreditTitleWhereUniqueInput
    update?: XOR<XOR<CreditTitleUpdateToOneWithWhereWithoutAuctionsInput, CreditTitleUpdateWithoutAuctionsInput>, CreditTitleUncheckedUpdateWithoutAuctionsInput>
  }

  export type UserUpdateOneRequiredWithoutAuctionsAsSellerNestedInput = {
    create?: XOR<UserCreateWithoutAuctionsAsSellerInput, UserUncheckedCreateWithoutAuctionsAsSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuctionsAsSellerInput
    upsert?: UserUpsertWithoutAuctionsAsSellerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuctionsAsSellerInput, UserUpdateWithoutAuctionsAsSellerInput>, UserUncheckedUpdateWithoutAuctionsAsSellerInput>
  }

  export type UserUpdateOneWithoutAuctionsAsWinnerNestedInput = {
    create?: XOR<UserCreateWithoutAuctionsAsWinnerInput, UserUncheckedCreateWithoutAuctionsAsWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuctionsAsWinnerInput
    upsert?: UserUpsertWithoutAuctionsAsWinnerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuctionsAsWinnerInput, UserUpdateWithoutAuctionsAsWinnerInput>, UserUncheckedUpdateWithoutAuctionsAsWinnerInput>
  }

  export type SettlementParticipantCreateNestedManyWithoutSettlementInput = {
    create?: XOR<SettlementParticipantCreateWithoutSettlementInput, SettlementParticipantUncheckedCreateWithoutSettlementInput> | SettlementParticipantCreateWithoutSettlementInput[] | SettlementParticipantUncheckedCreateWithoutSettlementInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutSettlementInput | SettlementParticipantCreateOrConnectWithoutSettlementInput[]
    createMany?: SettlementParticipantCreateManySettlementInputEnvelope
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
  }

  export type SettlementParticipantUncheckedCreateNestedManyWithoutSettlementInput = {
    create?: XOR<SettlementParticipantCreateWithoutSettlementInput, SettlementParticipantUncheckedCreateWithoutSettlementInput> | SettlementParticipantCreateWithoutSettlementInput[] | SettlementParticipantUncheckedCreateWithoutSettlementInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutSettlementInput | SettlementParticipantCreateOrConnectWithoutSettlementInput[]
    createMany?: SettlementParticipantCreateManySettlementInputEnvelope
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
  }

  export type SettlementParticipantUpdateManyWithoutSettlementNestedInput = {
    create?: XOR<SettlementParticipantCreateWithoutSettlementInput, SettlementParticipantUncheckedCreateWithoutSettlementInput> | SettlementParticipantCreateWithoutSettlementInput[] | SettlementParticipantUncheckedCreateWithoutSettlementInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutSettlementInput | SettlementParticipantCreateOrConnectWithoutSettlementInput[]
    upsert?: SettlementParticipantUpsertWithWhereUniqueWithoutSettlementInput | SettlementParticipantUpsertWithWhereUniqueWithoutSettlementInput[]
    createMany?: SettlementParticipantCreateManySettlementInputEnvelope
    set?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    disconnect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    delete?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    update?: SettlementParticipantUpdateWithWhereUniqueWithoutSettlementInput | SettlementParticipantUpdateWithWhereUniqueWithoutSettlementInput[]
    updateMany?: SettlementParticipantUpdateManyWithWhereWithoutSettlementInput | SettlementParticipantUpdateManyWithWhereWithoutSettlementInput[]
    deleteMany?: SettlementParticipantScalarWhereInput | SettlementParticipantScalarWhereInput[]
  }

  export type SettlementParticipantUncheckedUpdateManyWithoutSettlementNestedInput = {
    create?: XOR<SettlementParticipantCreateWithoutSettlementInput, SettlementParticipantUncheckedCreateWithoutSettlementInput> | SettlementParticipantCreateWithoutSettlementInput[] | SettlementParticipantUncheckedCreateWithoutSettlementInput[]
    connectOrCreate?: SettlementParticipantCreateOrConnectWithoutSettlementInput | SettlementParticipantCreateOrConnectWithoutSettlementInput[]
    upsert?: SettlementParticipantUpsertWithWhereUniqueWithoutSettlementInput | SettlementParticipantUpsertWithWhereUniqueWithoutSettlementInput[]
    createMany?: SettlementParticipantCreateManySettlementInputEnvelope
    set?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    disconnect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    delete?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    connect?: SettlementParticipantWhereUniqueInput | SettlementParticipantWhereUniqueInput[]
    update?: SettlementParticipantUpdateWithWhereUniqueWithoutSettlementInput | SettlementParticipantUpdateWithWhereUniqueWithoutSettlementInput[]
    updateMany?: SettlementParticipantUpdateManyWithWhereWithoutSettlementInput | SettlementParticipantUpdateManyWithWhereWithoutSettlementInput[]
    deleteMany?: SettlementParticipantScalarWhereInput | SettlementParticipantScalarWhereInput[]
  }

  export type SettlementCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<SettlementCreateWithoutParticipantsInput, SettlementUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: SettlementCreateOrConnectWithoutParticipantsInput
    connect?: SettlementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSettlementParticipantsInput = {
    create?: XOR<UserCreateWithoutSettlementParticipantsInput, UserUncheckedCreateWithoutSettlementParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type SettlementUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<SettlementCreateWithoutParticipantsInput, SettlementUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: SettlementCreateOrConnectWithoutParticipantsInput
    upsert?: SettlementUpsertWithoutParticipantsInput
    connect?: SettlementWhereUniqueInput
    update?: XOR<XOR<SettlementUpdateToOneWithWhereWithoutParticipantsInput, SettlementUpdateWithoutParticipantsInput>, SettlementUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutSettlementParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutSettlementParticipantsInput, UserUncheckedCreateWithoutSettlementParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementParticipantsInput
    upsert?: UserUpsertWithoutSettlementParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettlementParticipantsInput, UserUpdateWithoutSettlementParticipantsInput>, UserUncheckedUpdateWithoutSettlementParticipantsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutFiscalObligationsInput = {
    create?: XOR<UserCreateWithoutFiscalObligationsInput, UserUncheckedCreateWithoutFiscalObligationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFiscalObligationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFiscalObligationsNestedInput = {
    create?: XOR<UserCreateWithoutFiscalObligationsInput, UserUncheckedCreateWithoutFiscalObligationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFiscalObligationsInput
    upsert?: UserUpsertWithoutFiscalObligationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFiscalObligationsInput, UserUpdateWithoutFiscalObligationsInput>, UserUncheckedUpdateWithoutFiscalObligationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCreditCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditCategory | EnumCreditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CreditCategory[]
    notIn?: $Enums.CreditCategory[]
    not?: NestedEnumCreditCategoryFilter<$PrismaModel> | $Enums.CreditCategory
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusFilter<$PrismaModel> | $Enums.CreditStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCreditCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditCategory | EnumCreditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CreditCategory[]
    notIn?: $Enums.CreditCategory[]
    not?: NestedEnumCreditCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CreditCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditCategoryFilter<$PrismaModel>
    _max?: NestedEnumCreditCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTCTributarioFederalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioFederal | EnumTCTributarioFederalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioFederal[] | null
    notIn?: $Enums.TCTributarioFederal[] | null
    not?: NestedEnumTCTributarioFederalNullableFilter<$PrismaModel> | $Enums.TCTributarioFederal | null
  }

  export type NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioEstadual | EnumTCTributarioEstadualFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioEstadual[] | null
    notIn?: $Enums.TCTributarioEstadual[] | null
    not?: NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel> | $Enums.TCTributarioEstadual | null
  }

  export type NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioMunicipal | EnumTCTributarioMunicipalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioMunicipal[] | null
    notIn?: $Enums.TCTributarioMunicipal[] | null
    not?: NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel> | $Enums.TCTributarioMunicipal | null
  }

  export type NestedEnumTCTributarioFederalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioFederal | EnumTCTributarioFederalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioFederal[] | null
    notIn?: $Enums.TCTributarioFederal[] | null
    not?: NestedEnumTCTributarioFederalNullableWithAggregatesFilter<$PrismaModel> | $Enums.TCTributarioFederal | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTCTributarioFederalNullableFilter<$PrismaModel>
    _max?: NestedEnumTCTributarioFederalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTCTributarioEstadualNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioEstadual | EnumTCTributarioEstadualFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioEstadual[] | null
    notIn?: $Enums.TCTributarioEstadual[] | null
    not?: NestedEnumTCTributarioEstadualNullableWithAggregatesFilter<$PrismaModel> | $Enums.TCTributarioEstadual | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel>
    _max?: NestedEnumTCTributarioEstadualNullableFilter<$PrismaModel>
  }

  export type NestedEnumTCTributarioMunicipalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCTributarioMunicipal | EnumTCTributarioMunicipalFieldRefInput<$PrismaModel> | null
    in?: $Enums.TCTributarioMunicipal[] | null
    notIn?: $Enums.TCTributarioMunicipal[] | null
    not?: NestedEnumTCTributarioMunicipalNullableWithAggregatesFilter<$PrismaModel> | $Enums.TCTributarioMunicipal | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel>
    _max?: NestedEnumTCTributarioMunicipalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTCComercialFilter<$PrismaModel = never> = {
    equals?: $Enums.TCComercial | EnumTCComercialFieldRefInput<$PrismaModel>
    in?: $Enums.TCComercial[]
    notIn?: $Enums.TCComercial[]
    not?: NestedEnumTCComercialFilter<$PrismaModel> | $Enums.TCComercial
  }

  export type NestedEnumTCComercialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCComercial | EnumTCComercialFieldRefInput<$PrismaModel>
    in?: $Enums.TCComercial[]
    notIn?: $Enums.TCComercial[]
    not?: NestedEnumTCComercialWithAggregatesFilter<$PrismaModel> | $Enums.TCComercial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCComercialFilter<$PrismaModel>
    _max?: NestedEnumTCComercialFilter<$PrismaModel>
  }

  export type NestedEnumTCFinanceiroFilter<$PrismaModel = never> = {
    equals?: $Enums.TCFinanceiro | EnumTCFinanceiroFieldRefInput<$PrismaModel>
    in?: $Enums.TCFinanceiro[]
    notIn?: $Enums.TCFinanceiro[]
    not?: NestedEnumTCFinanceiroFilter<$PrismaModel> | $Enums.TCFinanceiro
  }

  export type NestedEnumTCFinanceiroWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCFinanceiro | EnumTCFinanceiroFieldRefInput<$PrismaModel>
    in?: $Enums.TCFinanceiro[]
    notIn?: $Enums.TCFinanceiro[]
    not?: NestedEnumTCFinanceiroWithAggregatesFilter<$PrismaModel> | $Enums.TCFinanceiro
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCFinanceiroFilter<$PrismaModel>
    _max?: NestedEnumTCFinanceiroFilter<$PrismaModel>
  }

  export type NestedEnumTCJudicialFilter<$PrismaModel = never> = {
    equals?: $Enums.TCJudicial | EnumTCJudicialFieldRefInput<$PrismaModel>
    in?: $Enums.TCJudicial[]
    notIn?: $Enums.TCJudicial[]
    not?: NestedEnumTCJudicialFilter<$PrismaModel> | $Enums.TCJudicial
  }

  export type NestedEnumTCJudicialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCJudicial | EnumTCJudicialFieldRefInput<$PrismaModel>
    in?: $Enums.TCJudicial[]
    notIn?: $Enums.TCJudicial[]
    not?: NestedEnumTCJudicialWithAggregatesFilter<$PrismaModel> | $Enums.TCJudicial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCJudicialFilter<$PrismaModel>
    _max?: NestedEnumTCJudicialFilter<$PrismaModel>
  }

  export type NestedEnumTCRuralFilter<$PrismaModel = never> = {
    equals?: $Enums.TCRural | EnumTCRuralFieldRefInput<$PrismaModel>
    in?: $Enums.TCRural[]
    notIn?: $Enums.TCRural[]
    not?: NestedEnumTCRuralFilter<$PrismaModel> | $Enums.TCRural
  }

  export type NestedEnumTCRuralWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCRural | EnumTCRuralFieldRefInput<$PrismaModel>
    in?: $Enums.TCRural[]
    notIn?: $Enums.TCRural[]
    not?: NestedEnumTCRuralWithAggregatesFilter<$PrismaModel> | $Enums.TCRural
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCRuralFilter<$PrismaModel>
    _max?: NestedEnumTCRuralFilter<$PrismaModel>
  }

  export type NestedEnumTCImobiliarioFilter<$PrismaModel = never> = {
    equals?: $Enums.TCImobiliario | EnumTCImobiliarioFieldRefInput<$PrismaModel>
    in?: $Enums.TCImobiliario[]
    notIn?: $Enums.TCImobiliario[]
    not?: NestedEnumTCImobiliarioFilter<$PrismaModel> | $Enums.TCImobiliario
  }

  export type NestedEnumTCImobiliarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCImobiliario | EnumTCImobiliarioFieldRefInput<$PrismaModel>
    in?: $Enums.TCImobiliario[]
    notIn?: $Enums.TCImobiliario[]
    not?: NestedEnumTCImobiliarioWithAggregatesFilter<$PrismaModel> | $Enums.TCImobiliario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCImobiliarioFilter<$PrismaModel>
    _max?: NestedEnumTCImobiliarioFilter<$PrismaModel>
  }

  export type NestedEnumTCAmbientalFilter<$PrismaModel = never> = {
    equals?: $Enums.TCAmbiental | EnumTCAmbientalFieldRefInput<$PrismaModel>
    in?: $Enums.TCAmbiental[]
    notIn?: $Enums.TCAmbiental[]
    not?: NestedEnumTCAmbientalFilter<$PrismaModel> | $Enums.TCAmbiental
  }

  export type NestedEnumTCAmbientalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCAmbiental | EnumTCAmbientalFieldRefInput<$PrismaModel>
    in?: $Enums.TCAmbiental[]
    notIn?: $Enums.TCAmbiental[]
    not?: NestedEnumTCAmbientalWithAggregatesFilter<$PrismaModel> | $Enums.TCAmbiental
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCAmbientalFilter<$PrismaModel>
    _max?: NestedEnumTCAmbientalFilter<$PrismaModel>
  }

  export type NestedEnumTCEspecialFilter<$PrismaModel = never> = {
    equals?: $Enums.TCEspecial | EnumTCEspecialFieldRefInput<$PrismaModel>
    in?: $Enums.TCEspecial[]
    notIn?: $Enums.TCEspecial[]
    not?: NestedEnumTCEspecialFilter<$PrismaModel> | $Enums.TCEspecial
  }

  export type NestedEnumTCEspecialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TCEspecial | EnumTCEspecialFieldRefInput<$PrismaModel>
    in?: $Enums.TCEspecial[]
    notIn?: $Enums.TCEspecial[]
    not?: NestedEnumTCEspecialWithAggregatesFilter<$PrismaModel> | $Enums.TCEspecial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTCEspecialFilter<$PrismaModel>
    _max?: NestedEnumTCEspecialFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumOfferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[]
    notIn?: $Enums.OfferType[]
    not?: NestedEnumOfferTypeFilter<$PrismaModel> | $Enums.OfferType
  }

  export type NestedEnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[]
    notIn?: $Enums.OfferStatus[]
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type NestedEnumOfferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[]
    notIn?: $Enums.OfferType[]
    not?: NestedEnumOfferTypeWithAggregatesFilter<$PrismaModel> | $Enums.OfferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferTypeFilter<$PrismaModel>
    _max?: NestedEnumOfferTypeFilter<$PrismaModel>
  }

  export type NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[]
    notIn?: $Enums.OfferStatus[]
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type NestedEnumBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[]
    notIn?: $Enums.BidStatus[]
    not?: NestedEnumBidStatusFilter<$PrismaModel> | $Enums.BidStatus
  }

  export type NestedEnumBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[]
    notIn?: $Enums.BidStatus[]
    not?: NestedEnumBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.BidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidStatusFilter<$PrismaModel>
    _max?: NestedEnumBidStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type CreditTitleCreateWithoutIssuerInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutIssuerInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutIssuerInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutIssuerInput, CreditTitleUncheckedCreateWithoutIssuerInput>
  }

  export type CreditTitleCreateManyIssuerInputEnvelope = {
    data: CreditTitleCreateManyIssuerInput | CreditTitleCreateManyIssuerInput[]
  }

  export type CreditTitleCreateWithoutOwnerInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutOwnerInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutOwnerInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutOwnerInput, CreditTitleUncheckedCreateWithoutOwnerInput>
  }

  export type CreditTitleCreateManyOwnerInputEnvelope = {
    data: CreditTitleCreateManyOwnerInput | CreditTitleCreateManyOwnerInput[]
  }

  export type DocumentCreateWithoutUploadedByInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    uploadedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    creditTitleId: string
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentCreateManyUploadedByInputEnvelope = {
    data: DocumentCreateManyUploadedByInput | DocumentCreateManyUploadedByInput[]
  }

  export type OfferCreateWithoutSellerInput = {
    id?: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutOffersInput
    bids?: BidCreateNestedManyWithoutOfferInput
    transactions?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutSellerInput = {
    id?: string
    creditTitleId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutOfferInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutSellerInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutSellerInput, OfferUncheckedCreateWithoutSellerInput>
  }

  export type OfferCreateManySellerInputEnvelope = {
    data: OfferCreateManySellerInput | OfferCreateManySellerInput[]
  }

  export type BidCreateWithoutBidderInput = {
    id?: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    offer: OfferCreateNestedOneWithoutBidsInput
    transactions?: TransactionCreateNestedManyWithoutBidInput
  }

  export type BidUncheckedCreateWithoutBidderInput = {
    id?: string
    offerId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutBidInput
  }

  export type BidCreateOrConnectWithoutBidderInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput>
  }

  export type BidCreateManyBidderInputEnvelope = {
    data: BidCreateManyBidderInput | BidCreateManyBidderInput[]
  }

  export type TransactionCreateWithoutSellerInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutTransactionsInput
    buyer: UserCreateNestedOneWithoutTransactionsAsBuyerInput
    offer?: OfferCreateNestedOneWithoutTransactionsInput
    bid?: BidCreateNestedOneWithoutTransactionsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutSellerInput = {
    id?: string
    creditTitleId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutSellerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSellerInput, TransactionUncheckedCreateWithoutSellerInput>
  }

  export type TransactionCreateManySellerInputEnvelope = {
    data: TransactionCreateManySellerInput | TransactionCreateManySellerInput[]
  }

  export type TransactionCreateWithoutBuyerInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutTransactionsInput
    seller: UserCreateNestedOneWithoutTransactionsAsSellerInput
    offer?: OfferCreateNestedOneWithoutTransactionsInput
    bid?: BidCreateNestedOneWithoutTransactionsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBuyerInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutBuyerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBuyerInput, TransactionUncheckedCreateWithoutBuyerInput>
  }

  export type TransactionCreateManyBuyerInputEnvelope = {
    data: TransactionCreateManyBuyerInput | TransactionCreateManyBuyerInput[]
  }

  export type TransactionCreateWithoutCreatedByInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutTransactionsInput
    seller: UserCreateNestedOneWithoutTransactionsAsSellerInput
    buyer: UserCreateNestedOneWithoutTransactionsAsBuyerInput
    offer?: OfferCreateNestedOneWithoutTransactionsInput
    bid?: BidCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCreatedByInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreatedByInput, TransactionUncheckedCreateWithoutCreatedByInput>
  }

  export type TransactionCreateManyCreatedByInputEnvelope = {
    data: TransactionCreateManyCreatedByInput | TransactionCreateManyCreatedByInput[]
  }

  export type AuctionCreateWithoutSellerInput = {
    id?: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credit: CreditTitleCreateNestedOneWithoutAuctionsInput
    winner?: UserCreateNestedOneWithoutAuctionsAsWinnerInput
  }

  export type AuctionUncheckedCreateWithoutSellerInput = {
    id?: string
    creditId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    winnerId?: string | null
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateOrConnectWithoutSellerInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutSellerInput, AuctionUncheckedCreateWithoutSellerInput>
  }

  export type AuctionCreateManySellerInputEnvelope = {
    data: AuctionCreateManySellerInput | AuctionCreateManySellerInput[]
  }

  export type AuctionCreateWithoutWinnerInput = {
    id?: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credit: CreditTitleCreateNestedOneWithoutAuctionsInput
    seller: UserCreateNestedOneWithoutAuctionsAsSellerInput
  }

  export type AuctionUncheckedCreateWithoutWinnerInput = {
    id?: string
    creditId: string
    sellerId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateOrConnectWithoutWinnerInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutWinnerInput, AuctionUncheckedCreateWithoutWinnerInput>
  }

  export type AuctionCreateManyWinnerInputEnvelope = {
    data: AuctionCreateManyWinnerInput | AuctionCreateManyWinnerInput[]
  }

  export type SettlementParticipantCreateWithoutUserInput = {
    id?: string
    role: string
    value: number
    status: string
    settlement: SettlementCreateNestedOneWithoutParticipantsInput
  }

  export type SettlementParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    settlementId: string
    role: string
    value: number
    status: string
  }

  export type SettlementParticipantCreateOrConnectWithoutUserInput = {
    where: SettlementParticipantWhereUniqueInput
    create: XOR<SettlementParticipantCreateWithoutUserInput, SettlementParticipantUncheckedCreateWithoutUserInput>
  }

  export type SettlementParticipantCreateManyUserInputEnvelope = {
    data: SettlementParticipantCreateManyUserInput | SettlementParticipantCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type FiscalObligationCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date | string
    taxCode?: string | null
    taxName?: string | null
    taxType?: string | null
    taxPeriod?: string | null
    taxBase?: number | null
    taxRate?: number | null
    taxValue?: number | null
    taxInterest?: number | null
    taxFine?: number | null
    taxTotal?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalObligationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date | string
    taxCode?: string | null
    taxName?: string | null
    taxType?: string | null
    taxPeriod?: string | null
    taxBase?: number | null
    taxRate?: number | null
    taxValue?: number | null
    taxInterest?: number | null
    taxFine?: number | null
    taxTotal?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalObligationCreateOrConnectWithoutUserInput = {
    where: FiscalObligationWhereUniqueInput
    create: XOR<FiscalObligationCreateWithoutUserInput, FiscalObligationUncheckedCreateWithoutUserInput>
  }

  export type FiscalObligationCreateManyUserInputEnvelope = {
    data: FiscalObligationCreateManyUserInput | FiscalObligationCreateManyUserInput[]
  }

  export type EmpresaCreateWithoutRepresentantePrincipalInput = {
    id?: string
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj: string
    inscEstadual?: string | null
    inscMunicipal?: string | null
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    website?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUncheckedCreateWithoutRepresentantePrincipalInput = {
    id?: string
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj: string
    inscEstadual?: string | null
    inscMunicipal?: string | null
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    website?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaCreateOrConnectWithoutRepresentantePrincipalInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutRepresentantePrincipalInput, EmpresaUncheckedCreateWithoutRepresentantePrincipalInput>
  }

  export type EmpresaCreateManyRepresentantePrincipalInputEnvelope = {
    data: EmpresaCreateManyRepresentantePrincipalInput | EmpresaCreateManyRepresentantePrincipalInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type CreditTitleUpsertWithWhereUniqueWithoutIssuerInput = {
    where: CreditTitleWhereUniqueInput
    update: XOR<CreditTitleUpdateWithoutIssuerInput, CreditTitleUncheckedUpdateWithoutIssuerInput>
    create: XOR<CreditTitleCreateWithoutIssuerInput, CreditTitleUncheckedCreateWithoutIssuerInput>
  }

  export type CreditTitleUpdateWithWhereUniqueWithoutIssuerInput = {
    where: CreditTitleWhereUniqueInput
    data: XOR<CreditTitleUpdateWithoutIssuerInput, CreditTitleUncheckedUpdateWithoutIssuerInput>
  }

  export type CreditTitleUpdateManyWithWhereWithoutIssuerInput = {
    where: CreditTitleScalarWhereInput
    data: XOR<CreditTitleUpdateManyMutationInput, CreditTitleUncheckedUpdateManyWithoutIssuerInput>
  }

  export type CreditTitleScalarWhereInput = {
    AND?: CreditTitleScalarWhereInput | CreditTitleScalarWhereInput[]
    OR?: CreditTitleScalarWhereInput[]
    NOT?: CreditTitleScalarWhereInput | CreditTitleScalarWhereInput[]
    id?: StringFilter<"CreditTitle"> | string
    category?: EnumCreditCategoryFilter<"CreditTitle"> | $Enums.CreditCategory
    valueNominal?: FloatFilter<"CreditTitle"> | number
    valueCurrent?: FloatFilter<"CreditTitle"> | number
    issueDate?: DateTimeFilter<"CreditTitle"> | Date | string
    expiryDate?: DateTimeNullableFilter<"CreditTitle"> | Date | string | null
    issuerId?: StringFilter<"CreditTitle"> | string
    ownerId?: StringFilter<"CreditTitle"> | string
    status?: EnumCreditStatusFilter<"CreditTitle"> | $Enums.CreditStatus
    tokenId?: StringNullableFilter<"CreditTitle"> | string | null
    tokenStandard?: StringNullableFilter<"CreditTitle"> | string | null
    blockchainTxHash?: StringNullableFilter<"CreditTitle"> | string | null
    isListed?: BoolFilter<"CreditTitle"> | boolean
    listingPrice?: FloatNullableFilter<"CreditTitle"> | number | null
    listingDate?: DateTimeNullableFilter<"CreditTitle"> | Date | string | null
    createdAt?: DateTimeFilter<"CreditTitle"> | Date | string
    updatedAt?: DateTimeFilter<"CreditTitle"> | Date | string
  }

  export type CreditTitleUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CreditTitleWhereUniqueInput
    update: XOR<CreditTitleUpdateWithoutOwnerInput, CreditTitleUncheckedUpdateWithoutOwnerInput>
    create: XOR<CreditTitleCreateWithoutOwnerInput, CreditTitleUncheckedCreateWithoutOwnerInput>
  }

  export type CreditTitleUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CreditTitleWhereUniqueInput
    data: XOR<CreditTitleUpdateWithoutOwnerInput, CreditTitleUncheckedUpdateWithoutOwnerInput>
  }

  export type CreditTitleUpdateManyWithWhereWithoutOwnerInput = {
    where: CreditTitleScalarWhereInput
    data: XOR<CreditTitleUpdateManyMutationInput, CreditTitleUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    isPublic?: BoolFilter<"Document"> | boolean
    mimeType?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    storageLocation?: StringFilter<"Document"> | string
    hash?: StringNullableFilter<"Document"> | string | null
    creditTitleId?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type OfferUpsertWithWhereUniqueWithoutSellerInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutSellerInput, OfferUncheckedUpdateWithoutSellerInput>
    create: XOR<OfferCreateWithoutSellerInput, OfferUncheckedCreateWithoutSellerInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutSellerInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutSellerInput, OfferUncheckedUpdateWithoutSellerInput>
  }

  export type OfferUpdateManyWithWhereWithoutSellerInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutSellerInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: StringFilter<"Offer"> | string
    creditTitleId?: StringFilter<"Offer"> | string
    sellerId?: StringFilter<"Offer"> | string
    price?: FloatFilter<"Offer"> | number
    expiryDate?: DateTimeNullableFilter<"Offer"> | Date | string | null
    terms?: StringNullableFilter<"Offer"> | string | null
    quantityAvailable?: IntFilter<"Offer"> | number
    offerType?: EnumOfferTypeFilter<"Offer"> | $Enums.OfferType
    minBidIncrement?: FloatNullableFilter<"Offer"> | number | null
    reservePrice?: FloatNullableFilter<"Offer"> | number | null
    allowPartialPurchase?: BoolFilter<"Offer"> | boolean
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
  }

  export type BidUpsertWithWhereUniqueWithoutBidderInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutBidderInput, BidUncheckedUpdateWithoutBidderInput>
    create: XOR<BidCreateWithoutBidderInput, BidUncheckedCreateWithoutBidderInput>
  }

  export type BidUpdateWithWhereUniqueWithoutBidderInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutBidderInput, BidUncheckedUpdateWithoutBidderInput>
  }

  export type BidUpdateManyWithWhereWithoutBidderInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutBidderInput>
  }

  export type BidScalarWhereInput = {
    AND?: BidScalarWhereInput | BidScalarWhereInput[]
    OR?: BidScalarWhereInput[]
    NOT?: BidScalarWhereInput | BidScalarWhereInput[]
    id?: StringFilter<"Bid"> | string
    offerId?: StringFilter<"Bid"> | string
    bidderId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    quantity?: IntFilter<"Bid"> | number
    notes?: StringNullableFilter<"Bid"> | string | null
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutSellerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSellerInput, TransactionUncheckedUpdateWithoutSellerInput>
    create: XOR<TransactionCreateWithoutSellerInput, TransactionUncheckedCreateWithoutSellerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSellerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSellerInput, TransactionUncheckedUpdateWithoutSellerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSellerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSellerInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    creditTitleId?: StringFilter<"Transaction"> | string
    sellerId?: StringFilter<"Transaction"> | string
    buyerId?: StringFilter<"Transaction"> | string
    price?: FloatFilter<"Transaction"> | number
    quantity?: IntFilter<"Transaction"> | number
    offerId?: StringNullableFilter<"Transaction"> | string | null
    bidId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    notes?: StringNullableFilter<"Transaction"> | string | null
    blockchainData?: StringNullableFilter<"Transaction"> | string | null
    createdById?: StringNullableFilter<"Transaction"> | string | null
    updatedById?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutBuyerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBuyerInput, TransactionUncheckedUpdateWithoutBuyerInput>
    create: XOR<TransactionCreateWithoutBuyerInput, TransactionUncheckedCreateWithoutBuyerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBuyerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBuyerInput, TransactionUncheckedUpdateWithoutBuyerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBuyerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBuyerInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreatedByInput, TransactionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TransactionCreateWithoutCreatedByInput, TransactionUncheckedCreateWithoutCreatedByInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreatedByInput, TransactionUncheckedUpdateWithoutCreatedByInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreatedByInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuctionUpsertWithWhereUniqueWithoutSellerInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutSellerInput, AuctionUncheckedUpdateWithoutSellerInput>
    create: XOR<AuctionCreateWithoutSellerInput, AuctionUncheckedCreateWithoutSellerInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutSellerInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutSellerInput, AuctionUncheckedUpdateWithoutSellerInput>
  }

  export type AuctionUpdateManyWithWhereWithoutSellerInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutSellerInput>
  }

  export type AuctionScalarWhereInput = {
    AND?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
    OR?: AuctionScalarWhereInput[]
    NOT?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
    id?: StringFilter<"Auction"> | string
    creditId?: StringFilter<"Auction"> | string
    sellerId?: StringFilter<"Auction"> | string
    type?: StringFilter<"Auction"> | string
    startPrice?: FloatFilter<"Auction"> | number
    minPrice?: FloatNullableFilter<"Auction"> | number | null
    startDate?: DateTimeFilter<"Auction"> | Date | string
    endDate?: DateTimeFilter<"Auction"> | Date | string
    status?: StringFilter<"Auction"> | string
    winnerId?: StringNullableFilter<"Auction"> | string | null
    finalPrice?: FloatNullableFilter<"Auction"> | number | null
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
  }

  export type AuctionUpsertWithWhereUniqueWithoutWinnerInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutWinnerInput, AuctionUncheckedUpdateWithoutWinnerInput>
    create: XOR<AuctionCreateWithoutWinnerInput, AuctionUncheckedCreateWithoutWinnerInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutWinnerInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutWinnerInput, AuctionUncheckedUpdateWithoutWinnerInput>
  }

  export type AuctionUpdateManyWithWhereWithoutWinnerInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutWinnerInput>
  }

  export type SettlementParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: SettlementParticipantWhereUniqueInput
    update: XOR<SettlementParticipantUpdateWithoutUserInput, SettlementParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<SettlementParticipantCreateWithoutUserInput, SettlementParticipantUncheckedCreateWithoutUserInput>
  }

  export type SettlementParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: SettlementParticipantWhereUniqueInput
    data: XOR<SettlementParticipantUpdateWithoutUserInput, SettlementParticipantUncheckedUpdateWithoutUserInput>
  }

  export type SettlementParticipantUpdateManyWithWhereWithoutUserInput = {
    where: SettlementParticipantScalarWhereInput
    data: XOR<SettlementParticipantUpdateManyMutationInput, SettlementParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type SettlementParticipantScalarWhereInput = {
    AND?: SettlementParticipantScalarWhereInput | SettlementParticipantScalarWhereInput[]
    OR?: SettlementParticipantScalarWhereInput[]
    NOT?: SettlementParticipantScalarWhereInput | SettlementParticipantScalarWhereInput[]
    id?: StringFilter<"SettlementParticipant"> | string
    settlementId?: StringFilter<"SettlementParticipant"> | string
    userId?: StringFilter<"SettlementParticipant"> | string
    role?: StringFilter<"SettlementParticipant"> | string
    value?: FloatFilter<"SettlementParticipant"> | number
    status?: StringFilter<"SettlementParticipant"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type FiscalObligationUpsertWithWhereUniqueWithoutUserInput = {
    where: FiscalObligationWhereUniqueInput
    update: XOR<FiscalObligationUpdateWithoutUserInput, FiscalObligationUncheckedUpdateWithoutUserInput>
    create: XOR<FiscalObligationCreateWithoutUserInput, FiscalObligationUncheckedCreateWithoutUserInput>
  }

  export type FiscalObligationUpdateWithWhereUniqueWithoutUserInput = {
    where: FiscalObligationWhereUniqueInput
    data: XOR<FiscalObligationUpdateWithoutUserInput, FiscalObligationUncheckedUpdateWithoutUserInput>
  }

  export type FiscalObligationUpdateManyWithWhereWithoutUserInput = {
    where: FiscalObligationScalarWhereInput
    data: XOR<FiscalObligationUpdateManyMutationInput, FiscalObligationUncheckedUpdateManyWithoutUserInput>
  }

  export type FiscalObligationScalarWhereInput = {
    AND?: FiscalObligationScalarWhereInput | FiscalObligationScalarWhereInput[]
    OR?: FiscalObligationScalarWhereInput[]
    NOT?: FiscalObligationScalarWhereInput | FiscalObligationScalarWhereInput[]
    id?: StringFilter<"FiscalObligation"> | string
    userId?: StringFilter<"FiscalObligation"> | string
    title?: StringFilter<"FiscalObligation"> | string
    description?: StringNullableFilter<"FiscalObligation"> | string | null
    type?: StringFilter<"FiscalObligation"> | string
    status?: StringFilter<"FiscalObligation"> | string
    amount?: FloatFilter<"FiscalObligation"> | number
    currency?: StringFilter<"FiscalObligation"> | string
    dueDate?: DateTimeFilter<"FiscalObligation"> | Date | string
    taxCode?: StringNullableFilter<"FiscalObligation"> | string | null
    taxName?: StringNullableFilter<"FiscalObligation"> | string | null
    taxType?: StringNullableFilter<"FiscalObligation"> | string | null
    taxPeriod?: StringNullableFilter<"FiscalObligation"> | string | null
    taxBase?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxRate?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxValue?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxInterest?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxFine?: FloatNullableFilter<"FiscalObligation"> | number | null
    taxTotal?: FloatNullableFilter<"FiscalObligation"> | number | null
    createdAt?: DateTimeFilter<"FiscalObligation"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalObligation"> | Date | string
  }

  export type EmpresaUpsertWithWhereUniqueWithoutRepresentantePrincipalInput = {
    where: EmpresaWhereUniqueInput
    update: XOR<EmpresaUpdateWithoutRepresentantePrincipalInput, EmpresaUncheckedUpdateWithoutRepresentantePrincipalInput>
    create: XOR<EmpresaCreateWithoutRepresentantePrincipalInput, EmpresaUncheckedCreateWithoutRepresentantePrincipalInput>
  }

  export type EmpresaUpdateWithWhereUniqueWithoutRepresentantePrincipalInput = {
    where: EmpresaWhereUniqueInput
    data: XOR<EmpresaUpdateWithoutRepresentantePrincipalInput, EmpresaUncheckedUpdateWithoutRepresentantePrincipalInput>
  }

  export type EmpresaUpdateManyWithWhereWithoutRepresentantePrincipalInput = {
    where: EmpresaScalarWhereInput
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalInput>
  }

  export type EmpresaScalarWhereInput = {
    AND?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    OR?: EmpresaScalarWhereInput[]
    NOT?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    id?: StringFilter<"Empresa"> | string
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    cnpj?: StringFilter<"Empresa"> | string
    inscEstadual?: StringNullableFilter<"Empresa"> | string | null
    inscMunicipal?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    website?: StringNullableFilter<"Empresa"> | string | null
    status?: StringFilter<"Empresa"> | string
    representantePrincipalId?: StringFilter<"Empresa"> | string
    createdAt?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
  }

  export type UserCreateWithoutEmpresasRepresentadasInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmpresasRepresentadasInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmpresasRepresentadasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmpresasRepresentadasInput, UserUncheckedCreateWithoutEmpresasRepresentadasInput>
  }

  export type UserUpsertWithoutEmpresasRepresentadasInput = {
    update: XOR<UserUpdateWithoutEmpresasRepresentadasInput, UserUncheckedUpdateWithoutEmpresasRepresentadasInput>
    create: XOR<UserCreateWithoutEmpresasRepresentadasInput, UserUncheckedCreateWithoutEmpresasRepresentadasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmpresasRepresentadasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmpresasRepresentadasInput, UserUncheckedUpdateWithoutEmpresasRepresentadasInput>
  }

  export type UserUpdateWithoutEmpresasRepresentadasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmpresasRepresentadasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserCreateWithoutIssuedCreditsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutIssuedCreditsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutIssuedCreditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIssuedCreditsInput, UserUncheckedCreateWithoutIssuedCreditsInput>
  }

  export type UserCreateWithoutOwnedCreditsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutOwnedCreditsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutOwnedCreditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedCreditsInput, UserUncheckedCreateWithoutOwnedCreditsInput>
  }

  export type CreditTitleTributarioCreateWithoutCreditTitleInput = {
    id?: string
    subTypeFederal?: $Enums.TCTributarioFederal | null
    subTypeEstadual?: $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: $Enums.TCTributarioMunicipal | null
    esfera: string
    nomeTributo: string
    periodoApuracaoInicio: Date | string
    periodoApuracaoFim: Date | string
    numeroProcessoAdministrativo?: string | null
    numeroProcessoJudicial?: string | null
  }

  export type CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subTypeFederal?: $Enums.TCTributarioFederal | null
    subTypeEstadual?: $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: $Enums.TCTributarioMunicipal | null
    esfera: string
    nomeTributo: string
    periodoApuracaoInicio: Date | string
    periodoApuracaoFim: Date | string
    numeroProcessoAdministrativo?: string | null
    numeroProcessoJudicial?: string | null
  }

  export type CreditTitleTributarioCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleTributarioWhereUniqueInput
    create: XOR<CreditTitleTributarioCreateWithoutCreditTitleInput, CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleComercialCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCComercial
    sacadoNome: string
    sacadoDocumento: string
  }

  export type CreditTitleComercialUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCComercial
    sacadoNome: string
    sacadoDocumento: string
  }

  export type CreditTitleComercialCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleComercialWhereUniqueInput
    create: XOR<CreditTitleComercialCreateWithoutCreditTitleInput, CreditTitleComercialUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleFinanceiroCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCFinanceiro
    indexador?: string | null
    taxaJurosAnual?: number | null
    rating?: string | null
  }

  export type CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCFinanceiro
    indexador?: string | null
    taxaJurosAnual?: number | null
    rating?: string | null
  }

  export type CreditTitleFinanceiroCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleFinanceiroWhereUniqueInput
    create: XOR<CreditTitleFinanceiroCreateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleJudicialCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCJudicial
    numeroProcesso: string
    tribunalOrigem: string
    varaOrigem?: string | null
    natureza: string
    enteDevedor?: string | null
  }

  export type CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCJudicial
    numeroProcesso: string
    tribunalOrigem: string
    varaOrigem?: string | null
    natureza: string
    enteDevedor?: string | null
  }

  export type CreditTitleJudicialCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleJudicialWhereUniqueInput
    create: XOR<CreditTitleJudicialCreateWithoutCreditTitleInput, CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleRuralCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCRural
    safra?: string | null
    produtoAgricola?: string | null
    areaFinanciadaHectares?: number | null
    registroImovelRural?: string | null
  }

  export type CreditTitleRuralUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCRural
    safra?: string | null
    produtoAgricola?: string | null
    areaFinanciadaHectares?: number | null
    registroImovelRural?: string | null
  }

  export type CreditTitleRuralCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleRuralWhereUniqueInput
    create: XOR<CreditTitleRuralCreateWithoutCreditTitleInput, CreditTitleRuralUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleImobiliarioCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCImobiliario
    matriculaImovel: string
    enderecoLogradouro: string
    enderecoNumero: string
    enderecoComplemento?: string | null
    enderecoBairro: string
    enderecoCidade: string
    enderecoEstado: string
    enderecoCep: string
    tipoGarantia?: string | null
  }

  export type CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCImobiliario
    matriculaImovel: string
    enderecoLogradouro: string
    enderecoNumero: string
    enderecoComplemento?: string | null
    enderecoBairro: string
    enderecoCidade: string
    enderecoEstado: string
    enderecoCep: string
    tipoGarantia?: string | null
  }

  export type CreditTitleImobiliarioCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleImobiliarioWhereUniqueInput
    create: XOR<CreditTitleImobiliarioCreateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleAmbientalCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCAmbiental
    projetoVinculado?: string | null
    metodologiaCertificacao?: string | null
    toneladasCO2Equivalente?: number | null
    hectaresConservados?: number | null
    volumeAguaEconomizadoM3?: number | null
  }

  export type CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCAmbiental
    projetoVinculado?: string | null
    metodologiaCertificacao?: string | null
    toneladasCO2Equivalente?: number | null
    hectaresConservados?: number | null
    volumeAguaEconomizadoM3?: number | null
  }

  export type CreditTitleAmbientalCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleAmbientalWhereUniqueInput
    create: XOR<CreditTitleAmbientalCreateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput>
  }

  export type CreditTitleEspecialCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCEspecial
    processoRecuperacaoJudicial?: string | null
    credorOriginal?: string | null
    classeCreditoRJ?: string | null
    administradoraConsorcio?: string | null
    grupoConsorcio?: string | null
    cotaConsorcio?: string | null
  }

  export type CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    subType: $Enums.TCEspecial
    processoRecuperacaoJudicial?: string | null
    credorOriginal?: string | null
    classeCreditoRJ?: string | null
    administradoraConsorcio?: string | null
    grupoConsorcio?: string | null
    cotaConsorcio?: string | null
  }

  export type CreditTitleEspecialCreateOrConnectWithoutCreditTitleInput = {
    where: CreditTitleEspecialWhereUniqueInput
    create: XOR<CreditTitleEspecialCreateWithoutCreditTitleInput, CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput>
  }

  export type DocumentCreateWithoutCreditTitleInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    uploadedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutCreditTitleInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCreditTitleInput, DocumentUncheckedCreateWithoutCreditTitleInput>
  }

  export type DocumentCreateManyCreditTitleInputEnvelope = {
    data: DocumentCreateManyCreditTitleInput | DocumentCreateManyCreditTitleInput[]
  }

  export type OfferCreateWithoutCreditTitleInput = {
    id?: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutOffersInput
    bids?: BidCreateNestedManyWithoutOfferInput
    transactions?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    sellerId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutOfferInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutCreditTitleInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutCreditTitleInput, OfferUncheckedCreateWithoutCreditTitleInput>
  }

  export type OfferCreateManyCreditTitleInputEnvelope = {
    data: OfferCreateManyCreditTitleInput | OfferCreateManyCreditTitleInput[]
  }

  export type TransactionCreateWithoutCreditTitleInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutTransactionsAsSellerInput
    buyer: UserCreateNestedOneWithoutTransactionsAsBuyerInput
    offer?: OfferCreateNestedOneWithoutTransactionsInput
    bid?: BidCreateNestedOneWithoutTransactionsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCreditTitleInput = {
    id?: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCreditTitleInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreditTitleInput, TransactionUncheckedCreateWithoutCreditTitleInput>
  }

  export type TransactionCreateManyCreditTitleInputEnvelope = {
    data: TransactionCreateManyCreditTitleInput | TransactionCreateManyCreditTitleInput[]
  }

  export type AuctionCreateWithoutCreditInput = {
    id?: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutAuctionsAsSellerInput
    winner?: UserCreateNestedOneWithoutAuctionsAsWinnerInput
  }

  export type AuctionUncheckedCreateWithoutCreditInput = {
    id?: string
    sellerId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    winnerId?: string | null
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateOrConnectWithoutCreditInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutCreditInput, AuctionUncheckedCreateWithoutCreditInput>
  }

  export type AuctionCreateManyCreditInputEnvelope = {
    data: AuctionCreateManyCreditInput | AuctionCreateManyCreditInput[]
  }

  export type UserUpsertWithoutIssuedCreditsInput = {
    update: XOR<UserUpdateWithoutIssuedCreditsInput, UserUncheckedUpdateWithoutIssuedCreditsInput>
    create: XOR<UserCreateWithoutIssuedCreditsInput, UserUncheckedCreateWithoutIssuedCreditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIssuedCreditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIssuedCreditsInput, UserUncheckedUpdateWithoutIssuedCreditsInput>
  }

  export type UserUpdateWithoutIssuedCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutIssuedCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUpsertWithoutOwnedCreditsInput = {
    update: XOR<UserUpdateWithoutOwnedCreditsInput, UserUncheckedUpdateWithoutOwnedCreditsInput>
    create: XOR<UserCreateWithoutOwnedCreditsInput, UserUncheckedCreateWithoutOwnedCreditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedCreditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedCreditsInput, UserUncheckedUpdateWithoutOwnedCreditsInput>
  }

  export type UserUpdateWithoutOwnedCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type CreditTitleTributarioUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleTributarioUpdateWithoutCreditTitleInput, CreditTitleTributarioUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleTributarioCreateWithoutCreditTitleInput, CreditTitleTributarioUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleTributarioWhereInput
  }

  export type CreditTitleTributarioUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleTributarioWhereInput
    data: XOR<CreditTitleTributarioUpdateWithoutCreditTitleInput, CreditTitleTributarioUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleTributarioUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTypeFederal?: NullableEnumTCTributarioFederalFieldUpdateOperationsInput | $Enums.TCTributarioFederal | null
    subTypeEstadual?: NullableEnumTCTributarioEstadualFieldUpdateOperationsInput | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput | $Enums.TCTributarioMunicipal | null
    esfera?: StringFieldUpdateOperationsInput | string
    nomeTributo?: StringFieldUpdateOperationsInput | string
    periodoApuracaoInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    periodoApuracaoFim?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroProcessoAdministrativo?: NullableStringFieldUpdateOperationsInput | string | null
    numeroProcessoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleTributarioUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTypeFederal?: NullableEnumTCTributarioFederalFieldUpdateOperationsInput | $Enums.TCTributarioFederal | null
    subTypeEstadual?: NullableEnumTCTributarioEstadualFieldUpdateOperationsInput | $Enums.TCTributarioEstadual | null
    subTypeMunicipal?: NullableEnumTCTributarioMunicipalFieldUpdateOperationsInput | $Enums.TCTributarioMunicipal | null
    esfera?: StringFieldUpdateOperationsInput | string
    nomeTributo?: StringFieldUpdateOperationsInput | string
    periodoApuracaoInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    periodoApuracaoFim?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroProcessoAdministrativo?: NullableStringFieldUpdateOperationsInput | string | null
    numeroProcessoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleComercialUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleComercialUpdateWithoutCreditTitleInput, CreditTitleComercialUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleComercialCreateWithoutCreditTitleInput, CreditTitleComercialUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleComercialWhereInput
  }

  export type CreditTitleComercialUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleComercialWhereInput
    data: XOR<CreditTitleComercialUpdateWithoutCreditTitleInput, CreditTitleComercialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleComercialUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCComercialFieldUpdateOperationsInput | $Enums.TCComercial
    sacadoNome?: StringFieldUpdateOperationsInput | string
    sacadoDocumento?: StringFieldUpdateOperationsInput | string
  }

  export type CreditTitleComercialUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCComercialFieldUpdateOperationsInput | $Enums.TCComercial
    sacadoNome?: StringFieldUpdateOperationsInput | string
    sacadoDocumento?: StringFieldUpdateOperationsInput | string
  }

  export type CreditTitleFinanceiroUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleFinanceiroUpdateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleFinanceiroCreateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleFinanceiroWhereInput
  }

  export type CreditTitleFinanceiroUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleFinanceiroWhereInput
    data: XOR<CreditTitleFinanceiroUpdateWithoutCreditTitleInput, CreditTitleFinanceiroUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleFinanceiroUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCFinanceiroFieldUpdateOperationsInput | $Enums.TCFinanceiro
    indexador?: NullableStringFieldUpdateOperationsInput | string | null
    taxaJurosAnual?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleFinanceiroUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCFinanceiroFieldUpdateOperationsInput | $Enums.TCFinanceiro
    indexador?: NullableStringFieldUpdateOperationsInput | string | null
    taxaJurosAnual?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleJudicialUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleJudicialUpdateWithoutCreditTitleInput, CreditTitleJudicialUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleJudicialCreateWithoutCreditTitleInput, CreditTitleJudicialUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleJudicialWhereInput
  }

  export type CreditTitleJudicialUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleJudicialWhereInput
    data: XOR<CreditTitleJudicialUpdateWithoutCreditTitleInput, CreditTitleJudicialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleJudicialUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCJudicialFieldUpdateOperationsInput | $Enums.TCJudicial
    numeroProcesso?: StringFieldUpdateOperationsInput | string
    tribunalOrigem?: StringFieldUpdateOperationsInput | string
    varaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    natureza?: StringFieldUpdateOperationsInput | string
    enteDevedor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleJudicialUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCJudicialFieldUpdateOperationsInput | $Enums.TCJudicial
    numeroProcesso?: StringFieldUpdateOperationsInput | string
    tribunalOrigem?: StringFieldUpdateOperationsInput | string
    varaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    natureza?: StringFieldUpdateOperationsInput | string
    enteDevedor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleRuralUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleRuralUpdateWithoutCreditTitleInput, CreditTitleRuralUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleRuralCreateWithoutCreditTitleInput, CreditTitleRuralUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleRuralWhereInput
  }

  export type CreditTitleRuralUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleRuralWhereInput
    data: XOR<CreditTitleRuralUpdateWithoutCreditTitleInput, CreditTitleRuralUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleRuralUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCRuralFieldUpdateOperationsInput | $Enums.TCRural
    safra?: NullableStringFieldUpdateOperationsInput | string | null
    produtoAgricola?: NullableStringFieldUpdateOperationsInput | string | null
    areaFinanciadaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    registroImovelRural?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleRuralUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCRuralFieldUpdateOperationsInput | $Enums.TCRural
    safra?: NullableStringFieldUpdateOperationsInput | string | null
    produtoAgricola?: NullableStringFieldUpdateOperationsInput | string | null
    areaFinanciadaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    registroImovelRural?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleImobiliarioUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleImobiliarioUpdateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleImobiliarioCreateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleImobiliarioWhereInput
  }

  export type CreditTitleImobiliarioUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleImobiliarioWhereInput
    data: XOR<CreditTitleImobiliarioUpdateWithoutCreditTitleInput, CreditTitleImobiliarioUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleImobiliarioUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCImobiliarioFieldUpdateOperationsInput | $Enums.TCImobiliario
    matriculaImovel?: StringFieldUpdateOperationsInput | string
    enderecoLogradouro?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: StringFieldUpdateOperationsInput | string
    enderecoComplemento?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoBairro?: StringFieldUpdateOperationsInput | string
    enderecoCidade?: StringFieldUpdateOperationsInput | string
    enderecoEstado?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    tipoGarantia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleImobiliarioUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCImobiliarioFieldUpdateOperationsInput | $Enums.TCImobiliario
    matriculaImovel?: StringFieldUpdateOperationsInput | string
    enderecoLogradouro?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: StringFieldUpdateOperationsInput | string
    enderecoComplemento?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoBairro?: StringFieldUpdateOperationsInput | string
    enderecoCidade?: StringFieldUpdateOperationsInput | string
    enderecoEstado?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    tipoGarantia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleAmbientalUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleAmbientalUpdateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleAmbientalCreateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleAmbientalWhereInput
  }

  export type CreditTitleAmbientalUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleAmbientalWhereInput
    data: XOR<CreditTitleAmbientalUpdateWithoutCreditTitleInput, CreditTitleAmbientalUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleAmbientalUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCAmbientalFieldUpdateOperationsInput | $Enums.TCAmbiental
    projetoVinculado?: NullableStringFieldUpdateOperationsInput | string | null
    metodologiaCertificacao?: NullableStringFieldUpdateOperationsInput | string | null
    toneladasCO2Equivalente?: NullableFloatFieldUpdateOperationsInput | number | null
    hectaresConservados?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeAguaEconomizadoM3?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditTitleAmbientalUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCAmbientalFieldUpdateOperationsInput | $Enums.TCAmbiental
    projetoVinculado?: NullableStringFieldUpdateOperationsInput | string | null
    metodologiaCertificacao?: NullableStringFieldUpdateOperationsInput | string | null
    toneladasCO2Equivalente?: NullableFloatFieldUpdateOperationsInput | number | null
    hectaresConservados?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeAguaEconomizadoM3?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditTitleEspecialUpsertWithoutCreditTitleInput = {
    update: XOR<CreditTitleEspecialUpdateWithoutCreditTitleInput, CreditTitleEspecialUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<CreditTitleEspecialCreateWithoutCreditTitleInput, CreditTitleEspecialUncheckedCreateWithoutCreditTitleInput>
    where?: CreditTitleEspecialWhereInput
  }

  export type CreditTitleEspecialUpdateToOneWithWhereWithoutCreditTitleInput = {
    where?: CreditTitleEspecialWhereInput
    data: XOR<CreditTitleEspecialUpdateWithoutCreditTitleInput, CreditTitleEspecialUncheckedUpdateWithoutCreditTitleInput>
  }

  export type CreditTitleEspecialUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCEspecialFieldUpdateOperationsInput | $Enums.TCEspecial
    processoRecuperacaoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    credorOriginal?: NullableStringFieldUpdateOperationsInput | string | null
    classeCreditoRJ?: NullableStringFieldUpdateOperationsInput | string | null
    administradoraConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    grupoConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    cotaConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditTitleEspecialUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    subType?: EnumTCEspecialFieldUpdateOperationsInput | $Enums.TCEspecial
    processoRecuperacaoJudicial?: NullableStringFieldUpdateOperationsInput | string | null
    credorOriginal?: NullableStringFieldUpdateOperationsInput | string | null
    classeCreditoRJ?: NullableStringFieldUpdateOperationsInput | string | null
    administradoraConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    grupoConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
    cotaConsorcio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutCreditTitleInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCreditTitleInput, DocumentUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<DocumentCreateWithoutCreditTitleInput, DocumentUncheckedCreateWithoutCreditTitleInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCreditTitleInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCreditTitleInput, DocumentUncheckedUpdateWithoutCreditTitleInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCreditTitleInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCreditTitleInput>
  }

  export type OfferUpsertWithWhereUniqueWithoutCreditTitleInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutCreditTitleInput, OfferUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<OfferCreateWithoutCreditTitleInput, OfferUncheckedCreateWithoutCreditTitleInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutCreditTitleInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutCreditTitleInput, OfferUncheckedUpdateWithoutCreditTitleInput>
  }

  export type OfferUpdateManyWithWhereWithoutCreditTitleInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutCreditTitleInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreditTitleInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreditTitleInput, TransactionUncheckedUpdateWithoutCreditTitleInput>
    create: XOR<TransactionCreateWithoutCreditTitleInput, TransactionUncheckedCreateWithoutCreditTitleInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreditTitleInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreditTitleInput, TransactionUncheckedUpdateWithoutCreditTitleInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreditTitleInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreditTitleInput>
  }

  export type AuctionUpsertWithWhereUniqueWithoutCreditInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutCreditInput, AuctionUncheckedUpdateWithoutCreditInput>
    create: XOR<AuctionCreateWithoutCreditInput, AuctionUncheckedCreateWithoutCreditInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutCreditInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutCreditInput, AuctionUncheckedUpdateWithoutCreditInput>
  }

  export type AuctionUpdateManyWithWhereWithoutCreditInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutCreditInput>
  }

  export type CreditTitleCreateWithoutDetailsTributarioInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsTributarioInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsTributarioInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsTributarioInput, CreditTitleUncheckedCreateWithoutDetailsTributarioInput>
  }

  export type CreditTitleUpsertWithoutDetailsTributarioInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsTributarioInput, CreditTitleUncheckedUpdateWithoutDetailsTributarioInput>
    create: XOR<CreditTitleCreateWithoutDetailsTributarioInput, CreditTitleUncheckedCreateWithoutDetailsTributarioInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsTributarioInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsTributarioInput, CreditTitleUncheckedUpdateWithoutDetailsTributarioInput>
  }

  export type CreditTitleUpdateWithoutDetailsTributarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsTributarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsComercialInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsComercialInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsComercialInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsComercialInput, CreditTitleUncheckedCreateWithoutDetailsComercialInput>
  }

  export type CreditTitleUpsertWithoutDetailsComercialInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsComercialInput, CreditTitleUncheckedUpdateWithoutDetailsComercialInput>
    create: XOR<CreditTitleCreateWithoutDetailsComercialInput, CreditTitleUncheckedCreateWithoutDetailsComercialInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsComercialInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsComercialInput, CreditTitleUncheckedUpdateWithoutDetailsComercialInput>
  }

  export type CreditTitleUpdateWithoutDetailsComercialInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsComercialInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsFinanceiroInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsFinanceiroInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsFinanceiroInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsFinanceiroInput, CreditTitleUncheckedCreateWithoutDetailsFinanceiroInput>
  }

  export type CreditTitleUpsertWithoutDetailsFinanceiroInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsFinanceiroInput, CreditTitleUncheckedUpdateWithoutDetailsFinanceiroInput>
    create: XOR<CreditTitleCreateWithoutDetailsFinanceiroInput, CreditTitleUncheckedCreateWithoutDetailsFinanceiroInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsFinanceiroInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsFinanceiroInput, CreditTitleUncheckedUpdateWithoutDetailsFinanceiroInput>
  }

  export type CreditTitleUpdateWithoutDetailsFinanceiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsFinanceiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsJudicialInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsJudicialInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsJudicialInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsJudicialInput, CreditTitleUncheckedCreateWithoutDetailsJudicialInput>
  }

  export type CreditTitleUpsertWithoutDetailsJudicialInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsJudicialInput, CreditTitleUncheckedUpdateWithoutDetailsJudicialInput>
    create: XOR<CreditTitleCreateWithoutDetailsJudicialInput, CreditTitleUncheckedCreateWithoutDetailsJudicialInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsJudicialInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsJudicialInput, CreditTitleUncheckedUpdateWithoutDetailsJudicialInput>
  }

  export type CreditTitleUpdateWithoutDetailsJudicialInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsJudicialInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsRuralInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsRuralInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsRuralInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsRuralInput, CreditTitleUncheckedCreateWithoutDetailsRuralInput>
  }

  export type CreditTitleUpsertWithoutDetailsRuralInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsRuralInput, CreditTitleUncheckedUpdateWithoutDetailsRuralInput>
    create: XOR<CreditTitleCreateWithoutDetailsRuralInput, CreditTitleUncheckedCreateWithoutDetailsRuralInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsRuralInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsRuralInput, CreditTitleUncheckedUpdateWithoutDetailsRuralInput>
  }

  export type CreditTitleUpdateWithoutDetailsRuralInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsRuralInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsImobiliarioInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsImobiliarioInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsImobiliarioInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsImobiliarioInput, CreditTitleUncheckedCreateWithoutDetailsImobiliarioInput>
  }

  export type CreditTitleUpsertWithoutDetailsImobiliarioInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsImobiliarioInput, CreditTitleUncheckedUpdateWithoutDetailsImobiliarioInput>
    create: XOR<CreditTitleCreateWithoutDetailsImobiliarioInput, CreditTitleUncheckedCreateWithoutDetailsImobiliarioInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsImobiliarioInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsImobiliarioInput, CreditTitleUncheckedUpdateWithoutDetailsImobiliarioInput>
  }

  export type CreditTitleUpdateWithoutDetailsImobiliarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsImobiliarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsAmbientalInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsAmbientalInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsAmbientalInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsAmbientalInput, CreditTitleUncheckedCreateWithoutDetailsAmbientalInput>
  }

  export type CreditTitleUpsertWithoutDetailsAmbientalInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsAmbientalInput, CreditTitleUncheckedUpdateWithoutDetailsAmbientalInput>
    create: XOR<CreditTitleCreateWithoutDetailsAmbientalInput, CreditTitleUncheckedCreateWithoutDetailsAmbientalInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsAmbientalInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsAmbientalInput, CreditTitleUncheckedUpdateWithoutDetailsAmbientalInput>
  }

  export type CreditTitleUpdateWithoutDetailsAmbientalInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsAmbientalInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDetailsEspecialInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDetailsEspecialInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDetailsEspecialInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDetailsEspecialInput, CreditTitleUncheckedCreateWithoutDetailsEspecialInput>
  }

  export type CreditTitleUpsertWithoutDetailsEspecialInput = {
    update: XOR<CreditTitleUpdateWithoutDetailsEspecialInput, CreditTitleUncheckedUpdateWithoutDetailsEspecialInput>
    create: XOR<CreditTitleCreateWithoutDetailsEspecialInput, CreditTitleUncheckedCreateWithoutDetailsEspecialInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDetailsEspecialInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDetailsEspecialInput, CreditTitleUncheckedUpdateWithoutDetailsEspecialInput>
  }

  export type CreditTitleUpdateWithoutDetailsEspecialInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDetailsEspecialInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleCreateWithoutDocumentsInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutDocumentsInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutDocumentsInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutDocumentsInput, CreditTitleUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type CreditTitleUpsertWithoutDocumentsInput = {
    update: XOR<CreditTitleUpdateWithoutDocumentsInput, CreditTitleUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CreditTitleCreateWithoutDocumentsInput, CreditTitleUncheckedCreateWithoutDocumentsInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutDocumentsInput, CreditTitleUncheckedUpdateWithoutDocumentsInput>
  }

  export type CreditTitleUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type CreditTitleCreateWithoutOffersInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutOffersInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutOffersInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutOffersInput, CreditTitleUncheckedCreateWithoutOffersInput>
  }

  export type UserCreateWithoutOffersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutOffersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutOffersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
  }

  export type BidCreateWithoutOfferInput = {
    id?: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder: UserCreateNestedOneWithoutBidsInput
    transactions?: TransactionCreateNestedManyWithoutBidInput
  }

  export type BidUncheckedCreateWithoutOfferInput = {
    id?: string
    bidderId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutBidInput
  }

  export type BidCreateOrConnectWithoutOfferInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutOfferInput, BidUncheckedCreateWithoutOfferInput>
  }

  export type BidCreateManyOfferInputEnvelope = {
    data: BidCreateManyOfferInput | BidCreateManyOfferInput[]
  }

  export type TransactionCreateWithoutOfferInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutTransactionsInput
    seller: UserCreateNestedOneWithoutTransactionsAsSellerInput
    buyer: UserCreateNestedOneWithoutTransactionsAsBuyerInput
    bid?: BidCreateNestedOneWithoutTransactionsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutOfferInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutOfferInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput>
  }

  export type TransactionCreateManyOfferInputEnvelope = {
    data: TransactionCreateManyOfferInput | TransactionCreateManyOfferInput[]
  }

  export type CreditTitleUpsertWithoutOffersInput = {
    update: XOR<CreditTitleUpdateWithoutOffersInput, CreditTitleUncheckedUpdateWithoutOffersInput>
    create: XOR<CreditTitleCreateWithoutOffersInput, CreditTitleUncheckedCreateWithoutOffersInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutOffersInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutOffersInput, CreditTitleUncheckedUpdateWithoutOffersInput>
  }

  export type CreditTitleUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type UserUpsertWithoutOffersInput = {
    update: XOR<UserUpdateWithoutOffersInput, UserUncheckedUpdateWithoutOffersInput>
    create: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOffersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOffersInput, UserUncheckedUpdateWithoutOffersInput>
  }

  export type UserUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type BidUpsertWithWhereUniqueWithoutOfferInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutOfferInput, BidUncheckedUpdateWithoutOfferInput>
    create: XOR<BidCreateWithoutOfferInput, BidUncheckedCreateWithoutOfferInput>
  }

  export type BidUpdateWithWhereUniqueWithoutOfferInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutOfferInput, BidUncheckedUpdateWithoutOfferInput>
  }

  export type BidUpdateManyWithWhereWithoutOfferInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutOfferInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutOfferInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutOfferInput, TransactionUncheckedUpdateWithoutOfferInput>
    create: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutOfferInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutOfferInput, TransactionUncheckedUpdateWithoutOfferInput>
  }

  export type TransactionUpdateManyWithWhereWithoutOfferInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutOfferInput>
  }

  export type OfferCreateWithoutBidsInput = {
    id?: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutOffersInput
    seller: UserCreateNestedOneWithoutOffersInput
    transactions?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutBidsInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutBidsInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutBidsInput, OfferUncheckedCreateWithoutBidsInput>
  }

  export type UserCreateWithoutBidsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutBidsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutBidsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
  }

  export type TransactionCreateWithoutBidInput = {
    id?: string
    price: number
    quantity?: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutTransactionsInput
    seller: UserCreateNestedOneWithoutTransactionsAsSellerInput
    buyer: UserCreateNestedOneWithoutTransactionsAsBuyerInput
    offer?: OfferCreateNestedOneWithoutTransactionsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBidInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutBidInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBidInput, TransactionUncheckedCreateWithoutBidInput>
  }

  export type TransactionCreateManyBidInputEnvelope = {
    data: TransactionCreateManyBidInput | TransactionCreateManyBidInput[]
  }

  export type OfferUpsertWithoutBidsInput = {
    update: XOR<OfferUpdateWithoutBidsInput, OfferUncheckedUpdateWithoutBidsInput>
    create: XOR<OfferCreateWithoutBidsInput, OfferUncheckedCreateWithoutBidsInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutBidsInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutBidsInput, OfferUncheckedUpdateWithoutBidsInput>
  }

  export type OfferUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutOffersNestedInput
    seller?: UserUpdateOneRequiredWithoutOffersNestedInput
    transactions?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type UserUpsertWithoutBidsInput = {
    update: XOR<UserUpdateWithoutBidsInput, UserUncheckedUpdateWithoutBidsInput>
    create: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBidsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBidsInput, UserUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutBidInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBidInput, TransactionUncheckedUpdateWithoutBidInput>
    create: XOR<TransactionCreateWithoutBidInput, TransactionUncheckedCreateWithoutBidInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBidInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBidInput, TransactionUncheckedUpdateWithoutBidInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBidInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBidInput>
  }

  export type CreditTitleCreateWithoutTransactionsInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleUncheckedCreateWithoutTransactionsInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditTitleCreateOrConnectWithoutTransactionsInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutTransactionsInput, CreditTitleUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsAsSellerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutTransactionsAsSellerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutTransactionsAsSellerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsAsSellerInput, UserUncheckedCreateWithoutTransactionsAsSellerInput>
  }

  export type UserCreateWithoutTransactionsAsBuyerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutTransactionsAsBuyerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutTransactionsAsBuyerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsAsBuyerInput, UserUncheckedCreateWithoutTransactionsAsBuyerInput>
  }

  export type OfferCreateWithoutTransactionsInput = {
    id?: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creditTitle: CreditTitleCreateNestedOneWithoutOffersInput
    seller: UserCreateNestedOneWithoutOffersInput
    bids?: BidCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutTransactionsInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutTransactionsInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutTransactionsInput, OfferUncheckedCreateWithoutTransactionsInput>
  }

  export type BidCreateWithoutTransactionsInput = {
    id?: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    offer: OfferCreateNestedOneWithoutBidsInput
    bidder: UserCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutTransactionsInput = {
    id?: string
    offerId: string
    bidderId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutTransactionsInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutTransactionsInput, BidUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutCreatedTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutCreatedTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutCreatedTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
  }

  export type CreditTitleUpsertWithoutTransactionsInput = {
    update: XOR<CreditTitleUpdateWithoutTransactionsInput, CreditTitleUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CreditTitleCreateWithoutTransactionsInput, CreditTitleUncheckedCreateWithoutTransactionsInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutTransactionsInput, CreditTitleUncheckedUpdateWithoutTransactionsInput>
  }

  export type CreditTitleUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type UserUpsertWithoutTransactionsAsSellerInput = {
    update: XOR<UserUpdateWithoutTransactionsAsSellerInput, UserUncheckedUpdateWithoutTransactionsAsSellerInput>
    create: XOR<UserCreateWithoutTransactionsAsSellerInput, UserUncheckedCreateWithoutTransactionsAsSellerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsAsSellerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsAsSellerInput, UserUncheckedUpdateWithoutTransactionsAsSellerInput>
  }

  export type UserUpdateWithoutTransactionsAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUpsertWithoutTransactionsAsBuyerInput = {
    update: XOR<UserUpdateWithoutTransactionsAsBuyerInput, UserUncheckedUpdateWithoutTransactionsAsBuyerInput>
    create: XOR<UserCreateWithoutTransactionsAsBuyerInput, UserUncheckedCreateWithoutTransactionsAsBuyerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsAsBuyerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsAsBuyerInput, UserUncheckedUpdateWithoutTransactionsAsBuyerInput>
  }

  export type UserUpdateWithoutTransactionsAsBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsAsBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type OfferUpsertWithoutTransactionsInput = {
    update: XOR<OfferUpdateWithoutTransactionsInput, OfferUncheckedUpdateWithoutTransactionsInput>
    create: XOR<OfferCreateWithoutTransactionsInput, OfferUncheckedCreateWithoutTransactionsInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutTransactionsInput, OfferUncheckedUpdateWithoutTransactionsInput>
  }

  export type OfferUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutOffersNestedInput
    seller?: UserUpdateOneRequiredWithoutOffersNestedInput
    bids?: BidUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type BidUpsertWithoutTransactionsInput = {
    update: XOR<BidUpdateWithoutTransactionsInput, BidUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BidCreateWithoutTransactionsInput, BidUncheckedCreateWithoutTransactionsInput>
    where?: BidWhereInput
  }

  export type BidUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BidWhereInput
    data: XOR<BidUpdateWithoutTransactionsInput, BidUncheckedUpdateWithoutTransactionsInput>
  }

  export type BidUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneRequiredWithoutBidsNestedInput
    bidder?: UserUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedTransactionsInput = {
    update: XOR<UserUpdateWithoutCreatedTransactionsInput, UserUncheckedUpdateWithoutCreatedTransactionsInput>
    create: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTransactionsInput, UserUncheckedUpdateWithoutCreatedTransactionsInput>
  }

  export type UserUpdateWithoutCreatedTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type CreditTitleCreateWithoutAuctionsInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: UserCreateNestedOneWithoutIssuedCreditsInput
    owner: UserCreateNestedOneWithoutOwnedCreditsInput
    detailsTributario?: CreditTitleTributarioCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentCreateNestedManyWithoutCreditTitleInput
    offers?: OfferCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionCreateNestedManyWithoutCreditTitleInput
  }

  export type CreditTitleUncheckedCreateWithoutAuctionsInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsTributario?: CreditTitleTributarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsComercial?: CreditTitleComercialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsJudicial?: CreditTitleJudicialUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsRural?: CreditTitleRuralUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedCreateNestedOneWithoutCreditTitleInput
    detailsEspecial?: CreditTitleEspecialUncheckedCreateNestedOneWithoutCreditTitleInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCreditTitleInput
    offers?: OfferUncheckedCreateNestedManyWithoutCreditTitleInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditTitleInput
  }

  export type CreditTitleCreateOrConnectWithoutAuctionsInput = {
    where: CreditTitleWhereUniqueInput
    create: XOR<CreditTitleCreateWithoutAuctionsInput, CreditTitleUncheckedCreateWithoutAuctionsInput>
  }

  export type UserCreateWithoutAuctionsAsSellerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutAuctionsAsSellerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutAuctionsAsSellerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuctionsAsSellerInput, UserUncheckedCreateWithoutAuctionsAsSellerInput>
  }

  export type UserCreateWithoutAuctionsAsWinnerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutAuctionsAsWinnerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutAuctionsAsWinnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuctionsAsWinnerInput, UserUncheckedCreateWithoutAuctionsAsWinnerInput>
  }

  export type CreditTitleUpsertWithoutAuctionsInput = {
    update: XOR<CreditTitleUpdateWithoutAuctionsInput, CreditTitleUncheckedUpdateWithoutAuctionsInput>
    create: XOR<CreditTitleCreateWithoutAuctionsInput, CreditTitleUncheckedCreateWithoutAuctionsInput>
    where?: CreditTitleWhereInput
  }

  export type CreditTitleUpdateToOneWithWhereWithoutAuctionsInput = {
    where?: CreditTitleWhereInput
    data: XOR<CreditTitleUpdateWithoutAuctionsInput, CreditTitleUncheckedUpdateWithoutAuctionsInput>
  }

  export type CreditTitleUpdateWithoutAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
  }

  export type UserUpsertWithoutAuctionsAsSellerInput = {
    update: XOR<UserUpdateWithoutAuctionsAsSellerInput, UserUncheckedUpdateWithoutAuctionsAsSellerInput>
    create: XOR<UserCreateWithoutAuctionsAsSellerInput, UserUncheckedCreateWithoutAuctionsAsSellerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuctionsAsSellerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuctionsAsSellerInput, UserUncheckedUpdateWithoutAuctionsAsSellerInput>
  }

  export type UserUpdateWithoutAuctionsAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutAuctionsAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUpsertWithoutAuctionsAsWinnerInput = {
    update: XOR<UserUpdateWithoutAuctionsAsWinnerInput, UserUncheckedUpdateWithoutAuctionsAsWinnerInput>
    create: XOR<UserCreateWithoutAuctionsAsWinnerInput, UserUncheckedCreateWithoutAuctionsAsWinnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuctionsAsWinnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuctionsAsWinnerInput, UserUncheckedUpdateWithoutAuctionsAsWinnerInput>
  }

  export type UserUpdateWithoutAuctionsAsWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutAuctionsAsWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type SettlementParticipantCreateWithoutSettlementInput = {
    id?: string
    role: string
    value: number
    status: string
    user: UserCreateNestedOneWithoutSettlementParticipantsInput
  }

  export type SettlementParticipantUncheckedCreateWithoutSettlementInput = {
    id?: string
    userId: string
    role: string
    value: number
    status: string
  }

  export type SettlementParticipantCreateOrConnectWithoutSettlementInput = {
    where: SettlementParticipantWhereUniqueInput
    create: XOR<SettlementParticipantCreateWithoutSettlementInput, SettlementParticipantUncheckedCreateWithoutSettlementInput>
  }

  export type SettlementParticipantCreateManySettlementInputEnvelope = {
    data: SettlementParticipantCreateManySettlementInput | SettlementParticipantCreateManySettlementInput[]
  }

  export type SettlementParticipantUpsertWithWhereUniqueWithoutSettlementInput = {
    where: SettlementParticipantWhereUniqueInput
    update: XOR<SettlementParticipantUpdateWithoutSettlementInput, SettlementParticipantUncheckedUpdateWithoutSettlementInput>
    create: XOR<SettlementParticipantCreateWithoutSettlementInput, SettlementParticipantUncheckedCreateWithoutSettlementInput>
  }

  export type SettlementParticipantUpdateWithWhereUniqueWithoutSettlementInput = {
    where: SettlementParticipantWhereUniqueInput
    data: XOR<SettlementParticipantUpdateWithoutSettlementInput, SettlementParticipantUncheckedUpdateWithoutSettlementInput>
  }

  export type SettlementParticipantUpdateManyWithWhereWithoutSettlementInput = {
    where: SettlementParticipantScalarWhereInput
    data: XOR<SettlementParticipantUpdateManyMutationInput, SettlementParticipantUncheckedUpdateManyWithoutSettlementInput>
  }

  export type SettlementCreateWithoutParticipantsInput = {
    id?: string
    type: string
    status: string
    totalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUncheckedCreateWithoutParticipantsInput = {
    id?: string
    type: string
    status: string
    totalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementCreateOrConnectWithoutParticipantsInput = {
    where: SettlementWhereUniqueInput
    create: XOR<SettlementCreateWithoutParticipantsInput, SettlementUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutSettlementParticipantsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutSettlementParticipantsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutSettlementParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettlementParticipantsInput, UserUncheckedCreateWithoutSettlementParticipantsInput>
  }

  export type SettlementUpsertWithoutParticipantsInput = {
    update: XOR<SettlementUpdateWithoutParticipantsInput, SettlementUncheckedUpdateWithoutParticipantsInput>
    create: XOR<SettlementCreateWithoutParticipantsInput, SettlementUncheckedCreateWithoutParticipantsInput>
    where?: SettlementWhereInput
  }

  export type SettlementUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: SettlementWhereInput
    data: XOR<SettlementUpdateWithoutParticipantsInput, SettlementUncheckedUpdateWithoutParticipantsInput>
  }

  export type SettlementUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSettlementParticipantsInput = {
    update: XOR<UserUpdateWithoutSettlementParticipantsInput, UserUncheckedUpdateWithoutSettlementParticipantsInput>
    create: XOR<UserCreateWithoutSettlementParticipantsInput, UserUncheckedCreateWithoutSettlementParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettlementParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettlementParticipantsInput, UserUncheckedUpdateWithoutSettlementParticipantsInput>
  }

  export type UserUpdateWithoutSettlementParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutSettlementParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    fiscalObligations?: FiscalObligationUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    fiscalObligations?: FiscalObligationUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserCreateWithoutFiscalObligationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleCreateNestedManyWithoutOwnerInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    offers?: OfferCreateNestedManyWithoutSellerInput
    bids?: BidCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserUncheckedCreateWithoutFiscalObligationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    issuedCredits?: CreditTitleUncheckedCreateNestedManyWithoutIssuerInput
    ownedCredits?: CreditTitleUncheckedCreateNestedManyWithoutOwnerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    offers?: OfferUncheckedCreateNestedManyWithoutSellerInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderInput
    transactionsAsSeller?: TransactionUncheckedCreateNestedManyWithoutSellerInput
    transactionsAsBuyer?: TransactionUncheckedCreateNestedManyWithoutBuyerInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatedByInput
    auctionsAsSeller?: AuctionUncheckedCreateNestedManyWithoutSellerInput
    auctionsAsWinner?: AuctionUncheckedCreateNestedManyWithoutWinnerInput
    settlementParticipants?: SettlementParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    empresasRepresentadas?: EmpresaUncheckedCreateNestedManyWithoutRepresentantePrincipalInput
  }

  export type UserCreateOrConnectWithoutFiscalObligationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFiscalObligationsInput, UserUncheckedCreateWithoutFiscalObligationsInput>
  }

  export type UserUpsertWithoutFiscalObligationsInput = {
    update: XOR<UserUpdateWithoutFiscalObligationsInput, UserUncheckedUpdateWithoutFiscalObligationsInput>
    create: XOR<UserCreateWithoutFiscalObligationsInput, UserUncheckedCreateWithoutFiscalObligationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFiscalObligationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFiscalObligationsInput, UserUncheckedUpdateWithoutFiscalObligationsInput>
  }

  export type UserUpdateWithoutFiscalObligationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUpdateManyWithoutSellerNestedInput
    bids?: BidUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type UserUncheckedUpdateWithoutFiscalObligationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    issuedCredits?: CreditTitleUncheckedUpdateManyWithoutIssuerNestedInput
    ownedCredits?: CreditTitleUncheckedUpdateManyWithoutOwnerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    offers?: OfferUncheckedUpdateManyWithoutSellerNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderNestedInput
    transactionsAsSeller?: TransactionUncheckedUpdateManyWithoutSellerNestedInput
    transactionsAsBuyer?: TransactionUncheckedUpdateManyWithoutBuyerNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    auctionsAsSeller?: AuctionUncheckedUpdateManyWithoutSellerNestedInput
    auctionsAsWinner?: AuctionUncheckedUpdateManyWithoutWinnerNestedInput
    settlementParticipants?: SettlementParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    empresasRepresentadas?: EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type CreditTitleCreateManyIssuerInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    ownerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditTitleCreateManyOwnerInput = {
    id?: string
    category: $Enums.CreditCategory
    valueNominal: number
    valueCurrent: number
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuerId: string
    status?: $Enums.CreditStatus
    tokenId?: string | null
    tokenStandard?: string | null
    blockchainTxHash?: string | null
    isListed?: boolean
    listingPrice?: number | null
    listingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyUploadedByInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    creditTitleId: string
    uploadedAt?: Date | string
  }

  export type OfferCreateManySellerInput = {
    id?: string
    creditTitleId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateManyBidderInput = {
    id?: string
    offerId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySellerInput = {
    id?: string
    creditTitleId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyBuyerInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCreatedByInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateManySellerInput = {
    id?: string
    creditId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    winnerId?: string | null
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateManyWinnerInput = {
    id?: string
    creditId: string
    sellerId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementParticipantCreateManyUserInput = {
    id?: string
    settlementId: string
    role: string
    value: number
    status: string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type FiscalObligationCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status: string
    amount: number
    currency: string
    dueDate: Date | string
    taxCode?: string | null
    taxName?: string | null
    taxType?: string | null
    taxPeriod?: string | null
    taxBase?: number | null
    taxRate?: number | null
    taxValue?: number | null
    taxInterest?: number | null
    taxFine?: number | null
    taxTotal?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaCreateManyRepresentantePrincipalInput = {
    id?: string
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj: string
    inscEstadual?: string | null
    inscMunicipal?: string | null
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    website?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTitleUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateManyWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTitleUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: UserUpdateOneRequiredWithoutIssuedCreditsNestedInput
    detailsTributario?: CreditTitleTributarioUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsTributario?: CreditTitleTributarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsComercial?: CreditTitleComercialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsFinanceiro?: CreditTitleFinanceiroUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsJudicial?: CreditTitleJudicialUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsRural?: CreditTitleRuralUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsImobiliario?: CreditTitleImobiliarioUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsAmbiental?: CreditTitleAmbientalUncheckedUpdateOneWithoutCreditTitleNestedInput
    detailsEspecial?: CreditTitleEspecialUncheckedUpdateOneWithoutCreditTitleNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCreditTitleNestedInput
    offers?: OfferUncheckedUpdateManyWithoutCreditTitleNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreditTitleNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutCreditNestedInput
  }

  export type CreditTitleUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCreditCategoryFieldUpdateOperationsInput | $Enums.CreditCategory
    valueNominal?: FloatFieldUpdateOperationsInput | number
    valueCurrent?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenStandard?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    isListed?: BoolFieldUpdateOperationsInput | boolean
    listingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitleId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    creditTitleId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutOffersNestedInput
    bids?: BidUpdateManyWithoutOfferNestedInput
    transactions?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutOfferNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneRequiredWithoutBidsNestedInput
    transactions?: TransactionUpdateManyWithoutBidNestedInput
  }

  export type BidUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutBidNestedInput
  }

  export type BidUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput
    buyer?: UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput
    offer?: OfferUpdateOneWithoutTransactionsNestedInput
    bid?: BidUpdateOneWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput
    seller?: UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput
    offer?: OfferUpdateOneWithoutTransactionsNestedInput
    bid?: BidUpdateOneWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput
    seller?: UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput
    offer?: OfferUpdateOneWithoutTransactionsNestedInput
    bid?: BidUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: CreditTitleUpdateOneRequiredWithoutAuctionsNestedInput
    winner?: UserUpdateOneWithoutAuctionsAsWinnerNestedInput
  }

  export type AuctionUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: CreditTitleUpdateOneRequiredWithoutAuctionsNestedInput
    seller?: UserUpdateOneRequiredWithoutAuctionsAsSellerNestedInput
  }

  export type AuctionUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUncheckedUpdateManyWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    settlement?: SettlementUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type SettlementParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settlementId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SettlementParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settlementId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalObligationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalObligationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalObligationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxBase?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    taxInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    taxFine?: NullableFloatFieldUpdateOperationsInput | number | null
    taxTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUpdateWithoutRepresentantePrincipalInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateWithoutRepresentantePrincipalInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateManyWithoutRepresentantePrincipalInput = {
    id?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    inscEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    inscMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyCreditTitleInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    isPublic?: boolean
    mimeType: string
    size: number
    storageLocation: string
    hash?: string | null
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type OfferCreateManyCreditTitleInput = {
    id?: string
    sellerId: string
    price: number
    expiryDate?: Date | string | null
    terms?: string | null
    quantityAvailable?: number
    offerType?: $Enums.OfferType
    minBidIncrement?: number | null
    reservePrice?: number | null
    allowPartialPurchase?: boolean
    status?: $Enums.OfferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCreditTitleInput = {
    id?: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateManyCreditInput = {
    id?: string
    sellerId: string
    type: string
    startPrice: number
    minPrice?: number | null
    startDate: Date | string
    endDate: Date | string
    status: string
    winnerId?: string | null
    finalPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storageLocation?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutOffersNestedInput
    bids?: BidUpdateManyWithoutOfferNestedInput
    transactions?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutOfferNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    minBidIncrement?: NullableFloatFieldUpdateOperationsInput | number | null
    reservePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPartialPurchase?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput
    offer?: OfferUpdateOneWithoutTransactionsNestedInput
    bid?: BidUpdateOneWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCreditTitleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutAuctionsAsSellerNestedInput
    winner?: UserUpdateOneWithoutAuctionsAsWinnerNestedInput
  }

  export type AuctionUncheckedUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUncheckedUpdateManyWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startPrice?: FloatFieldUpdateOperationsInput | number
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateManyOfferInput = {
    id?: string
    bidderId: string
    amount: number
    quantity?: number
    notes?: string | null
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyOfferInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    bidId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneRequiredWithoutBidsNestedInput
    transactions?: TransactionUpdateManyWithoutBidNestedInput
  }

  export type BidUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutBidNestedInput
  }

  export type BidUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput
    seller?: UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput
    bid?: BidUpdateOneWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    bidId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyBidInput = {
    id?: string
    creditTitleId: string
    sellerId: string
    buyerId: string
    price: number
    quantity?: number
    offerId?: string | null
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    notes?: string | null
    blockchainData?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditTitle?: CreditTitleUpdateOneRequiredWithoutTransactionsNestedInput
    seller?: UserUpdateOneRequiredWithoutTransactionsAsSellerNestedInput
    buyer?: UserUpdateOneRequiredWithoutTransactionsAsBuyerNestedInput
    offer?: OfferUpdateOneWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditTitleId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockchainData?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementParticipantCreateManySettlementInput = {
    id?: string
    userId: string
    role: string
    value: number
    status: string
  }

  export type SettlementParticipantUpdateWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSettlementParticipantsNestedInput
  }

  export type SettlementParticipantUncheckedUpdateWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SettlementParticipantUncheckedUpdateManyWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}